---
ver: rpa2
title: Protocols for Verifying Smooth Strategies in Bandits and Games
arxiv_id: '2507.10567'
source_url: https://arxiv.org/abs/2507.10567
tags:
- smooth
- strategy
- verifier
- bandit
- protocol
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: This paper introduces interactive proof protocols for verifying
  approximate optimality of strategies in multi-armed bandits and normal-form games.
  The key idea is to leverage smoothness of strategies (distributions not concentrated
  on few actions) to design sublinear verification protocols.
---

# Protocols for Verifying Smooth Strategies in Bandits and Games

## Quick Facts
- **arXiv ID:** 2507.10567
- **Source URL:** https://arxiv.org/abs/2507.10567
- **Reference count:** 40
- **Primary result:** Sublinear verification protocols for smooth strategies in bandits and games using O(nσ/ε²) queries instead of Ω(n) learning queries

## Executive Summary
This paper introduces interactive proof protocols for verifying approximate optimality of strategies in multi-armed bandits and normal-form games. The key innovation is leveraging smoothness constraints (distributions not concentrated on few actions) to design verification protocols that require sublinear queries. For multi-armed bandits, they provide a protocol that verifies an ε-optimal σ-smooth strategy using O(nσ/ε² log(nσ/ε) log(1/ε)) queries, significantly less than the Ω(n) queries needed for learning. They also establish a matching lower bound and use cryptographic tools (SNARKs and vector commitments) to reduce communication complexity. For normal-form games, they extend this approach to verify approximate strong σ-smooth Nash equilibria with O(k nσ/η² log(nσ/η) log(1/η) k log k) queries.

## Method Summary
The method involves creating interactive proof systems where a prover claims to know an optimal smooth strategy, and a verifier checks this claim with sublinear queries. The core approach partitions potential lies into logarithmic bins by magnitude, then randomly samples arms from each bin to detect inconsistencies. For games, verification reduces to k independent bandit verification subproblems (one per player). The cryptographic variant uses vector commitments and SNARKs to reduce communication from O(n) to O(λ) bits while preserving soundness.

## Key Results
- Proves that verifying ε-optimal σ-smooth bandit strategies requires O(nσ/ε² log(nσ/ε) log(1/ε)) queries
- Establishes matching lower bound showing this is optimal
- Extends verification to approximate strong σ-smooth Nash equilibria in k-player games
- Introduces cryptographic protocol reducing communication to O(λ) bits using SNARKs and vector commitments
- Shows verification can be substantially more efficient than learning in large action spaces

## Why This Works (Mechanism)

### Mechanism 1
- **Claim:** Verifying smooth strategies requires sublinear queries because a dishonest prover must lie about many arms to hide the existence of better smooth alternatives.
- **Mechanism:** If the prover misreports utilities enough to distort optimal policy value by ε, then for some lie magnitude α affecting a β-fraction of arms, βnσα ≥ ε. The verifier randomly samples O(1/β) arms and queries each O(1/α²) times to detect inconsistencies. By smoothness constraints, this yields O(nσ/ε²) total queries.
- **Core assumption:** Strategies are σ-smooth (no single action receives probability mass > σ).
- **Evidence anchors:** [abstract] "We prove that such verification is possible for sufficiently smooth strategies that do not put too much probability mass on any specific action."

### Mechanism 2
- **Claim:** Verifying smooth Nash equilibria reduces to k independent bandit verification subproblems.
- **Mechanism:** For each player i, fixing opponents' strategies π_{-i} creates a bandit where player i's n actions each have fixed reward distributions (determined by π_{-i}). Verifying no profitable smooth deviation for player i is exactly verifying that π_i is approximately optimal for this induced bandit.
- **Core assumption:** Query access to the game oracle that returns payoffs for sampled action profiles.
- **Evidence anchors:** [section 6.2] "Observe that for each action j ∈ [n], π specifies a distribution over player i's utility...This induces an n-arm bandit, denoted B(i, u, π)."

### Mechanism 3
- **Claim:** Cryptographic primitives (SNARKs + vector commitments) reduce communication from O(n) to O(λ) bits while preserving verification soundness.
- **Mechanism:** The prover commits to the utility vector û via vector commitment (O(λ) bits), then uses a SNARK to prove "the optimal σ-smooth policy for û has value t" without revealing û. The verifier queries specific indices; the prover provides O(λ)-sized opening proofs for each queried component.
- **Core assumption:** Computational knowledge soundness of SNARKs and position binding of vector commitments under standard cryptographic assumptions.
- **Evidence anchors:** [section 5.2.2] "The prover sends a commitment to the vector ũ of purported rewards, rather than sending ũ in full."

## Foundational Learning

- **Concept: Multi-Armed Bandit (MAB) Query Complexity**
  - Why needed here: Understanding why learning requires Ω(n) queries establishes the baseline that verification improves upon.
  - Quick check question: Why can't you find an ε-optimal strategy with o(n) queries without a prover? (Answer: In the worst case, the best arm could be any of n arms; you must sample most to identify it.)

- **Concept: Interactive Proof Systems (Completeness & Soundness)**
  - Why needed here: The paper's protocols are formalized as interactive proofs; understanding the security guarantees is essential.
  - Quick check question: What probability threshold must both completeness and soundness satisfy? (Answer: ≥ 2/3, amplifiable to 1-δ.)

- **Concept: Smooth Strategies and Nash Equilibria**
  - Why needed here: The verification protocols only work for σ-smooth strategies; this constraint is fundamental to the sublinear query complexity.
  - Quick check question: What is the smoothest possible strategy for n actions? (Answer: Uniform distribution, σ = 1/n.)

## Architecture Onboarding

- **Component map:** Game Oracle -> Protocol Core -> Crypto Layer -> Optimal Strategy Computation
- **Critical path:** 1. Prover estimates all n arm utilities (requires O(n/ε²) queries). 2. Prover computes and sends purported optimal smooth strategy (or commits + SNARK). 3. Verifier iterates over log(1/ε) bins, sampling O(nσ/ε²) arms total. 4. Verifier rejects if any prover estimate differs from empirical estimate beyond bin threshold.
- **Design tradeoffs:** Query vs. Communication: Basic protocol uses O(n log(1/ε)) bits; crypto variant uses O(λ) bits but requires trusted setup and stronger assumptions. Completeness vs. Slackness: Game verification requires an η slackness parameter because stochastic oracles cannot distinguish ε from ε + tiny gaps deterministically. Adaptive vs. Non-adaptive queries: All protocols use non-adaptive queries for simplicity and parallelizability.
- **Failure signatures:** Prover lies about many arms by small amounts: Verifier catches with high probability due to binning strategy. Prover lies about few arms by large amounts: Each lie is easy to detect; sampling catches at least one. Strategy is not σ-smooth: Verifier rejects immediately by checking probability constraints.
- **First 3 experiments:** 1. Sanity check on synthetic bandit: Create an n=1000 arm bandit with known smooth optimal strategy; verify Protocol 1 achieves ≥ 2/3 success rate with O(nσ/ε²) queries. 2. Lower bound validation: Implement the coin-bias reduction from Appendix A.5; confirm that any verifier with o(nσ/ε²) queries fails to detect adversarial provers. 3. Crypto communication overhead: Implement Protocol 4 with a standard SNARK library (e.g., Groth16); measure actual bit transmission vs. theoretical O(λ·nσ log(1/ε)/ε) bound.

## Open Questions the Paper Calls Out

### Open Question 1
- Question: Can these interactive proof protocols for verifying approximate optimality be extended to general Reinforcement Learning (RL) settings beyond the multi-armed bandit model?
- Basis in paper: [explicit] The conclusion states, "One direction is to study verification for reinforcement learning ... beyond the bandit setting."
- Why unresolved: The current work focuses on bandits (single-step) and normal-form games; the complexity of verification in multi-step Markov Decision Processes (MDPs) remains unexplored.
- What evidence would resolve it: A formal protocol for verifying value functions or policies in MDPs with bounded query complexity.

### Open Question 2
- Question: Can verification protocols be designed for extensive-form games (games with sequential moves and imperfect information) rather than just normal-form games?
- Basis in paper: [explicit] The conclusion suggests examining "interactive proofs ... for extensive form games."
- Why unresolved: The paper models games as simultaneous single-shot interactions (normal-form); extensive-form games require handling game trees and information sets, complicating the oracle query model.
- What evidence would resolve it: A verification protocol defined for extensive-form game oracles with proven completeness and soundness.

### Open Question 3
- Question: Can the requirement for cryptographic primitives (SNARKs and vector commitments) be removed while maintaining sublinear communication complexity?
- Basis in paper: [inferred] The paper uses cryptographic tools to reduce communication in Lemma 5.7, implying it is unknown if this efficiency can be achieved information-theoretically.
- Why unresolved: The low-communication protocol explicitly relies on the computational soundness of SNARKs; the paper does not offer a non-cryptographic alternative for sublinear communication.
- What evidence would resolve it: A protocol achieving the communication bounds of Lemma 5.7 without relying on computational hardness assumptions.

### Open Question 4
- Question: Is the "slackness" parameter (η) strictly necessary for verifying approximate Nash equilibria in games?
- Basis in paper: [inferred] Remark 2.1 states that slackness is "necessitated" to create a gap for stochastic oracles, but leaves open whether this is a fundamental barrier or a limitation of the specific construction.
- Why unresolved: The paper asserts the difficulty of distinguishing ε-optimal from (ε+δ)-optimal profiles with stochastic queries but does not prove a lower bound on the impossibility of zero slackness.
- What evidence would resolve it: A proof that zero-slackness verification requires linear queries or a protocol that achieves it with sublinear queries.

## Limitations
- Smoothness parameter σ creates fundamental tradeoff: as σ approaches 1/n, verification efficiency degrades toward Ω(n), eliminating sublinear advantage
- Cryptographic implementation represents highest uncertainty area requiring careful engineering
- Lower bound proof relies on coin-bias reduction that may not capture all realistic adversarial strategies
- Practical performance in extremely large action spaces (millions of arms) remains untested

## Confidence
- **High Confidence:** Query complexity bounds for basic bandit verification protocol are mathematically rigorous with explicit proofs and matching lower bounds
- **Medium Confidence:** Game verification protocol extension inherits correctness from bandit protocol but η-slackness parameter introduces approximation
- **Medium Confidence:** Cryptographic protocol security relies on standard assumptions requiring careful implementation
- **Low Confidence:** Practical performance in high-dimensional settings has not been empirically validated

## Next Checks
1. **Lower Bound Tightness:** Implement the coin-bias reduction from Appendix A.5 and verify that verification protocols with o(nσ/ε²) queries fail to distinguish honest from adversarial provers with probability ≥ 1/3
2. **Smoothness Degradation:** Systematically vary σ from 1/n to 1 in synthetic experiments and measure how verification query complexity scales, confirming it matches the theoretical O(nσ/ε²) relationship
3. **Crypto Implementation Security:** Build a prototype of Protocol 4 using standard libraries (e.g., Arkworks for SNARKs) and test whether computational soundness holds against adaptive adversaries who may exploit implementation-specific side channels