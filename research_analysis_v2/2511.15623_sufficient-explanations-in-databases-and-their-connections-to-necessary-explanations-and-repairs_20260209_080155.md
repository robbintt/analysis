---
ver: rpa2
title: Sufficient Explanations in Databases and their Connections to Necessary Explanations
  and Repairs
arxiv_id: '2511.15623'
source_url: https://arxiv.org/abs/2511.15623
tags:
- tuples
- core
- query
- repairs
- explanations
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: This paper introduces the concept of sufficient explanations for
  query answers in relational databases and investigates their connections to database
  repairs and necessary explanations. The authors formalize the notion of tuple-based
  sufficient explanations for monotone queries and introduce a quantitative sufficiency
  score to measure the strength of sufficiency.
---

# Sufficient Explanations in Databases and their Connections to Necessary Explanations and Repairs

## Quick Facts
- **arXiv ID**: 2511.15623
- **Source URL**: https://arxiv.org/abs/2511.15623
- **Reference count**: 40
- **Primary result**: Introduces tuple-based sufficient explanations for monotone queries with quantitative sufficiency scores and establishes connections to database repairs and necessary explanations

## Executive Summary
This paper introduces the concept of sufficient explanations for query answers in relational databases and investigates their connections to database repairs and necessary explanations. The authors formalize the notion of tuple-based sufficient explanations for monotone queries and introduce a quantitative sufficiency score to measure the strength of sufficiency. A key contribution is establishing a direct connection between sufficient explanations for conjunctive queries and database repairs via the repair core, enabling efficient computation of minimal sufficient explanations. The work also explores the relationship between necessity and sufficiency degrees, showing that sufficient tuples are necessarily necessary.

## Method Summary
The paper presents a method for computing sufficient explanations by leveraging database repairs and the repair core. For a Boolean conjunctive query Q and database D, the approach transforms Q into a denial constraint K = ¬Q and computes the repair core Core(D,K). The repair core contains tuples that do not participate in any witness of Q. An algorithm then constructs minimal sufficient sets (MSS) containing a specific tuple by iteratively adding compatible tuples that maintain query satisfaction. The sufficiency degree σ(t) = 1/|S| where S is a minimum-cardinality sufficient-set containing t. For self-join-free queries, this yields polynomial-time complexity.

## Key Results
- Sufficient explanations can be formalized as tuples belonging to minimal sufficient-sets (MSS), with a quantitative sufficiency degree measuring their strength
- A direct connection between sufficient explanations for conjunctive queries and database repairs via the repair core enables efficient computation
- The sufficiency degree of a tuple can be computed in polynomial time for self-join-free conjunctive queries
- Sufficient tuples are necessarily necessary, establishing a bidirectional hitting-set relationship between MSS and minimal necessary-sets

## Why This Works (Mechanism)

### Mechanism 1
- **Claim**: Sufficient explanations can be formalized as tuples belonging to minimal sufficient-sets (MSS), with a quantitative sufficiency degree measuring their strength.
- **Mechanism**: For database D and Boolean monotone query Q where D |= Q, tuple t ∈ D_n is a sufficient explanation if S ∪ D_x |= Q for some minimal S ⊆ D_n containing t. The sufficiency degree σ(t) = 1/|S| where S is a minimum-cardinality sufficient-set containing t. Higher scores indicate stronger sufficiency (e.g., t₁ alone sufficing gives σ(t₁) = 1).
- **Core assumption**: Queries are monotone—adding tuples cannot make a true query false.
- **Evidence anchors**:
  - [abstract] "formalize the notion of tuple-based sufficient explanation for monotone queries... introduce a quantitative sufficiency score"
  - [section 4, Definition 2] Defines sufficient-sets, MSS, and sufficiency-degree formally
  - [corpus] Weak direct corpus support; related work on explanations in databases exists but doesn't replicate this sufficiency formulation
- **Break condition**: If query is non-monotone (e.g., contains negation), the sufficiency definition may not hold—removing tuples could make query true.

### Mechanism 2
- **Claim**: Sufficient explanations can be computed efficiently via the repair core without enumerating all repairs.
- **Mechanism**: For BCQ Q with denial constraint K = ¬Q, the repair core is Core(D,K) = ∩_{D'∈Rep(D,K)} D'. Lemma 1 shows Core(D,K) = ∩_{1≤i≤k}(D \ R^D_i) where R^D_i contains tuples in P^D_i participating in any query witness. Algorithm 1: (1) compute Core in O(|D|^k), (2) pick t ∈ D \ Core, (3) use chase-like procedure (Proposition 4) to build MSS containing t.
- **Core assumption**: Query is a fixed-size Boolean conjunctive query; self-join-free for minimum MSS guarantee.
- **Evidence anchors**:
  - [abstract] "direct connection between sufficient explanations for conjunctive queries and database repairs via the repair core, enabling efficient computation"
  - [section 5, Corollary 1] Core computation in O(|D|^k) PTIME
  - [corpus] No direct corpus validation of repair-core-to-sufficiency connection
- **Break condition**: If query has self-joins, Algorithm 1 may produce MSS but not necessarily minimum-size MSS (Example 13). If exogenous tuples are not properly handled, the procedure may include tuples not subject to intervention.

### Mechanism 3
- **Claim**: Sufficient tuples are necessarily necessary, establishing a bidirectional hitting-set relationship between MSS and minimal necessary-sets (MNS).
- **Mechanism**: Proposition 1: t ∈ some MSS iff t is a necessary tuple. Proposition 2: Each MSS is a minimal hitting-set (MHS) for the collection of MNS, and each MNS is an MHS for MSS. This creates a duality: necessity degree η(t) = 1/|N| (where N is minimum-cardinality necessary-set) may differ from sufficiency degree σ(t), with neither strictly superior (Example 14 vs Example 7).
- **Core assumption**: Database partitioned into endogenous/exogenous tuples; necessity requires endogenous tuples only.
- **Evidence anchors**:
  - [abstract] "sufficient tuples are necessarily necessary"
  - [section 4, Propositions 1-2] Formal statements and proofs of MSS-MNS hitting-set duality
  - [corpus] Halpern-Pearl causality (cited in corpus) provides foundation but doesn't establish this specific sufficiency-necessity link
- **Break condition**: If exogenous tuples are not properly excluded from MNS computation, the hitting-set relationship may fail.

## Foundational Learning

- **Concept: Database repairs (S-repairs and C-repairs)**
  - **Why needed here**: The entire sufficient explanation mechanism relies on transforming the query into a denial constraint and computing repairs of the inconsistent database. Without understanding subset-repairs (maximal consistent subsets) vs. cardinality-repairs (minimum deletions), the Core computation and its connection to sufficiency remain opaque.
  - **Quick check question**: Given database D = {t₁, t₂, t₃} and constraint "at most 2 tuples," what are the S-repairs? (Answer: {t₁,t₂}, {t₁,t₃}, {t₂,t₃})

- **Concept: Minimal hitting-sets**
  - **Why needed here**: Proposition 2 establishes that MSS and MNS are dual through hitting-sets. Understanding that a hitting-set for collection S contains at least one element from each set in S is essential for grasping why computing one from the other is feasible.
  - **Quick check question**: For collection {{a,b}, {b,c}, {a,c}}, what is the minimum hitting-set? (Answer: {a,b} or any 2-element subset containing at least one from each pair)

- **Concept: Conjunctive queries (CQs) and self-joins**
  - **Why needed here**: The polynomial-time results (Corollaries 2-4) depend critically on whether the query is self-join-free (SJF). A CQ with repeated predicate symbols may have multiple atoms over the same relation, breaking the guarantee of minimum-size MSS from Algorithm 1 (see Example 13).
  - **Quick check question**: Is Q: ∃x∃y(R(x,y) ∧ R(y,z)) self-join-free? (Answer: No—R appears twice)

## Architecture Onboarding

- **Component map**: Core Computer -> MSS Builder -> Sufficiency Scorer
- **Critical path**: Core Computer → MSS Builder → Sufficiency Scorer. The Core computation is the bottleneck for efficiency but enables avoiding exponential repair enumeration.
- **Design tradeoffs**:
  - **SJF vs. non-SJF queries**: SJF guarantees minimum MSS in PTIME; non-SJF may require additional minimization post-processing (NP-hard in general)
  - **Endogenous/exogenous partition**: Including exogenous tuples in D_x reduces search space but requires user annotation; all-endogenous is simpler but may over-attribute causality
  - **Repair semantics**: S-repairs (subset-maximal) vs. C-repairs (cardinality-minimal)—paper focuses on S-repairs for Core; C-repairs connect to maximum-responsibility causes
- **Failure signatures**:
  - **Empty Core**: If Core(D,K) = D, then D |= K (query false)—check D |= Q before proceeding
  - **Non-terminating MSS Builder**: If t doesn't belong to any MSS (σ(t) = 0), chase procedure has no valid completion—validate t is necessary tuple first (Proposition 1)
  - **Exponential blowup**: If query size k is not fixed, O(|D|^k) becomes exponential in input size—bound k or restrict to constant-size queries
- **First 3 experiments**:
  1. **Validate Core computation correctness**: On small graph database (e.g., Example 1 with 6 tuples, path query), compute Core manually via repair intersection, compare with Lemma 1 algorithm output. Verify Core contains only tuples not in any query witness path.
  2. **Measure MSS Builder efficiency scaling**: Generate random databases of size |D| ∈ {100, 1000, 10000} with fixed SJF query (k=3), measure Core + MSS computation time. Expect O(|D|^k) scaling; confirm polynomial behavior.
  3. **Compare sufficiency vs. necessity degrees**: On Example 14 graph (5 tuples, 2 exogenous), compute both η(t) and σ(t) for all tuples. Verify η(t₅) = 1 > σ(t₅) = 0.5, demonstrating cases where necessity better captures contribution.

## Open Questions the Paper Calls Out

### Open Question 1
- Question: Can the efficient computation of sufficient explanations be extended to general conjunctive queries (with self-joins) or non-monotone queries?
- Basis: [explicit] Section 6 states, "we should go beyond conjunctive queries without self-joins, and also into the realm of more general queries, monotone or not."
- Why unresolved: The paper's main complexity results (e.g., Corollary 3) rely on the query being a self-join-free Boolean Conjunctive Query (SJF BCQ).
- Evidence: An algorithm with polynomial-time data complexity for CQs with self-joins, or a hardness proof for non-monotone queries.

### Open Question 2
- Question: How does the inclusion of exogenous tuples impact the complexity and computation of the repair core and sufficient explanations?
- Basis: [explicit] Section 6 notes, "We have concentrated our algorithmic analysis mostly on databases without exogenous tuples. A next step would be including the latter as well."
- Why unresolved: While Remark 1 suggests validity, the primary algorithms and complexity bounds focus on endogenous-only instances (D=D_n).
- Evidence: A complexity analysis and specific algorithms handling the partition D=D_n ∪ D_x within the repair core computation.

### Open Question 3
- Question: Under what specific conditions are necessity and sufficiency scores aligned, and how can they be combined into a unified causal-contribution score?
- Basis: [explicit] Section 6 highlights the need to "investigate under what conditions... the scores are aligned" and mentions a "causal-contribution score" as ongoing work.
- Why unresolved: The paper provides examples where necessity and sufficiency diverge (Ex 14) but does not characterize the conditions for alignment.
- Evidence: A formal characterization of query/database properties ensuring score alignment or a definition of the proposed combined score.

## Limitations

- Polynomial-time results rely heavily on self-join-free queries, with non-SJF cases lacking guarantees of minimum-size MSS
- The exogenous/endogenous tuple partition requires domain knowledge for correct application
- Complexity bounds assume fixed query size k, becoming exponential when k scales with input

## Confidence

- **High**: The repair-core connection to sufficient explanations (Section 5) and the sufficiency-necessity duality (Propositions 1-2) have rigorous formal proofs
- **Medium**: The O(|D|^k) complexity claims for Core computation depend on query structure assumptions that may not hold in practice
- **Low**: The quantitative sufficiency score interpretation and its practical utility for database explanation tasks lack empirical validation

## Next Checks

1. Test the Core computation algorithm on larger synthetic databases (10K+ tuples) with varying query sizes to empirically verify polynomial scaling
2. Implement both S-repairs and C-repairs variants to compare their impact on Core computation and sufficiency results
3. Conduct user studies comparing sufficiency vs. necessity explanations for database debugging tasks to assess practical utility of both approaches