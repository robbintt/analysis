---
ver: rpa2
title: Dense Neural Network Based Arrhythmia Classification on Low-cost and Low-compute
  Micro-controller
arxiv_id: '2504.03531'
source_url: https://arxiv.org/abs/2504.03531
tags:
- arrhythmia
- network
- table
- system
- neural
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: This study presents a dense neural network-based arrhythmia classification
  system implemented on a low-cost, low-compute Arduino Nano microcontroller. The
  system uses an AD8232 ECG sensor and a two-layer neural network with sigmoid activation
  functions, achieving 96.38% accuracy and 78.3% F1 score (macro-average) for classifying
  four types of arrhythmia.
---

# Dense Neural Network Based Arrhythmia Classification on Low-cost and Low-compute Micro-controller

## Quick Facts
- **arXiv ID:** 2504.03531
- **Source URL:** https://arxiv.org/abs/2504.03531
- **Reference count:** 12
- **Primary result:** 96.38% accuracy and 78.3% macro F1-score for 4-class arrhythmia classification on Arduino Nano using a 1.267 KB quantized dense neural network

## Executive Summary
This study demonstrates a dense neural network-based arrhythmia classification system implemented on a low-cost Arduino Nano microcontroller. The system uses an AD8232 ECG sensor and a two-layer neural network with sigmoid activation functions, achieving 96.38% accuracy and 78.3% macro F1-score for classifying four types of arrhythmia. The model size is 1.267 KB with only 0.001314 MOps of floating-point operations, making it suitable for resource-constrained healthcare applications. The key innovation is the successful deployment of an efficient neural network on low-cost hardware while maintaining high classification performance.

## Method Summary
The method implements a 4-class arrhythmia classifier on Arduino Nano using MIT-BIH Arrhythmia Database. ECG signals are preprocessed using a modified Pan-Tompkins algorithm (Bandpass 5-15Hz → Derivative → Square → Moving Window Integration) to extract 61-sample windows centered on R-peaks. A 2-layer dense neural network (61→10→4) with sigmoid activation functions is trained using Adam optimizer (learning rate 0.001, MSE loss, batch size 1024, 10,000 epochs). The model is compressed using int8 quantization with zero-point preservation and temporary dequantization during inference to maintain accuracy while fitting within 2KB SRAM constraints.

## Key Results
- **96.38% accuracy** on MIT-BIH Arrhythmia Database for 4-class classification
- **78.3% macro F1-score** demonstrating reasonable performance across all classes
- **1.267 KB model size** fitting within Arduino Nano's 2KB SRAM limit
- **0.001314 MOps** computational complexity enabling real-time inference

## Why This Works (Mechanism)

### Mechanism 1: Signal Preprocessing Convergence for Feature Amplification
The Pan-Tompkins preprocessing pipeline transforms raw ECG signals into a temporally compressed, R-peak amplified representation, making arrhythmia classification learnable by a minimal neural network. Sequential application of bandpass filtering (5–15 Hz), differentiation, squaring, and moving window integration suppresses baseline wander and high-frequency noise while concentrating the QRS complex energy into a characteristic 61-sample signature.

### Mechanism 2: Asymmetric Quantization with Zero-Point Preservation
Symmetric quantization mapping (αq=-127, βq=+127) with zero explicitly mapped to zero mitigates precision loss during 32-bit float to 8-bit integer conversion. This preserves the network's sparse activation patterns and avoids systematic bias in matrix multiplication, achieving 93.74% accuracy vs. 80.023% when zero is not preserved.

### Mechanism 3: Architecture-Aware Activation Selection for MCU Constraints
Sigmoid-sigmoid activation outperforms softmax-based alternatives due to softmax's O(2n) loop complexity, which is prohibitive on a 16 MHz MCU without FPU. Sigmoid's bounded output [0,1] per neuron allows multi-label ambiguity, which empirically improves recall on minority classes compared to the enforced single-label constraint of softmax.

## Foundational Learning

### Concept: Pan-Tompkins Algorithm and QRS Morphology
- **Why needed here:** The neural network classifies preprocessed beats, not raw ECG. Understanding what preprocessing extracts (R-peak energy, QRS width) is essential to debug misclassifications.
- **Quick check question:** Given a beat preprocessed through Pan-Tompkins, which segment of the 61-sample window corresponds to the QRS complex peak vs. the ST segment?

### Concept: Quantization-Aware Training vs. Post-Training Quantization
- **Why needed here:** This paper uses post-training quantization with zero-point preservation. Knowing the difference helps assess whether the 13.7% accuracy drop (zero not preserved) could be recovered with quantization-aware training.
- **Quick check question:** In quantization-aware training, when is the fake-quantization node inserted in the computational graph, and how does it affect backpropagation compared to post-training quantization?

### Concept: Class Imbalance and Macro vs. Weighted Averaging
- **Why needed here:** The paper reports 96.38% accuracy but 78.3% F1 (macro), driven by poor performance on S and F classes. Macro average exposes this; weighted average masks it.
- **Quick check question:** If you deploy this model and it misses 50% of Ventricular ectopic (V) beats but 99% of Normal (N) beats, which metric (accuracy, macro F1, weighted F1) will best reflect the clinical risk?

## Architecture Onboarding

### Component map:
AD8232 ECG Sensor → Arduino Nano (ATMega328) → Heartbeat Detection Module (Pan-Tompkins) → Arrhythmia Detection Module (Dense NN) → Classification Output

### Critical path:
SRAM allocation: 150-sample ECG buffer (600 bytes) + quantized model (667 bytes) = 1267/2048 bytes. Inference latency: Dense layer 1 = 17.88 ms (dequantized) / 12.74 ms (quantized); total <20 ms per beat is required to maintain real-time at 360 Hz sampling. Preprocessing alignment: The index±30 window extraction must synchronize with HDM's R-peak detection; misalignment by ±5 samples shifts the QRS morphology, causing misclassification.

### Design tradeoffs:
Temporary dequantization vs. pure quantized inference: Dequantization recovers ~3% accuracy but adds ~28.7% latency per layer. Sigmoid vs. Softmax: Sigmoid allows ambiguous multi-class outputs, whereas softmax forces a hard decision. Dataset imbalance: Using weighted loss or oversampling S/F classes could improve macro F1 but was not attempted.

### Failure signatures:
Class collapse on S/F: If F1-macro drops below 0.5 while accuracy stays >90%, check S/F class balance and consider focal loss or SMOTE. Quantization overflow: If dequantized weights exceed ±64.74 during inference, outputs saturate at sigmoid boundaries; monitor activation histograms. Real-time buffer overrun: If HDM processing exceeds 2.78 ms/sample (360 Hz), the 150-sample buffer fills before inference completes.

### First 3 experiments:
Reproduce the preprocessing pipeline: Implement Algorithm 1 on a desktop with MIT-BIH data, visualize preprocessed vs. raw beats for N/S/V/F, and confirm the 61-sample window captures QRS morphology. Ablate quantization: Train the sigmoid-sigmoid model, then quantize with zero-preservation disabled and compare accuracy drop to Table V. Profile MCU latency: Deploy the dequantized model on Arduino Nano, measure per-layer inference time with a logic analyzer, and verify if softmax would exceed the 20 ms budget.

## Open Questions the Paper Calls Out

### Open Question 1
Can high-compute edge or cloud systems effectively aggregate data from these low-compute ECG devices to predict acute cardiac events like heart attacks? The paper concludes that "Future work with Edge Computing has a great prospect" but does not integrate the device into a wider network to test higher-order predictive analytics.

### Open Question 2
Can the low recall for minority classes (S and F types) be improved without exceeding the strict 2KB SRAM limit? The authors identify poor recall for classes S and F (0.52 and 0.45 respectively) and attribute it to a lack of training samples, but do not test if memory-efficient techniques like oversampling or class-weighted loss functions could mitigate the imbalance.

### Open Question 3
Can the "temporary dequantization" technique be applied to other complex biomedical signals (e.g., EMG or EEG) on similar low-cost hardware? The study validates the method strictly for single-lead ECG; it is unverified if the specific preprocessing and dequantization overhead scale to signals with different frequency characteristics or noise profiles.

## Limitations
- The model is highly tuned to MIT-BIH dataset and Arduino Nano's constraints; deployment on different hardware may require retraining
- Performance on minority classes (S and F) remains poor despite high overall accuracy, indicating class imbalance issues
- The preprocessing pipeline and quantization strategy may not generalize to other biomedical signals or different patient populations

## Confidence

**High Confidence:** Reported accuracy (96.38%) and F1-score (78.3%) are consistent with described preprocessing, architecture, and training procedure on MIT-BIH dataset.

**Medium Confidence:** Computational claims (1.267 KB model, 0.001314 MOps) are derived from stated architecture and quantization scheme, but actual MCU inference latency depends on implementation details not fully specified.

**Low Confidence:** Activation function selection (sigmoid vs. softmax) is justified by complexity arguments but not empirically validated on target MCU with actual cycle measurements.

## Next Checks

1. **Preprocessing Pipeline Validation:** Implement Algorithm 1 on MIT-BIH data, visualize preprocessed vs. raw beats for each class, and confirm 61-sample window consistently captures QRS morphology with variance measurement.

2. **Quantization Ablation Study:** Retrain sigmoid-sigmoid model, quantize with zero-preservation disabled and with different weight distributions, compare accuracy drops to Table V to isolate degradation sources.

3. **MCU Latency Profiling:** Deploy dequantized model on Arduino Nano, measure per-layer inference time with logic analyzer, verify if softmax would exceed 20 ms budget, and profile temporary dequantization loop cycle count.