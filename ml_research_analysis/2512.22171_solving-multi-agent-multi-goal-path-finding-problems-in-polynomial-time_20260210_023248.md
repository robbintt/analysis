---
ver: rpa2
title: Solving Multi-Agent Multi-Goal Path Finding Problems in Polynomial Time
arxiv_id: '2512.22171'
source_url: https://arxiv.org/abs/2512.22171
tags:
- agents
- time
- agent
- problem
- goal
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: This paper addresses multi-agent multi-goal path finding (CMAPF)
  problems in undirected graphs, where multiple goals must be assigned to agents.
  The key insight is that, unlike traditional vehicle routing which is NP-hard, CMAPF
  can be solved in polynomial time by exploiting the undirected nature of the graph
  and allowing dynamic goal reassignment during execution.
---

# Solving Multi-Agent Multi-Goal Path Finding Problems in Polynomial Time

## Quick Facts
- arXiv ID: 2512.22171
- Source URL: https://arxiv.org/abs/2512.22171
- Authors: Stefan Edelkamp
- Reference count: 20
- Primary result: CMAPF problems solvable in polynomial time by exploiting undirected graphs and dynamic goal reassignment

## Executive Summary
This paper addresses multi-agent multi-goal path finding (CMAPF) problems in undirected graphs, where multiple goals must be assigned to agents. The key insight is that, unlike traditional vehicle routing which is NP-hard, CMAPF can be solved in polynomial time by exploiting the undirected nature of the graph and allowing dynamic goal reassignment during execution. The proposed approach uses a combination of shortest-path precomputation, polynomial-time assignment algorithms (including Hungarian algorithm and NRPA for vehicle routing), and a novel "agents-on-a-graph" simulation that handles conflicts by swapping goal agendas on collisions. For anonymous MAPF, the method achieves a 50% reduction in makespan and a 90% reduction in sum-of-cost compared to fixed assignment, with conflicts reduced by two orders of magnitude. The CMAPF solver finds solutions for 500 benchmark instances in under 30 minutes each.

## Method Summary
The method combines global assignment optimization with local conflict resolution. It first precomputes all-pairs shortest paths from goals, then solves an assignment problem using Hungarian algorithm or NRPA depending on the variant. During execution, agents move along shortest paths but resolve conflicts by swapping goal agendas when they collide—either exchanging directions on edges or reassigning goals at junctions. This swap-based conflict resolution is equivalent to agents passing through each other, maintaining polynomial-time complexity while achieving high-quality solutions.

## Key Results
- CMAPF solver finds solutions for 500 benchmark instances in under 30 minutes each
- Anonymous MAPF achieves 50% reduction in makespan and 90% reduction in sum-of-cost vs. fixed assignment
- Conflicts reduced by two orders of magnitude (26,420 to 552 on Boston map with 950 agents)
- Polynomial-time solvability for all three MAPF variants (AMAPF, CMAPF, Regular MAPF)

## Why This Works (Mechanism)

### Mechanism 1: Goal Agenda Swapping on Collision
- Claim: Agents can resolve collisions in polynomial time by exchanging goal agendas rather than physically avoiding each other.
- Mechanism: When two agents meet on a graph edge, they swap both direction and goal agenda (shortest-path tables). This is equivalent to agents passing through each other—each continues carrying the other's mission. For multi-agent junction conflicts, a local O(k³) assignment problem solver reassigns agendas among colliding agents.
- Core assumption: Agents are interchangeable (anonymous or combinatorial MAPF); the objective cares that all goals are visited, not which specific agent visits which goal.

### Mechanism 2: Shortest-Path Precomputation with Global Assignment
- Claim: Precomputing all-pairs shortest paths from goal locations and solving the assignment problem globally reduces conflicts by orders of magnitude before simulation begins.
- Mechanism: (1) Run Dijkstra from each goal backward to all nodes—O(k(e + n log n)). (2) Build distance matrix between all start-goal pairs. (3) Solve assignment problem via Hungarian algorithm in O(k³) for sum-of-cost, or bottleneck assignment for makespan. This yields an initial mapping that minimizes total travel distance.
- Core assumption: The graph is undirected and connected (or has detectable connected components); shortest paths are unique or tie-breaking is consistent.

### Mechanism 3: Cuckoo'ing and Zipping for Dynamic Conflict Resolution
- Claim: Agents that have reached their goal can be "kicked out" by incoming agents who inherit their agenda, while same-direction conflicts are resolved by interleaving (zipping).
- Mechanism: Cuckoo'ing recursively pushes idle agents off goal nodes, exchanging their path tables with incoming agents. Zipping handles same-direction edge conflicts by forcing one agent dependency subtree to wait one step, alternating which branch waits. Agent dependency graphs track propagated delays.
- Core assumption: At least one agent can move per iteration; no agent waits forever (fairness).

## Foundational Learning

- **Concept: Assignment Problem (Hungarian Algorithm)**
  - Why needed here: Core subroutine for O(k³) optimal matching of k agents to k goals in AMAPF. The paper uses Jonker-Volgenant variant for shortest augmentation paths.
  - Quick check question: Given a 3×3 cost matrix where agent 1 has costs [2, 9, 1] to goals A, B, C, what is the minimum total cost assignment?

- **Concept: Vehicle Routing Problem (VRP) vs. TSP**
  - Why needed here: CMAPF generalizes assignment to multiple goals per agent, requiring tour construction. NRPA (Nested Rollout Policy Adaptation) provides anytime solutions. Assumption: NRPA mechanics not fully detailed in paper.
  - Quick check question: If TSP is NP-hard even on grid graphs, why does the paper claim polynomial-time CMAPF? (Hint: re-targeting + no exclusive node visits.)

- **Concept: Time-Expanded Graphs vs. Shortest-Path Reduction**
  - Why needed here: Prior AMAPF work uses time-expanded networks (large input size). This paper works on the shortest-path reduced graph instead, reducing complexity.
  - Quick check question: A time-expanded graph with n nodes and T timesteps has how many nodes? If T = O(n), what is the size difference vs. working on the original graph?

## Architecture Onboarding

- **Component map:**
```
[Input: Graph G, Agent starts S, Goals W]
         ↓
[1. Shortest-Path Precomputation] → Dijkstra from each goal → O(k·(e+n log n))
         ↓
[2. Distance Matrix Construction] → n×k table of start→goal distances
         ↓
[3. Assignment Solver] → Hungarian (AMAPF) or NRPA (CMAPF) → O(k³) or bounded rollouts
         ↓
[4. Simulation Engine] → Agent dependency graph + conflict handlers
    ├── Edge conflict → Swap agendas (Figure 7)
    ├── Node conflict (opposite dir) → Swap agendas (Figure 6)
    ├── Node conflict (same dir) → Zipping with wait propagation (Figure 5)
    └── Goal occupied → Cuckoo'ing (Figure 4)
         ↓
[Output: Collision-free schedules π₁...πₖ]
```

- **Critical path**: The simulation loop (Component 4) dominates runtime for large instances. Each iteration must: (a) update agent positions along shortest-path edges, (b) detect conflicts, (c) resolve via swap/wait/cuckoo, (d) propagate waits through dependency tree. Assumption: Dependency tree traversal is O(k) per iteration.

- **Design tradeoffs:**
  - **Optimality vs. Polynomial Time**: Theorem 2/4 guarantee polynomial time but NOT optimality for Regular MAPF (n²-1 puzzle is NP-hard to optimize). Global assignment optimizes initial state; dynamic swaps may deviate.
  - **Continuous vs. Discrete**: Continuous case (Theorem 1) achieves L+ε optimality; discrete case requires wait actions and cuckoo'ing, incurring delay.
  - **NRPA Iterations vs. Solution Quality**: CMAPF uses bounded rollouts; paper trades quality for time (500 benchmarks in <30 min each). More rollouts improve solutions.

- **Failure signatures:**
  - **Unsolvable instance spike**: CMAPF may produce unsolvable instances if goals become unreachable based on agent start positions (detected in O(n) via connected components). Figure 16 shows spikes in runtime plot.
  - **Infinite wait detection**: If dependency graph has cycles where all agents wait on each other, simulation stalls. Paper claims fairness via alternating but does not provide cycle detection pseudocode—assumption: cycle-free by construction.
  - **Disconnected graph**: Linear-time check required upfront; otherwise Dijkstra produces infinite distances.

- **First 3 experiments:**
  1. **Boston map sanity check**: Run AMAPF on the Boston_0_950 scenario (Table 1). Verify conflicts drop from ~26K to ~500. If not, check swap logic in simulation—agenda exchange must include shortest-path table reassignment.
  2. **Single-agent CMAPF validation**: With k=1, m=5 goals on a 10×10 grid, compare NRPA tour cost vs. brute-force TSP solution. NRPA should find valid (not necessarily optimal) tour in polynomial rollouts.
  3. **Conflict resolution stress test**: Construct a 4-agent, single-chokepoint graph where all agents must pass through one node. Verify cuckoo'ing and zipping produce a schedule without deadlock. Measure makespan increase vs. conflict-free baseline.

## Open Questions the Paper Calls Out
None

## Limitations
- Theorem 2's proof for Regular MAPF is marked as "out of scope" and refers to a separate paper, creating a gap in theoretical foundation
- Implementation details for NRPA mechanics, cycle detection in dependency graphs, and specific tie-breaking rules are not fully detailed
- Empirical validation is limited to benchmark instances from the literature without ablation studies or sensitivity analysis

## Confidence

- **High confidence**: Polynomial-time solvability of AMAPF (Theorem 1 is complete), correctness of shortest-path precomputation and Hungarian algorithm application, basic swap-on-collision mechanism
- **Medium confidence**: CMAPF generalization with NRPA, cuckoo'ing and zipping conflict resolution mechanics, practical performance claims on benchmarks
- **Low confidence**: Regular MAPF polynomial-time claim (proof deferred), optimality guarantees for continuous case (L+ε claim), scalability to extremely large graphs

## Next Checks

1. **Proof verification**: Implement and verify the complete proof of Theorem 1, including all edge cases in the conflict resolution mechanisms (swap, cuckoo'ing, zipping). Test on synthetic graphs where manual verification is tractable.

2. **Optimality gap analysis**: Run the solver on small Regular MAPF instances (3-5 agents, 4-6 goals) where optimal solutions can be computed via brute force or ILP. Measure the makespan and sum-of-cost gap between the polynomial-time solution and the optimal solution.

3. **Scalability stress test**: Generate random graphs with 1000+ agents and 5000+ goals. Measure runtime growth, conflict resolution frequency, and solution quality degradation. Verify that the O(k³) assignment solver and O(k) dependency resolution per iteration scale as claimed.