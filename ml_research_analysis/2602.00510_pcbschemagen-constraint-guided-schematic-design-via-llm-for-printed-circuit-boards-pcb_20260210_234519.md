---
ver: rpa2
title: 'PCBSchemaGen: Constraint-Guided Schematic Design via LLM for Printed Circuit
  Boards (PCB)'
arxiv_id: '2602.00510'
source_url: https://arxiv.org/abs/2602.00510
tags:
- design
- circuit
- schematic
- verification
- power
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: PCBSchemaGen introduces the first training-free framework for automated
  PCB schematic design, addressing the challenges of heterogeneous digital, analog,
  and power signal integration with real-world IC constraints. The core innovation
  combines LLM-based SKiDL code generation with a constraint-guided verification framework
  leveraging a Knowledge Graph derived from IC datasheets and Subgraph Isomorphism
  for topology checking.
---

# PCBSchemaGen: Constraint-Guided Schematic Design via LLM for Printed Circuit Boards (PCB)

## Quick Facts
- **arXiv ID:** 2602.00510
- **Source URL:** https://arxiv.org/abs/2602.00510
- **Reference count:** 40
- **Primary result:** Training-free LLM framework achieving 88.1% Pass@1 on PCB schematic generation with 37× speedup over manual design

## Executive Summary
PCBSchemaGen introduces the first training-free framework for automated PCB schematic design, addressing the challenges of heterogeneous digital, analog, and power signal integration with real-world IC constraints. The core innovation combines LLM-based SKiDL code generation with a constraint-guided verification framework leveraging a Knowledge Graph derived from IC datasheets and Subgraph Isomorphism for topology checking. Evaluated on 23 tasks spanning three domains, the system achieves 88.1% Pass@1 and 100% Pass@5 on easy tasks, with significant gains in medium and hard tasks through iterative feedback.

## Method Summary
The framework uses an LLM (GPT-5.1/Gemini-3) to generate SKiDL code from natural language specifications using In-Context Learning and Chain-of-Thought prompting. A four-stage verifier checks Python/ERC syntax, Knowledge Graph-based pin-role constraints, inter-component constraints, and Subgraph Isomorphism topology against reference skeletons. Errors trigger iterative feedback (Full/Weak/None) for up to three retries. The Knowledge Graph compresses 16k-token datasheets to ~300 tokens while preserving 36 pin-role types for cross-vendor constraint injection.

## Key Results
- **88.1% Pass@1** on 23 benchmark tasks with Gemini-3-Pro across digital, analog, and power domains
- **37× speedup** compared to manual design (10-15 minutes vs 6-8 hours per task)
- **Feedback granularity critical**: Full feedback achieves 78.1% Pass@1 on hard tasks vs 57.1% with None feedback

## Why This Works (Mechanism)

### Mechanism 1
- Claim: Training-free LLM code generation can produce valid PCB schematics when grounded in structured domain knowledge.
- Mechanism: The LLM receives natural language specifications and generates SKiDL (Python-based HDL) code. In-Context Learning provides exemplars of correct schematic patterns; Chain-of-Thought prompting forces explicit reasoning about connectivity before code emission. This avoids fine-tuning data requirements.
- Core assumption: The LLM's pre-trained Python knowledge transfers to SKiDL syntax with minimal examples; domain constraints are learnable from structured prompts rather than weight updates.
- Evidence anchors:
  - [abstract]: "training-free framework for PCB schematic design... LLM-based code generation paradigm with iterative feedback with domain-specific prompts"
  - [Section 3.1]: "SKiDL serves as the most effective medium... since the vast majority of state-of-the-art LLMs have undergone extensive fine-tuning on Python code bases"
  - [corpus]: EEschematic (arXiv:2510.17002) similarly uses multimodal LLMs for schematic generation, supporting the general approach but with different verification strategy.

### Mechanism 2
- Claim: Knowledge Graph compression of IC datasheets enables constraint injection without exceeding context windows.
- Mechanism: Raw datasheets (~16k tokens) are distilled into structured KG with 36 pin-role types (e.g., `primary_vdd`, `gate_output`), constraint functions, and isolation boundaries. This achieves 30–70× token reduction while preserving functional/electrical constraints for both generation guidance and verification.
- Core assumption: Pin-role semantics generalize across vendor-specific naming conventions; critical constraints are extractable from datasheets without loss of design-critical information.
- Evidence anchors:
  - [Section 3.2]: "KG captures the essential information of IC components, including pin roles, electrical properties, topological constraints... reducing the token footprint per IC component from approximately 16k tokens to average 300 token"
  - [Table 8]: 34 defined pin roles mapped to semantic functions (e.g., `mosfet_kelvin_source` for high-power switching)
  - [corpus]: No directly comparable KG-based PCB verification systems found; AMSNet-KG (Shi et al., 2025) applies KG to analog circuits but anchors to fixed datasets.

### Mechanism 3
- Claim: Subgraph Isomorphism (SI) verification provides deterministic topology checking that simulation cannot deliver for real IC packages.
- Mechanism: Circuits are represented as bipartite graphs (components + nets). The VF2 algorithm checks whether generated topology `G_gen` contains reference skeleton `G_ref` as a subgraph, verifying both structural correctness and constraint satisfaction (e.g., bootstrap capacitor placement, isolation boundaries).
- Core assumption: Topological correctness is necessary (though not sufficient) for functional correctness; reference skeletons can be defined by domain experts for common circuit classes.
- Evidence anchors:
  - [Section 3.3]: "For PCB schematics involving real IC packages and pin-level constraints, no scalable functional or electrical performance verifier currently exists, making datasheet-grounded structural verification a necessary and practical abstraction"
  - [Equation 3]: "Verify(σ_gen, σ_ref, R) ⇔ ∃injective φ: G_R ↪ G_gen" formalizing the SI reduction
  - [Figure 6]: Visualizes SI tolerance—additional capacitors accepted if core topology preserved
  - [corpus]: GNN approach (arXiv:2506.10577) adds optimizing components via link prediction but lacks closed-loop verification.

### Mechanism 4
- Claim: Iterative feedback with precise error localization enables self-correction that binary or type-only feedback cannot achieve.
- Mechanism: Multi-stage verification produces three feedback levels: Full (type + pin/net location), Weak (type only), None (binary). Full feedback enables the LLM to identify specific violations (e.g., "pin FB is unconnected") rather than guessing blindly.
- Core assumption: LLMs can translate structured error messages into targeted code modifications without breaking existing correct connections.
- Evidence anchors:
  - [Table 4]: Hard tasks drop from 78.1% (Full) to 57.1% (None) Pass@1
  - [Section 4.3]: "Full feedback is indispensable for complex designs, where explicit localization enables precise self-correction"
  - [Table 10]: Example error messages showing granularity difference
  - [corpus]: Weak/missing—no comparable ablation of feedback granularity in circuit generation literature.

## Foundational Learning

- **Bipartite graph representation of circuits**:
  - Why needed here: The entire verification framework depends on modeling circuits as G = (V_C ∪ V_N, E) where components and nets are disjoint vertex sets.
  - Quick check question: Given a circuit with 3 resistors and 4 nets, how many vertices exist in the bipartite graph?

- **Subgraph isomorphism complexity**:
  - Why needed here: VF2 algorithm runtime scales with graph size; understanding NP-completeness informs timeout/retry design.
  - Quick check question: Why is subgraph isomorphism harder than graph isomorphism for verification purposes?

- **Pin-role semantics vs. vendor naming**:
  - Why needed here: The KG abstraction (36 roles) maps vendor-specific pin names (e.g., "KS", "BOOT") to semantic functions for cross-vendor verification.
  - Quick check question: A MOSFET has pins named "G", "D", "S1", "S2", "KS". Which pin-role would "KS" (Kelvin Source) map to, and why does it matter for high-frequency switching?

- **SKiDL as executable HDL**:
  - Why needed here: Unlike netlist formats, SKiDL allows programmatic circuit construction and direct ERC integration.
  - Quick check question: What advantage does Python-based SKiDL offer over JSON netlists for LLM generation?

## Architecture Onboarding

- **Component map**: Natural Language Spec → Prompt Engineering (ICL + CoT) → LLM → SKiDL Code → Verification (Syntax/ERC → KG Constraints → SI Topology) → Feedback → Iterative Refinement

- **Critical path**: Prompt design → SKiDL generation → ERC pass → KG constraint check → SI topology verification → KiCAD netlist export. Any failure before SI triggers feedback loop.

- **Design tradeoffs**:
  - **Token budget vs. constraint coverage**: KG reduces 16k→300 tokens but may omit edge-case constraints. Validate with expert review (κ=0.913 achieved).
  - **Feedback granularity vs. token cost**: Full feedback improves Hard tasks 78.1%→57.1% but increases cumulative token usage. Figure 5 shows diminishing returns after 3 retries.
  - **ICL examples vs. generalization**: Task-specific examples help complex topologies (78.1%→43.8% drop without ICL on Hard tasks) but risk overfitting to example patterns.

- **Failure signatures**:
  - **Phase 1 (Syntax/ERC)**: Typically floating pins, short circuits—more common in Easy tasks (38% of failures)
  - **Phase 2 (KG Constraint)**: Missing decoupling capacitors, wrong supply connections—persistent across difficulty levels
  - **Phase 3 (Topology)**: Incorrect net connections preserving component count—dominates Medium failures
  - **Phase 4 (System Topology)**: Malformed half-bridge structures, incorrect transformer windings—exclusive to Hard tasks (33%)

- **First 3 experiments**:
  1. **Reproduce Task #7 (isolated DC-DC)** with Full vs. None feedback to validate feedback mechanism on your LLM of choice. Compare token usage and convergence rate.
  2. **Extend KG with a new IC** (e.g., a different gate driver) by extracting pin roles from its datasheet. Verify that generated schematics pass SI without modifying the core algorithm.
  3. **Test topology generalization**: Run Task #17 (synchronous buck) with a different MOSFET package (TOLL vs. TO-247). Observe whether pin-role abstraction enables cross-package transfer or if package-specific constraints are needed in the KG.

## Open Questions the Paper Calls Out

None

## Limitations

- **Proprietary LLM dependency**: Performance metrics tied to GPT-5.1/Gemini-3 which cannot be reproduced with current public models
- **KG abstraction limitations**: 36-pin role vocabulary may miss edge-case constraints from real IC datasheets
- **Verification scope limits**: SI verification provides necessary but not sufficient guarantees for functional correctness

## Confidence

**High Confidence (80-95%)**: The training-free framework architecture, KG construction methodology, and verification pipeline implementation are clearly specified and reproducible. The ablation studies on feedback granularity show statistically significant improvements that are robust across difficulty levels.

**Medium Confidence (60-80%)**: The quantitative performance metrics are likely reproducible with similar LLMs but will vary with model choice. The KG abstraction's effectiveness in preserving design-critical constraints is supported by expert validation (κ=0.913) but hasn't been stress-tested on edge cases beyond the benchmark.

**Low Confidence (40-60%)**: Claims about generalizability to novel IC packages or complex topologies beyond the benchmark tasks are extrapolations. The system's behavior on highly specialized or emerging IC architectures hasn't been validated.

## Next Checks

1. **LLM Transfer Test**: Reproduce Task #7 (isolated DC-DC) using GPT-4o or Gemini 1.5 Pro instead of the reported GPT-5.1/Gemini-3. Compare Pass@1 rates and token usage to assess model dependency.

2. **KG Stress Test**: Extend the Knowledge Graph with a datasheet from an IC not in the original corpus (e.g., a different gate driver with unique pin constraints). Verify that generated schematics pass the SI verification without modifying the core algorithm.

3. **Topology Generalization Test**: Run Task #17 (synchronous buck) with a MOSFET package different from those in the original benchmark (e.g., TOLL vs. TO-247). Evaluate whether the pin-role abstraction enables cross-package transfer or if package-specific constraints become necessary.