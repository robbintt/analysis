---
ver: rpa2
title: Common Foundations for SHACL, ShEx, and PG-Schema
arxiv_id: '2502.01295'
source_url: https://arxiv.org/abs/2502.01295
tags:
- shex
- shacl
- common
- shape
- graph
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: 'This paper provides a unified formal framework for comparing three
  major graph schema languages: SHACL, ShEx, and PG-Schema. The authors establish
  a common data model that bridges RDF and Property Graph representations, then systematically
  analyze the core features of each language.'
---

# Common Foundations for SHACL, ShEx, and PG-Schema

## Quick Facts
- arXiv ID: 2502.01295
- Source URL: https://arxiv.org/abs/2502.01295
- Reference count: 40
- This paper establishes a unified formal framework for comparing SHACL, ShEx, and PG-Schema graph schema languages, identifying a minimal common subset (CoGSL) that captures shared validation capabilities.

## Executive Summary
This paper provides a systematic comparison of three major graph schema languages—SHACL, ShEx, and PG-Schema—by establishing a common data model that bridges RDF and Property Graph representations. The authors identify a minimal common subset called CoGSL that captures the shared core functionalities across all three languages. Through careful translations between languages, they demonstrate that despite different origins and approaches, these languages can express the same set of fundamental constraints, enabling potential interoperability and cross-language translations.

## Method Summary
The authors establish a common data model for graphs with edges labeled by properties and nodes with attributes, then formally define the core features of each language. They systematically analyze the semantic differences between languages, particularly around counting mechanisms (triple-based vs node-based) and path expressions. The method involves creating translation algorithms from CoGSL to both SHACL and ShEx, proving through lemmas that these translations preserve validation semantics. The approach focuses on non-recursive variants of the languages, with recursive features left for future work.

## Key Results
- All three languages can express the same core constraints through careful translations
- A minimal common subset (CoGSL) was identified that captures shared validation capabilities
- The paper demonstrates that despite different origins, these languages share fundamental capabilities for graph validation

## Why This Works (Mechanism)
The common foundation works because all three languages ultimately describe constraints on graph structures, albeit with different syntax and semantics. By abstracting to a common data model and identifying the minimal set of constraint types (type constraints, path expressions, cardinality, value constraints, logical combinations), the authors can map between languages systematically. The key insight is that differences in counting (triples vs nodes) and path encoding can be reconciled through careful translation.

## Foundational Learning
1. **Common Graph Data Model**: Nodes, properties, and values form the basis for comparison - needed to bridge RDF and Property Graph representations; quick check: verify graph parser correctly handles both formats
2. **Selector vs Shape Encoding**: PG-Schema uses selectors separately from shapes, requiring encoding paths as disjunctions - needed to understand validation semantics differences; quick check: test selector-path pairs on sample graphs
3. **Counting Semantics**: SHACL/PG-Schema count nodes, ShEx counts triples - needed to reconcile cardinality constraint behavior; quick check: create graphs with varying edge multiplicities to test counting

## Architecture Onboarding
- **Component Map**: Common Graph Model -> Language Parsers -> CoGSL Translator -> Validation Engine
- **Critical Path**: Graph parsing → Constraint translation → Validation execution → Result comparison
- **Design Tradeoffs**: Focus on non-recursive variants simplifies comparison but limits expressiveness; counting mechanism differences require careful translation logic
- **Failure Signatures**: Counting mismatches occur when graphs differ only in edge multiplicity; selector encoding errors produce validation failures on wrong nodes
- **3 First Experiments**: 1) Implement common graph model with both RDF and PG parsers; 2) Validate one constraint type across all three languages; 3) Test translation of cardinality constraints with varying edge counts

## Open Questions the Paper Calls Out
None

## Limitations
- The paper focuses only on non-recursive variants of the languages, leaving recursive feature comparison for future work
- Concrete instantiation of value types and their validation semantics are not fully specified
- No reference implementation or test suite is provided for the formal definitions

## Confidence
- High confidence: The identification of CoGSL and systematic translation framework between languages
- Medium confidence: The formal definitions of common data model and individual language semantics
- Low confidence: Handling of recursive constraints and complete instantiation of value type semantics

## Next Checks
1. Implement test suite for three example constraints (C1-C5) across all three languages to verify translation algorithms preserve semantics
2. Test counting discrepancy between triple-based (ShEx) and node-based (SHACL/PG-Schema) cardinality constraints on graphs with varying edge multiplicities
3. Validate selector-to-shape translation mechanism by constructing graphs where only selector-matched nodes should trigger validation failures