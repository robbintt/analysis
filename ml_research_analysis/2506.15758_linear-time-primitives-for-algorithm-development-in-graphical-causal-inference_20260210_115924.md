---
ver: rpa2
title: Linear-Time Primitives for Algorithm Development in Graphical Causal Inference
arxiv_id: '2506.15758'
source_url: https://arxiv.org/abs/2506.15758
tags:
- cifly
- causal
- algorithm
- nodes
- graph
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: CIfly is a framework for efficient algorithmic primitives in graphical
  causal inference, reducing many causal reasoning tasks to reachability in dynamically
  constructed state-space graphs. It uses a rule table schema to specify algorithms,
  which are proven to run in linear time.
---

# Linear-Time Primitives for Algorithm Development in Graphical Causal Inference

## Quick Facts
- **arXiv ID:** 2506.15758
- **Source URL:** https://arxiv.org/abs/2506.15758
- **Reference count:** 40
- **Primary result:** CIfly is a framework for efficient algorithmic primitives in graphical causal inference, reducing many causal reasoning tasks to reachability in dynamically constructed state-space graphs.

## Executive Summary
CIfly is a novel framework for developing efficient linear-time algorithms in graphical causal inference. The core insight is to reduce many causal reasoning tasks to reachability problems in dynamically constructed state-space graphs, specified through a rule table schema. The framework implements these algorithms in Rust with Python and R bindings, demonstrating performance improvements of up to five orders of magnitude over existing implementations for large graphs. The authors prove that traditional primitives like moralization are computationally equivalent to Boolean matrix multiplication, making them unsuitable for linear-time algorithms, while CIfly maintains strict O(p+m) complexity.

## Method Summary
CIfly maps causal inference tasks to reachability problems in state-space graphs by defining neighbor types and colors that encode the context of graph traversal. Algorithms are specified through rule tables that define valid state transitions based on logical conditions. The framework implements a DFS-based reachability algorithm that constructs the state-space graph on-the-fly, achieving linear time complexity. The system supports multiple graph types including DAGs, CPDAGs, and ADMGs, with implementations in Rust plus Python and R bindings for accessibility.

## Key Results
- CIfly outperforms pcalg and DAGitty by up to five orders of magnitude for large sparse graphs
- The framework successfully re-implements established causal inference tasks and develops new algorithms for instrumental variables
- Traditional primitives moralization and latent projection are proven equivalent to Boolean matrix multiplication, confirming their super-linear complexity
- CIfly algorithms maintain linear time complexity O(p+m) for graph size p and edges m

## Why This Works (Mechanism)

### Mechanism 1
- **Claim:** Causal graphical tasks can be reduced to standard reachability problems in a dynamically constructed state-space graph.
- **Mechanism:** CIfly maps an input graph G to a directed state-space graph G_dir where nodes represent tuples of the original node, a neighbor-type (e.g., parent/child), and a "color" (state context). A directed path in G_dir corresponds to a valid walk (e.g., a d-connecting walk) in G. The algorithm then solves the reachability instance.
- **Core assumption:** The causal primitive output can be determined solely by the set of states reached in G_dir.
- **Evidence anchors:**
  - [abstract] "...reducing many causal reasoning tasks to reachability in purpose-built state-space graphs..."
  - [section] Definition 2 formally defines the CIfly reduction mapping input to (G_dir, S).
  - [corpus] Corpus signals focus on discovery and bandits; direct evidence for this specific reachability mechanism is absent in provided neighbors.

### Mechanism 2
- **Claim:** Transition logic for causal walks can be encoded in a succinct "rule table" evaluated locally.
- **Mechanism:** The framework uses a rule table to define the transition function φ. Each row specifies valid transitions between states (neighbor-type/color pairs) based on logical conditions of set membership (e.g., "current node is in set Z"). This allows the system to "forget" the graph structure and focus on local traversal rules.
- **Core assumption:** The conditions for walk validity (like collider rules in d-separation) depend only on the current node, the next edge type, and local set membership.
- **Evidence anchors:**
  - [section] Section 3.2 describes the rule table schema: "A CIfly rule table consists of three columns... current state... next state... rule."
  - [abstract] "It uses a rule table schema to specify algorithms..."
  - [corpus] No direct corpus evidence for this specific encoding method.

### Mechanism 3
- **Claim:** Linear time complexity is achieved by constructing the state-space graph "on the fly" rather than pre-computing it.
- **Mechanism:** Instead of building the full state-space graph G_dir (which has size O(p · |N_E| · |C|)), Algorithm 1 performs a Depth-First Search (DFS). It generates neighboring states and checks transitions dynamically using φ only when a node is visited.
- **Core assumption:** The number of states |C| and neighbor-types |N_E| remain constant (independent of graph size p).
- **Evidence anchors:**
  - [section] Theorem 3 proves Algorithm 1 computes output in O(p+m).
  - [abstract] "...state-space graphs that can be constructed on the fly during traversal."
  - [corpus] No corpus evidence contradicts this complexity claim.

## Foundational Learning

- **Concept: D-separation and Walks**
  - **Why needed here:** CIfly operates on "walks" rather than just paths. The rule tables explicitly implement logic for colliders and non-colliders (e.g., passing through a node in the conditioning set Z opens a collider). You cannot write rule tables without understanding these definitions.
  - **Quick check question:** In a DAG, if a walk passes through a node v via edges pointing *toward* v (a collider), is the walk open or blocked if v is *not* in the conditioning set Z?

- **Concept: Graph Reachability (BFS/DFS)**
  - **Why needed here:** The core engine of CIfly is a standard reachability algorithm. The "primitives" are essentially finding connected components in the state-space graph.
  - **Quick check question:** What is the time complexity of standard DFS on a graph with p nodes and m edges?

- **Concept: Graph Types (DAG vs. ADMG vs. CPDAG)**
  - **Why needed here:** The framework generalizes across graph types by parameterizing the "neighbor-types" (N_E). A rule table for a DAG differs from an ADMG (which has bidirected edges ↔) because the set of valid neighbor-types changes.
  - **Quick check question:** Does an ADMG allow bidirected edges (↔) between nodes? How would this affect the set N_E?

## Architecture Onboarding

- **Component map:**
  - Input: Graph G + Sets L + Rule Table → Parser → Logic → Reachability Engine → Output
  - Core (Rust): cifly crate
  - Bindings: ciflypy (Python) and ciflyr (R) wrapper packages

- **Critical path:**
  1. Define the edge types E and neighbor types N_E relevant to your problem.
  2. Construct the Rule Table: Define colors C, start states S, return states T, and the transition logic φ.
  3. Save the table to a text file (e.g., my_algorithm.rule).
  4. Call cifly.reach(G, sets, "my_algorithm.rule") from Python/R.

- **Design tradeoffs:**
  - **CIfly vs. Moralization:** The paper proves traditional primitives like moralization are computationally equivalent to Boolean Matrix Multiplication (BMM), making them unsuitable for linear time. CIfly avoids these global transformations, trading off some algorithmic flexibility for a strict O(p+m) guarantee.
  - **Generality vs. Complexity:** The system restricts transitions to those expressible by finite "colors". If a problem requires unbounded memory of the path history, it cannot be implemented in CIfly.

- **Failure signatures:**
  - **Super-linear Performance:** If you pre-process the graph using latent projection (which is BMM-equivalent) before calling CIfly, the overall pipeline is no longer linear.
  - **Incomplete Reachability:** If the rule table fails to match a valid transition (missing row in the table), the algorithm returns a subset of the true causal nodes.

- **First 3 experiments:**
  1. **Hello World (D-Separation):** Use the rule table from Figure 3 (d-connection in ADMGs) to verify that X not⊥ Y | Z in a simple 4-node graph where a collider is opened.
  2. **Benchmark:** Compare the runtime of cifly against pcalg for "Verifying Adjustment Set Validity" (Table 2) on a sparse graph with 500 nodes.
  3. **Custom Implementation:** Write a rule table to find all *ancestors* of a set X (simple reachability) and verify it runs correctly against a standard BFS implementation.

## Open Questions the Paper Calls Out

- **Open Question 1:** Can CIfly algorithms be developed for the front-door criterion in general graphs, and can the framework be extended to handle MAGs and PAGs?
  - **Basis in paper:** [explicit] "Future work includes CIfly algorithms for the front-door criterion (Wienöbst et al., 2024) and extensions to MAGs and PAGs (Richardson and Spirtes, 2002)."
  - **Why unresolved:** The current CIfly implementation covers DAGs, CPDAGs, and ADMGs, but MAGs and PAGs involve additional edge types and more complex d-separation characterizations that may require new state-space graph constructions.
  - **What evidence would resolve it:** Rule tables and implementations for front-door adjustment and for reachability queries in MAGs and PAGs, with proofs of linear-time complexity.

- **Open Question 2:** Which causal inference tasks beyond those demonstrated can be expressed as reachability problems within the CIfly framework?
  - **Basis in paper:** [explicit] "The CIfly framework also opens a broader research agenda, centered around the question of which causal tasks can be expressed as reachability problems."
  - **Why unresolved:** The paper demonstrates several tasks (adjustment verification, instrumental variables) but does not provide a characterization of the boundary of expressible problems.
  - **What evidence would resolve it:** A theoretical characterization (necessary and/or sufficient conditions) for when a causal primitive admits a CIfly reduction, with examples of tasks that provably cannot be expressed.

- **Open Question 3:** What are the complete graphical conditions for identifying graphically optimal conditional instrumental sets, and can they be computed in linear time for all valid outcomes?
  - **Basis in paper:** [inferred] Simulation results show the "optimal" algorithm fails to find valid instruments in up to one-third of instances where one exists. The paper states "This indicates that more research into graphically optimal conditional instrumental sets may be warranted."
  - **Why unresolved:** Theorem 6 provides conditions for graphical optimality but requires deG(x) = {x, y}, and the completeness of the criterion for finding any valid instrument is not established.
  - **What evidence would resolve it:** A complete graphical characterization of graphically optimal conditional instrumental sets without restrictions on descendant structure, or a proof that linear-time computation is impossible in the general case.

## Limitations

- The framework cannot express causal inference tasks requiring unbounded memory of path history
- Rule tables must be manually constructed for each new algorithm, requiring deep understanding of causal graph theory
- Performance gains depend on the graph being sparse and the color set |C| remaining constant with graph size
- The computational equivalence of moralization to Boolean matrix multiplication is cited but not detailed in the provided text

## Confidence

- **High Confidence**: The linear-time complexity claim (O(p+m)) is well-supported by Theorem 3 and the on-the-fly construction mechanism. The benchmark performance comparisons against pcalg and DAGitty are concrete and reproducible.
- **Medium Confidence**: The rule table encoding mechanism is clearly specified and appears sound for the demonstrated tasks, but its completeness for all causal reasoning tasks remains uncertain.
- **Low Confidence**: The computational equivalence proof between traditional primitives (moralization, latent projection) and Boolean matrix multiplication is cited but not detailed in the provided text, limiting assessment of this claim's validity.

## Next Validation Checks

1. **Benchmark Reproduction**: Replicate the runtime comparison for "Verifying Adjustment Set Validity" against pcalg on sparse graphs (p=500, average degree 4) using the provided CIfly rule tables and graph generation procedure.
2. **Rule Table Completeness**: Test CIfly with a custom rule table for a more complex task (e.g., computing all minimal adjustment sets) to verify the framework can express and correctly solve problems beyond the demonstrated examples.
3. **State-Space Explosion**: Construct an ADMG with bidirected edges where the conditioning set Z must track a large number of distinct collider states, and measure whether the color set |C| scales with graph size, potentially violating the linear-time guarantee.