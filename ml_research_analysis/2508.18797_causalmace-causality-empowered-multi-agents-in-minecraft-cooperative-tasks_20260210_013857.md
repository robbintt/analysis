---
ver: rpa2
title: 'CausalMACE: Causality Empowered Multi-Agents in Minecraft Cooperative Tasks'
arxiv_id: '2508.18797'
source_url: https://arxiv.org/abs/2508.18797
tags:
- task
- agent
- tasks
- agents
- causal
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: ''
---

# CausalMACE: Causality Empowered Multi-Agents in Minecraft Cooperative Tasks

## Quick Facts
- **arXiv ID:** 2508.18797
- **Source URL:** https://arxiv.org/abs/2508.18797
- **Reference count:** 17
- **Primary result:** A causality-empowered multi-agent framework that improves task completion rates in Minecraft by refining task dependencies using causal intervention.

## Executive Summary
CausalMACE introduces a novel multi-agent planning framework that integrates causal inference with language model reasoning to address the problem of hallucinated dependencies in task graphs. The system uses game rules as instrumental variables to perform causal interventions that identify and remove spurious dependencies, then executes tasks in parallel across agents while respecting causal constraints. The framework demonstrates superior performance on Minecraft construction, cooking, and escape room tasks compared to baseline planners.

## Method Summary
The framework consists of three main components: a Planner that decomposes tasks into subtasks and constructs an initial dependency graph, a causal intervention module that refines this graph by identifying and removing hallucinated dependencies using Average Treatment Effect calculations, and a Worker that assigns agents to execution paths using a busy rate metric to balance load. The Planner uses GPT-4o to generate initial task graphs, which are then refined by querying the LLM with counterfactual game rules to identify true causal dependencies. The Worker employs Depth-First Search to find all possible execution paths and assigns agents based on path busy rates to minimize resource contention.

## Key Results
- CausalMACE achieves higher Completion Rates than baselines on VillagerBench construction, cooking, and escape room tasks
- The causal intervention module effectively prunes hallucinated dependencies, improving execution efficiency
- Busy rate load balancing outperforms random agent assignment in multi-agent scenarios

## Why This Works (Mechanism)

### Mechanism 1: Causal Intervention for Edge Pruning
The framework treats game rules as instrumental variables to identify and remove hallucinated dependencies in task graphs. By modeling the LLM's inference process as a mediator between subtasks and dependencies, and introducing game rules as an external variable, the system calculates the Average Treatment Effect (ATE) when rules are counterfactually modified. If ATE equals zero, the dependency is deemed spurious and removed. This mechanism assumes that the causal effect of game rules on dependency prediction can be separated from the LLM's internal knowledge.

### Mechanism 2: DFS-based Path Parallelization
The system structures subtasks into a Directed Acyclic Graph (DAG) and processes execution paths via Depth-First Search to enable parallel execution while maintaining prerequisite chains. Agents are assigned to distinct paths, allowing them to operate in parallel branches without violating causal order. This approach assumes the task graph is acyclic and that world state changes slowly enough that one agent's completion of a root node remains valid when a leaf-node agent needs it.

### Mechanism 3: Busy Rate Load Balancing
A "Busy Rate" metric based on agent density near path entry points minimizes resource contention and improves efficiency. The Worker calculates busy rate for each path using the sum of inverse distances to path entrances and assigns new agents to the path with minimum busy rate. This assumes physical proximity or queue depth in the task graph correlates with resource contention.

## Foundational Learning

- **Concept: Structural Causal Models (SCMs) & Intervention ($do$-calculus)**
  - **Why needed here:** The paper explicitly frames dependency discovery as a causal inference problem, requiring understanding how $do(R=x)$ differs from observing $R=x$.
  - **Quick check question:** If I observe a correlation between "having sticks" and "placing a ladder," how does an intervention on the rule "ladders require sticks" help determine if the dependency is real?

- **Concept: Instrumental Variables**
  - **Why needed here:** Section 3.4 relies on Game Rules ($R$) being an instrument to separate true causality from LLM hallucination, requiring understanding of how instruments break confounding.
  - **Quick check question:** Why must the instrumental variable ($R$) have no direct effect on the output ($Y$) except through the mediator ($M$)?

- **Concept: Directed Acyclic Graphs (DAGs) in Task Planning**
  - **Why needed here:** The entire execution flow relies on the graph being acyclic so that DFS can find valid execution paths.
  - **Quick check question:** What happens to the Worker's DFS path sampling if the Causal Intervention module fails to remove a circular dependency?

## Architecture Onboarding

- **Component map:** Judger -> Planner -> Worker -> Agents
- **Critical path:** The Graph Refinement loop in the Planner (Section 3.4) where the unique value proposition lies
- **Design tradeoffs:**
  - LLM vs. Hard-coded Rules: Uses LLMs for initial graph generation (flexible but prone to hallucination) and causal logic to prune it (rigid but requires valid rules)
  - Parallelism vs. Dependency Strictness: Enforcing strict causal dependencies reduces parallelism but ensures validity
- **Failure signatures:**
  - Hallucination Persistence: If ATE calculation fails to reject false edges, agents will deadlock
  - Starvation: If Busy Rate isn't normalized, agents may crowd into "easy" paths
- **First 3 experiments:**
  1. Unit Test Causal Intervention: Feed Planner a task with known false dependency and verify ATE module prunes the edge
  2. Busy Rate Stress Test: Run 6-agent construction task with Busy Rate enabled vs. disabled; measure delta in Efficiency
  3. Ablation on Rule Quality: Provide incomplete/incorrect "Game Rules" to Planner to test Instrumental Variable assumption

## Open Questions the Paper Calls Out
- How can causality be effectively integrated into the pretraining or fine-tuning of smaller language models to support this framework?
- Can the path assignment strategy be refined to dynamically estimate task duration and difficulty to improve workload balancing?
- How robust is the dependency graph refinement when the LLM generates ambiguous or incorrect counterfactual rules?

## Limitations
- The framework's effectiveness critically depends on the completeness of the game rule set, as missing rules may lead to failure in pruning hallucinated edges
- The paper does not specify the exact ATE threshold for pruning edges, which is crucial for balancing false positive and false negative rates
- The method is designed for domains with well-defined, deterministic rules and may not generalize well to domains with complex or ambiguous causal structures

## Confidence
- **High Confidence:** The core architecture and Busy Rate load balancing are clearly defined and well-supported by ablation study results
- **Medium Confidence:** The theoretical foundation of using instrumental variables is sound, but practical implementation in the LLM context needs more rigorous validation
- **Low Confidence:** Insufficient detail on specific game rules and busy rate distance calculation logic makes complete reproduction challenging

## Next Checks
1. Unit Test Causal Intervention: Create controlled test case with known false dependency and verify ATE calculation correctly identifies and removes it
2. ATE Threshold Sweep: Systematically vary the ATE threshold used for pruning edges and measure impact on Completion Rate and Efficiency
3. Generalization Test: Apply framework to simple task in different domain to assess transfer of causal reasoning mechanism