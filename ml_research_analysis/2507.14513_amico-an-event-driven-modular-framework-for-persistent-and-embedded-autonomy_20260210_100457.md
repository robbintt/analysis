---
ver: rpa2
title: 'Amico: An Event-Driven Modular Framework for Persistent and Embedded Autonomy'
arxiv_id: '2507.14513'
source_url: https://arxiv.org/abs/2507.14513
tags:
- amico
- agent
- event
- reasoning
- action
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: Amico is an event-driven, modular agent framework designed for
  persistent autonomy in resource-constrained environments. Built in Rust and deployable
  via WebAssembly, it decouples perception, reasoning, and action into asynchronous
  components to enable responsive, adaptive behavior across embedded and browser-based
  platforms.
---

# Amico: An Event-Driven Modular Framework for Persistent and Embedded Autonomy

## Quick Facts
- arXiv ID: 2507.14513
- Source URL: https://arxiv.org/abs/2507.14513
- Authors: Hongyi Yang; Yue Pan; Jiayi Xu; Kelsen Liu
- Reference count: 5
- Primary result: Amico achieved 0.61 reward score on WebShop, outperforming a baseline LLM prompting method.

## Executive Summary
Amico is an event-driven, modular agent framework designed for persistent autonomy in resource-constrained environments. Built in Rust and deployable via WebAssembly, it decouples perception, reasoning, and action into asynchronous components to enable responsive, adaptive behavior across embedded and browser-based platforms. The framework introduces structured abstractions for event generation, task management, and model-based reasoning with optional RAG integration. In experiments on the AgentBench WebShop task, Amico outperformed a baseline LLM prompting method with a reward score of 0.61 (vs. 0.47), demonstrating the value of its event-driven control loop. Even without retrieval augmentation, Amico maintained competitive performance, highlighting the benefits of persistent task state and modular architecture.

## Method Summary
Amico implements an event-driven architecture where raw environmental observations are transformed into structured Events with timestamps and metadata, buffered in a central queue, and processed asynchronously by the Action Selector. The framework decouples perception and action through LLM-based event parsing and a two-stage action selection pipeline (candidate generation → dispatch). It's built in Rust for efficiency and can be compiled to WebAssembly for embedded deployment. The system maintains persistent task state through a dedicated task manager and optionally integrates retrieval-augmented generation for long-term memory support.

## Key Results
- Achieved 0.61 reward score on WebShop benchmark vs. 0.47 for baseline LLM prompting method
- Pure Amico (0.61) outperformed Amico+RAG (0.53) on WebShop, suggesting RAG introduced latency or irrelevant context
- Demonstrated fewer redundant interface operations and invalid clicks compared to baseline methods

## Why This Works (Mechanism)

### Mechanism 1: Event-Driven Decoupling of Perception and Action
Decoupling event generation from action selection improves responsiveness and state consistency compared to sequential polling loops. Raw observations from sensors/clients are transformed into structured Events with timestamps and metadata, buffered in a central queue, and processed asynchronously by the Action Selector—eliminating blocking dependencies between perception and execution.

### Mechanism 2: Structured Event Transformation via LLM-Based Parsing
Transforming raw environmental observations into semantically enriched Events improves action selection quality. An LLM-powered Event Generator parses observations and available actions into structured objects with fields (intent, observations, available actions, timestamp), enabling the Action Selector to reason over normalized inputs rather than raw strings.

### Mechanism 3: Two-Stage Action Selection with Candidate Generation and Dispatch
Separating action candidate generation from final selection reduces invalid actions and improves task alignment. First, an Action Generator proposes up to 5 candidate actions constrained to executable formats. Then, a Dispatcher evaluates semantic alignment with the task goal and selects exactly one action (or no-op). This pipeline filters out incoherent or non-executable actions.

## Foundational Learning

- **Event-driven architecture and message-passing concurrency**
  - Why needed here: Amico's core runtime replaces sequential polling with asynchronous event streams; understanding event queues, decoupled producers/consumers, and non-blocking dispatch is essential.
  - Quick check question: Can you explain how an event queue decouples a sensor producing 100 events/second from a consumer processing 50 events/second?

- **Retrieval-Augmented Generation (RAG)**
  - Why needed here: The Amico+RAG variant integrates Honcho for contextual memory; understanding embedding-based retrieval, memory partitioning, and retrieval timing is required to extend or debug this module.
  - Quick check question: What happens to retrieval quality if the embedding space drifts between storage and query time?

- **WebAssembly (WASM) for edge deployment**
  - Why needed here: Amico targets embedded platforms via WASM; understanding WASM's memory model, near-native performance, and sandboxing constraints informs deployment decisions.
  - Quick check question: Why might WASM be preferred over Docker containers for resource-constrained edge devices?

## Architecture Onboarding

- Component map:
  - Environment Layer (sensors/IoT) -> Event Generator (LLM parsing) -> Event Queue (buffer) -> Action Selector (Generator → Dispatcher) -> Effectors (execute) -> Feedback -> Event Generator

- Critical path:
  1. Sensor/Client input → Event Generator (LLM parsing)
  2. Structured Event → Event Queue (timestamped buffer)
  3. Action Selector retrieves latest Event + RAG context + available actions
  4. Action Generator proposes ≤5 candidates → Dispatcher selects one
  5. Effector executes → Feedback → Event Generator (next cycle)

- Design tradeoffs:
  - Amico vs. Amico+RAG: Pure Amico (0.61) outperformed Amico+RAG (0.53) on WebShop. Assumption: RAG introduced latency or irrelevant context for tightly scoped tasks.
  - Event queue depth: Larger buffers handle bursty inputs but increase latency; tune based on event arrival rate and processing capacity.
  - LLM dependency: Both Event Generator and Action Selector require LLM calls—latency and cost scale with step count.

- Failure signatures:
  - Queue overflow: Events dropped or delayed; reactivity degrades
  - Malformed events: Event Generator LLM produces invalid JSON or missing fields; Action Selector fails
  - Excessive no-ops: Dispatcher issues noop repeatedly; task stalls
  - RAG noise: Irrelevant retrieved content disrupts reasoning; Amico+RAG underperforms baseline

- First 3 experiments:
  1. Baseline replication: Run the 200-task WebShop subset with pure Amico (no RAG) using the open-source repo. Verify reward ≈0.61.
  2. Event queue stress test: Flood the Event Generator with high-frequency synthetic events. Measure queue latency, drop rate, and action selection delay.
  3. RAG ablation on longer-horizon tasks: Test Amico+RAG on a multi-session task requiring cross-session memory. Compare against pure Amico to identify scenarios where RAG provides net benefit.

## Open Questions the Paper Calls Out

### Open Question 1
Can dynamic memory pruning and intent-aware retrieval optimization reverse the observed performance degradation when integrating retrieval-augmented generation (RAG) into Amico? The current RAG implementation (Honcho) introduced latency and irrelevant documents that disrupted decision coherence in tightly scoped tasks. Evidence needed: A modified Amico+RAG system achieving a reward score greater than 0.61 on the WebShop benchmark.

### Open Question 2
Does decomposing the Event Generator and Action Selector into separate, asynchronous cooperative agents improve scalability compared to the monolithic runtime? The current architecture operates these components in a coupled manner; asynchronous separation requires new conflict arbitration mechanisms. Evidence needed: Performance metrics showing improved throughput or success rates in multi-task environments using the multi-agent architecture.

### Open Question 3
Can reinforcement learning (e.g., PPO) effectively replace manually defined heuristics to optimize adaptive event scheduling? The current reliance on static priorities limits adaptability to varying task complexity or time constraints dynamically. Evidence needed: An RL-trained scheduler demonstrating higher efficiency or accuracy than the static baseline in dynamic domains.

## Limitations
- Task Domain Specificity: Experimental evaluation limited to WebShop benchmark; unclear how architecture generalizes to real-time perception, embodied navigation, or multi-modal sensory inputs.
- LLM Dependency and Cost: Both Event Generator and Action Selector depend on LLM calls for every decision cycle, introducing potential bottlenecks in latency, cost, and reliability.
- RAG Integration Trade-off: Amico+RAG underperformed pure Amico on WebShop, suggesting retrieval augmentation may introduce noise or latency in tightly scoped tasks.

## Confidence
- High Confidence: Core event-driven architecture (decoupling perception and action via asynchronous event queues) is well-supported by implementation description and empirical results.
- Medium Confidence: Effectiveness of two-stage action selection pipeline demonstrated in WebShop task but lacks direct comparison to alternative strategies in agent framework literature.
- Medium Confidence: Claim that Amico outperforms baseline LLM prompting method supported by single experiment on one benchmark; generalization requires further validation.

## Next Checks
1. Cross-Domain Generalization Test: Deploy Amico on continuous control or embodied navigation task (e.g., robotic manipulation or autonomous driving simulation) to evaluate whether event-driven decoupling generalizes beyond web interfaces.
2. LLM Failure Mode Analysis: Systematically inject LLM failures (timeouts, malformed outputs, high latency) into Event Generator and Action Selector. Measure impact on task completion and identify whether fallback mechanisms are needed.
3. RAG Ablation in Long-Horizon Tasks: Design multi-session or memory-intensive task where cross-session reasoning is essential. Compare Amico+RAG against pure Amico and baseline methods to identify scenarios where retrieval augmentation provides measurable benefit.