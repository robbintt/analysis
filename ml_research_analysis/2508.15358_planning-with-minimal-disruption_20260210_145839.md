---
ver: rpa2
title: Planning with Minimal Disruption
arxiv_id: '2508.15358'
source_url: https://arxiv.org/abs/2508.15358
tags:
- plan
- disruption
- state
- task
- planning
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: This paper introduces plan disruption as a new metric for measuring
  the number of changes required to transform the initial state into the goal state
  in planning problems. The authors propose two compilations - lazy and eager plan
  disruption - to jointly optimize both action costs and plan disruption.
---

# Planning with Minimal Disruption
## Quick Facts
- arXiv ID: 2508.15358
- Source URL: https://arxiv.org/abs/2508.15358
- Reference count: 21
- Primary result: Plan disruption as a metric for measuring state changes in planning problems

## Executive Summary
This paper introduces plan disruption as a novel metric for quantifying the number of state changes required to transform an initial state into a goal state in planning problems. The authors propose two compilation approaches - lazy and eager plan disruption - that jointly optimize both action costs and plan disruption. The eager compilation dynamically updates action costs based on fluent changes, while the lazy compilation introduces new fluents and actions to track changes after goal achievement. Experiments on 1847 STRIPS tasks demonstrate that these compilations can effectively balance cost and disruption when task variability exists.

## Method Summary
The authors introduce plan disruption as a new planning metric that measures the number of changes (additions and deletions of fluents) required to reach a goal state from an initial state. They propose two compilation approaches: the eager compilation, which updates action costs dynamically based on changes to fluents during planning, and the lazy compilation, which introduces new fluents and actions to track state changes after the goal is achieved. Both compilations transform the original planning problem into a weighted PDDL format that can be solved by standard planners. The eager approach maintains similar scalability to standard planning but may produce suboptimal disruption values, while the lazy approach guarantees optimal disruption at the cost of significantly increased execution time.

## Key Results
- Plan disruption provides a meaningful metric for quantifying state changes in planning problems
- Eager compilation scales similarly to standard planning but can produce higher disruption values than optimal
- Lazy compilation guarantees optimal disruption but requires significantly more execution time
- Most tasks show limited variability in plan disruption, but compilations effectively balance objectives when diversity exists

## Why This Works (Mechanism)
Plan disruption works by explicitly measuring and optimizing the number of state changes (fluent additions and deletions) that occur during plan execution. The mechanism captures the intuition that plans requiring fewer changes to the world state are often preferable in practice, as they minimize disruption to ongoing processes. By transforming this objective into a weighted planning problem, standard planners can optimize for both cost and disruption simultaneously. The eager compilation achieves this by dynamically adjusting action costs based on their impact on fluents, while the lazy compilation tracks changes through additional state variables introduced after goal achievement.

## Foundational Learning
- **Plan Disruption Metric**: A measure of the total number of state changes (fluent additions and deletions) in a plan; needed to quantify plan "smoothness" and minimize world state changes.
- **STRIPS Planning**: A classical planning framework using preconditions and effects; needed as the baseline problem representation.
- **Weighted PDDL**: An extension of PDDL that allows action costs to be specified; needed to encode the dual objectives of cost and disruption.
- **Compilation Techniques**: Methods to transform planning problems with new objectives into standard formats; needed to leverage existing planners.
- **Eager vs Lazy Evaluation**: Eager updates costs immediately based on changes, lazy tracks changes after execution; needed to explore different optimization strategies.
- **Fluent Tracking**: Monitoring the addition and deletion of state variables; needed to measure disruption accurately.

## Architecture Onboarding
- **Component Map**: Original STRIPS problem -> Eager Compilation (cost updates) OR Lazy Compilation (new fluents/actions) -> Weighted PDDL problem -> Standard Planner -> Plan with minimal disruption
- **Critical Path**: Problem definition → Compilation transformation → Weighted PDDL generation → Planning solver execution → Plan extraction with disruption measurement
- **Design Tradeoffs**: Eager compilation offers better scalability but potentially suboptimal disruption; lazy compilation guarantees optimal disruption but with significant time overhead
- **Failure Signatures**: Eager compilation may get stuck in local optima producing higher disruption; lazy compilation may timeout on larger problems due to state space explosion
- **First Experiments**: 1) Run both compilations on a simple STRIPS problem with known optimal disruption; 2) Compare runtime of eager compilation vs standard planning on medium-sized problems; 3) Verify that lazy compilation produces lower disruption values than eager on a small benchmark suite

## Open Questions the Paper Calls Out
None

## Limitations
- Empirical evaluation focuses on synthetic benchmarks without real-world validation
- Eager compilation may produce higher disruption values than optimal in some cases
- Lazy compilation's significant time overhead limits applicability in time-sensitive domains
- No analysis of how the metric handles probabilistic or uncertain environments

## Confidence
- High Confidence: The fundamental concept of plan disruption as a measurable metric, and the basic formulations of both compilations
- Medium Confidence: The experimental results showing trade-offs between the two approaches, though the lack of real-world validation reduces certainty about practical performance
- Low Confidence: Claims about scalability and practical applicability, particularly regarding the lazy compilation's overhead and the eager compilation's optimality guarantees

## Next Checks
1. Implement the eager compilation on a real-world planning problem with clear initial/goal states to verify whether higher disruption values manifest in practice and assess their practical impact.

2. Conduct a detailed runtime analysis comparing the lazy compilation to standard planning across varied problem sizes to quantify the scaling factor and identify break-even points where its optimality becomes valuable.

3. Test both compilations on domains with partial observability or probabilistic effects to evaluate how well plan disruption handles uncertainty in state transitions.