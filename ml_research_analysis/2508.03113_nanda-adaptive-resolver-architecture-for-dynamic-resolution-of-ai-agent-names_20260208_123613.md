---
ver: rpa2
title: 'NANDA Adaptive Resolver: Architecture for Dynamic Resolution of AI Agent Names'
arxiv_id: '2508.03113'
source_url: https://arxiv.org/abs/2508.03113
tags:
- agent
- name
- communication
- agents
- context
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: This paper presents a microservice architecture for dynamic resolution
  of AI agent names, enabling context-aware, real-time endpoint selection based on
  factors like geographic location, system load, and security threats. The system
  allows agents to advertise their requirements through Agent Fact cards in an Agent
  Registry, enabling tailored communication channels that go beyond traditional client-server
  models.
---

# NANDA Adaptive Resolver: Architecture for Dynamic Resolution of AI Agent Names

## Quick Facts
- **arXiv ID**: 2508.03113
- **Source URL**: https://arxiv.org/abs/2508.03113
- **Reference count**: 1
- **Primary result**: Presents microservice architecture for dynamic, context-aware resolution of AI agent names to enable real-time, tailored endpoint selection

## Executive Summary
This paper proposes an architecture for dynamic resolution of AI agent names that extends DNS principles to support context-aware, real-time selection of communication endpoints. The system enables agents to advertise their requirements through Agent Fact cards and allows resolution based on factors like geographic location, system load, security threats, and resource constraints. The architecture supports negotiation of trust, quality of service, and resource constraints to facilitate secure, scalable agent-to-agent interactions. Key deployment modes include moving server endpoints closer to clients, using AI gateways, agent mobility, and multi-party communication. The approach provides a foundation for robust, future-proof agent communication that can evolve with increasing ecosystem complexity.

## Method Summary
The architecture implements a DNS-inspired recursive resolution system using REST APIs over HTTPS. Key components include an Agent Registry for discovery, hierarchical Name Space with Intermediate and Authoritative Name Servers, and a Recursive Resolver for clients. The process involves discovery of Agent Facts cards, resolution of agent names through hierarchical name servers, optional negotiation phase for context requirements, and deployment of optimized communication channels. The system supports context-aware endpoint selection where different requesters may receive different URLs for the same agent based on their environmental context.

## Key Results
- Enables context-aware, real-time selection of communication endpoints based on geographic location, system load, agent capabilities, and security threats
- Supports hierarchical delegation of name resolution allowing scalable, distributed management of agent namespaces across organizational boundaries
- Implements multi-phase negotiation enabling agents to establish trust, agree on QoS/security requirements, and optimize communication channel placement

## Why This Works (Mechanism)

### Mechanism 1
Context-aware resolution enables different requesters to receive tailored communication endpoints for the same agent based on their environmental context. The Authoritative Name Server receives both the requester's context (location, topology) and the target agent's deployment constraints, then selects or constructs an endpoint optimized for that specific interaction—similar to how DNS Authoritative Name Servers return "Tailored Responses" based on requester location (RFC 7871). This works under the assumption that sufficient context metadata is available and accurate from both parties, with optimization decisions made quickly enough to avoid becoming a bottleneck.

### Mechanism 2
Hierarchical delegation of name resolution allows scalable, distributed management of agent namespaces across organizational boundaries. Agent names follow a URN-style hierarchy (e.g., `ual:nanda.mit.edu:lab15:robot42`). The namespace identifier maps to a DNS name for the root name server. Resolution proceeds recursively through Intermediate Name Servers to the Authoritative Name Server, with referrals cached for efficiency—mirroring DNS recursive resolution patterns. This assumes the hierarchical naming authority is trusted and intermediate servers are available and correctly route referrals.

### Mechanism 3
Multi-phase negotiation enables agents to establish trust, agree on QoS/security requirements, and optimize communication channel placement before interaction begins. If initial context exchange is insufficient, the Authoritative Name Server returns a "Negotiation Invitation." Brokers for each party then gather metadata (physical resources, usage patterns, security requirements, cost constraints) to produce a Comms Spec, which is optimized into a Placement Spec and deployed by resource owners. This assumes negotiation algorithms exist and can converge, all parties participate in good faith, and resource owners will honor placement specifications.

## Foundational Learning

- **Concept: DNS Recursive Resolution**
  - Why needed here: The entire architecture is presented as an extension of DNS principles. Understanding how DNS Authoritative Name Servers, recursive resolvers, and referral caching work is prerequisite to grasping the proposed system.
  - Quick check question: Can you explain why DNS returns different IP addresses to clients in different geographic locations, and what role the Authoritative Name Server plays in that decision?

- **Concept: URN/URI Namespace Design**
  - Why needed here: The paper proposes agent names follow URN syntax (RFC 8141) with hierarchical paths. Understanding namespace identifiers, path delimiters, and the distinction between naming and resolution is essential.
  - Quick check question: Why does the paper argue that "The path name should not muddle identity with communication issues, such as protocol, version, security"?

- **Concept: Microservice and Edge Deployment Patterns**
  - Why needed here: The deployment modes (moving endpoints closer to clients, AI gateways, agent mobility) assume familiarity with CDNs, message buses, and computational offloading.
  - Quick check question: In the "Agent mobility" deployment mode, what moves where, and why is this the opposite of traditional CDN-style server distribution?

## Architecture Onboarding

- **Component map**: Requester Agent -> Recursive Resolver -> Root/Intermediate Name Servers -> Authoritative Name Server -> Communication Environment
- **Critical path**: Discovery (obtain Agent Facts card) → Extract Agent Name + context requirements → Resolver Query to Recursive Resolver → Recursive delegation through name servers → Authoritative Name Server optimization → Return tailored endpoint URL. If context is insufficient, insert negotiation phase before optimization.
- **Design tradeoffs**: Static URL in Agent Facts card vs. dynamic resolution (simpler vs. scalable); centralized vs. distributed optimization (current plan vs. future evolution); privacy vs. context richness (better optimization vs. information exposure).
- **Failure signatures**: Resolution timeout (network partition or misconfigured delegation); Negotiation loop (parties cannot agree on requirements); Context mismatch (returned endpoint doesn't meet QoS/security needs); Cache staleness (using outdated referrals or endpoints).
- **First 3 experiments**:
  1. Implement a minimal Recursive Resolver and single Authoritative Name Server returning static URLs; verify basic name-to-endpoint resolution works before adding context awareness.
  2. Add context metadata (requester location, target geo-constraints) and implement simple "closest endpoint" selection; validate that different requesters receive different URLs.
  3. Introduce a simulated negotiation phase where requester and target exchange requirement constraints before endpoint assignment; measure added latency and identify break conditions where negotiation fails to converge.

## Open Questions the Paper Calls Out

### Open Question 1
What specific algorithms can effectively perform requirements negotiation between agents when entities may maintain hidden costs and private goals? The architecture defines the "Negotiation Invitation" hook but explicitly defers the logic for consensus-building to future designs. A protocol that allows agents to agree on a "Comms Spec" despite incomplete disclosure of internal constraints is needed.

### Open Question 2
How can the deployment optimization process be solved efficiently, particularly as the system evolves from centralized to distributed execution? The authors currently describe only the input (Comms Spec) and output (Placement Spec) without defining the optimization logic. An algorithm capable of mapping communication requirements to physical resources within the resolver's critical path latency limits is required.

### Open Question 3
What constitutes the minimal, extensible metadata schema required for the OpenAPI specification to support dynamic resolution? The paper focuses on architectural flow, leaving the concrete data definitions necessary for a reference implementation undefined. A formalized schema and reference implementation that validates the "start off simple and be extensible" requirement is needed.

## Limitations
- Critical algorithms for context-aware optimization and multi-party negotiation are explicitly deferred, leaving significant gaps in reproducibility
- Architecture relies heavily on assumed metadata quality and availability with no discussion of privacy-preserving techniques for context exchange
- Does not address the complexity of managing trust across organizational boundaries or performance impact of recursive resolution compared to simpler approaches

## Confidence
- **High confidence**: Hierarchical name resolution mechanism and DNS extension principles are well-grounded in existing protocols
- **Medium confidence**: Multi-phase negotiation framework is theoretically plausible but lacks algorithmic specification
- **Low confidence**: Deployment mode claims are described at a high level without concrete implementation guidance or performance considerations

## Next Checks
1. **Metadata Schema Validation**: Implement and test a minimal schema for Agent Facts cards and context metadata to verify that required fields capture sufficient information for meaningful endpoint optimization without exposing excessive privacy-sensitive data.

2. **Context-Aware Resolution Prototype**: Build a prototype Authoritative Name Server that implements simple context-based routing rules (e.g., geographic proximity, load-based endpoint selection) and measure the performance overhead compared to static resolution.

3. **Negotiation Failure Analysis**: Simulate negotiation scenarios with conflicting requirements and missing context to identify break conditions, timeouts, and fallback mechanisms that the paper does not specify.