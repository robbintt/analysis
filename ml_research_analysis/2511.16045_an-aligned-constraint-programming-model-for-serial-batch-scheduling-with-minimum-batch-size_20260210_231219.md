---
ver: rpa2
title: An Aligned Constraint Programming Model For Serial Batch Scheduling With Minimum
  Batch Size
arxiv_id: '2511.16045'
source_url: https://arxiv.org/abs/2511.16045
tags:
- jobs
- batch
- instances
- family
- time
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: This paper addresses the serial batch (s-batch) scheduling problem
  with minimum batch sizes, a common requirement in manufacturing processes like semiconductor
  photolithography and ion implantation. The problem involves grouping jobs from similar
  families into batches processed sequentially on machines to minimize setup times,
  while respecting minimum batch size constraints for each family.
---

# An Aligned Constraint Programming Model For Serial Batch Scheduling With Minimum Batch Size

## Quick Facts
- arXiv ID: 2511.16045
- Source URL: https://arxiv.org/abs/2511.16045
- Reference count: 40
- Primary result: Proposed CP models outperform existing methods, achieving solutions up to 25% better on large-scale instances within 20-minute time limits

## Executive Summary
This paper addresses the serial batch scheduling problem with minimum batch sizes, a common requirement in manufacturing processes like semiconductor photolithography. The problem involves grouping jobs from similar families into batches processed sequentially on machines to minimize setup times while respecting minimum batch size constraints. Unlike previous CP models that rely on predefined virtual sets of possible batches, this work introduces an aligned CP model (s-A) that directly reasons on sequences of same-family jobs using virtual interval variables and cumulative functions to enforce batch size constraints.

## Method Summary
The proposed method uses Constraint Programming with IBM ILOG CP Optimizer to model the serial batch scheduling problem. It introduces virtual interval variables that extend over family blocks and uses alignment constraints to synchronize them with the job sequence. Cumulative functions count jobs within blocks, enforcing minimum and maximum batch sizes. An improved version (s-A*) adds tailored search phases that first fix core scheduling decisions before refining batch structures, significantly improving performance on large instances.

## Key Results
- s-A and s-A* models consistently outperform previous CP approaches (IA, G, H) and MIP methods on instances up to 500 jobs
- s-A* achieves up to 25% better solutions than state-of-the-art methods on large instances within 20-minute time limits
- Performance is sensitive to symmetry when number of families equals number of machines (|F| = |M|), with significant slowdowns
- Using "Extended" inference levels can slow down the solver, suggesting propagation cost may outweigh pruning benefits

## Why This Works (Mechanism)

### Mechanism 1: Virtual Interval Alignment for Implicit Batching
The model eliminates the "curse of dimensionality" by reasoning directly on schedule geometry using aligned virtual intervals instead of predefined batch indices. Optional virtual intervals are created for each job and forced to stretch to family block boundaries using the `alwaysEqual` constraint, creating an implicit batch structure derived from job sequences rather than pre-defined indices.

### Mechanism 2: Cumulative Function Sizing
Minimum and maximum batch size constraints are enforced globally by monitoring cumulative function heights over aligned virtual intervals. A cumulative function $n_{mf}$ pulses +1 for each virtual interval in a family block, and the `alwaysIn` constraint ensures the height remains within batch size bounds $[l_f, u_f]$.

### Mechanism 3: Two-Phase Search & Formulation Refinement (s-A*)
Performance on large instances is improved by decoupling core scheduling decisions from batch-sizing variables via tailored search phases. The s-A* model uses Phase 1 to fix core intervals (assignment and sequencing) and Phase 2 to subsequently fix virtual intervals (block structure), preventing backtracking on batch geometry before the underlying schedule is stable.

## Foundational Learning

- **Concept: Interval Variables in Constraint Programming**
  - Why needed here: The entire architecture relies on "core" and "virtual" interval variables with start, end, size, and presence status
  - Quick check question: How does the `alternative` constraint (Eq. 1f) enforce that a job is processed on exactly one machine?

- **Concept: State Functions and Alignment**
  - Why needed here: The "magic" of the s-A model is aligning virtual intervals to the family block via the `alwaysEqual` constraint acting on a state function
  - Quick check question: In the Family Block section, what specific constraint parameter is enabled to force the virtual interval's start/end to match the state function's transition points?

- **Concept: Serial vs. Parallel Batching**
  - Why needed here: The paper adapts an "Aligned" model originally designed for parallel batching to serial batching, requiring understanding of jobs as sequential vs. overlapping
  - Quick check question: In s-batch, why does aligning the *virtual* intervals (which overlap) help count jobs that are actually processed sequentially?

## Architecture Onboarding

- **Component map:** Input (Jobs, Machines, Setups) -> Core Section (`alternative` -> `noOverlap` -> `alwaysEqual`) -> Family Block Section (Virtual Intervals -> Containment -> Alignment) -> Sizing Section (Cumulative Function -> `alwaysIn`)

- **Critical path:** The interaction between `noOverlap` sequence and cumulative sizing function is the performance bottleneck. If sequence is undetermined, cumulative function cannot bound block sizes, causing propagation failure.

- **Design tradeoffs:** The s-A model trades explicit modularity of "virtual set of batches" for a more compact but tighter formulation. While solving large instances better, it sacrifices intuitive "batch variable" useful for downstream reporting or warm-starting.

- **Failure signatures:**
  - Symmetry Stalls: If `|F| = |M|` (e.g., 10 families, 10 machines), performance degrades significantly due to symmetrical machine assignments
  - Inference Overhead: Using "Extended" inference levels can slow down the solver, suggesting propagation cost outweighs pruning benefit

- **First 3 experiments:**
  1. Run the Core section alone on a small instance to confirm it minimizes TWCT but violates minimum batch sizes
  2. Run s-A* on large instances (500 jobs) with search phases disabled to quantify tailored search contribution
  3. Generate instances where `|F| = |M|` vs `|F| > |M|` to verify symmetry sensitivity

## Open Questions the Paper Calls Out

- Can effective symmetry-breaking constraints be developed for the Aligned CP model to improve performance on instances where the number of families equals the number of machines? The authors identify this as a potential research stream, noting that early attempts failed because they pruned improving solutions derived from non-identical release times.

- Can the Aligned model's logic be successfully adapted to open-source CP solvers that may lack specific advanced global constraints used in IBM ILOG CP Optimizer? The authors explicitly list this as ongoing work.

- How does the s-A* model perform when integrated into dynamic digital-twin frameworks requiring frequent rescheduling to handle real-time disturbances? Future work includes embedding models into richer wafer-fab scheduling and digital-twin frameworks.

## Limitations

- Performance comparison is limited to specific prior methods (RP MIP, IA, G, H models) within constrained time limits (20 minutes)
- The exact propagation dynamics of the `alwaysEqual` alignment and cumulative function's tightness are not empirically validated
- The paper does not propose concrete symmetry-breaking constraints despite identifying significant sensitivity to problem symmetry

## Confidence

- Claims about model superiority (up to 25% better) are **High confidence** based on extensive experiments across 4,920 instances
- Claims about the mechanism of aligned virtual intervals and cumulative sizing are **Medium confidence** - equations are clear but propagation dynamics are not validated
- Claims about symmetry sensitivity and inference level tradeoffs are **High confidence** based on explicit experimental results

## Next Checks

1. **Ablation Study on Alignment:** Run s-A* on large instances with `alwaysEqual` alignment parameters disabled to quantify alignment mechanism contribution

2. **Symmetry Stress Test:** Generate and test instances where `|F| = |M|` versus `|F| > |M|` to validate reported symmetry sensitivity and evaluate potential symmetry-breaking constraints

3. **Inference Level Sensitivity:** Systematically test s-A* model with different inference levels (Basic, Extended, Full) on representative instances to confirm reported tradeoff between propagation cost and pruning benefit