---
ver: rpa2
title: 'HTN Plan Repair Algorithms Compared: Strengths and Weaknesses of Different
  Methods'
arxiv_id: '2504.16209'
source_url: https://arxiv.org/abs/2504.16209
tags:
- repair
- plan
- problems
- problem
- solutions
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: 'This paper compares three HTN plan repair algorithms: SHOPFixer,
  IPyHOPPER, and Rewrite. The algorithms differ in their definitions of plan repair
  and search strategies.'
---

# HTN Plan Repair Algorithms Compared: Strengths and Weaknesses of Different Methods

## Quick Facts
- arXiv ID: 2504.16209
- Source URL: https://arxiv.org/abs/2504.16209
- Reference count: 40
- Primary result: SHOPFixer's causal-link analysis scales better for complex problems, IPyHOPPER is faster on simple problems, and Rewrite guarantees prefix preservation but is often the slowest due to extensive replanning.

## Executive Summary
This paper compares three HTN plan repair algorithms—SHOPFixer, IPyHOPPER, and Rewrite—differing in their definitions of plan repair and search strategies. SHOPFixer uses causal-link analysis with backjumping to identify minimal repair subtrees, IPyHOPPER employs forward simulation with chronological backtracking, and Rewrite replans from scratch while preserving the executed action prefix. Theoretical analysis shows their solution sets are distinct but overlapping, with SHOPFixer's solutions being a subset of IPyHOPPER's. Empirical evaluation on benchmark domains (Rovers, Satellites, Openstacks) reveals that IPyHOPPER generally has faster runtimes on simpler problems, SHOPFixer scales better for complex problems, and Rewrite is often the slowest due to extensive replanning. The choice of algorithm depends on domain characteristics and the importance of runtime efficiency versus solution flexibility.

## Method Summary
The paper compares three HTN plan repair algorithms on benchmark domains adapted from IPC problems. SHOPFixer uses causal-link analysis with backjumping to localize failures and repair minimal subtrees. IPyHOPPER uses forward simulation with chronological backtracking to predict action effects and find repairs. Rewrite compiles a new HTN domain forcing exact action-prefix preservation, then invokes an external planner. Experiments run 50 trials per problem with random disturbances, measuring runtime and success rates with 300-second timeout. SHOPFixer is implemented in Common Lisp, IPyHOPPER in Python, and Rewrite uses an external HTN planner (SHOP3 recommended).

## Key Results
- IPyHOPPER generally has faster runtimes on simpler problems due to minimal upfront cost and efficient simulation-based prediction
- SHOPFixer scales better for complex problems by leveraging causal-link analysis to prune search space through backjumping
- Rewrite guarantees executed-action-prefix stability but is often the slowest due to extensive replanning overhead
- SHOPFixer's solutions form a subset of IPyHOPPER's solution space according to theoretical analysis
- Algorithm performance varies significantly based on domain characteristics and problem complexity

## Why This Works (Mechanism)

### Mechanism 1: SHOPFixer's Causal-Link Analysis with Backjumping
SHOPFixer constructs a dependency graph linking task decompositions to their preconditions and effects. When a disturbance occurs, it locates the first node whose preconditions are violated and backjumps to the parent of its immediate parent, potentially skipping many intermediate search decisions. This holistic repair can resolve cascading failures without chronological unwinding. The core assumption is that domain structure includes sufficient causal dependencies to localize failures, and preconditions are explicitly modeled at method and action levels. Domains with sparse precondition modeling or highly interconnected causal graphs where failure localization provides no search reduction break this mechanism.

### Mechanism 2: IPyHOPPER's Forward Simulation with Chronological Backtracking
IPyHOPPER defers computational cost until disturbances occur by using forward simulation rather than maintaining internal projection. Upon failure at an action, it restarts decomposition at the task that produced that action using the current observed state, then simulates forward. If simulation fails at a subsequent action, repair recurses. Backtracking proceeds chronologically through the decomposition tree. The core assumption is that the simulator accurately reflects domain dynamics and the search space near the failure point contains valid repairs. Complex search spaces where chronological backtracking must explore many dead ends before finding repairs, and domains with tight inter-task dependencies, break this mechanism.

### Mechanism 3: REWRITE's Domain Compilation for Prefix Preservation
Rewrite compiles the repair problem into a new HTN domain where the last executed action produces the observed disturbed state rather than the predicted state. It then invokes an HTN planner on the compiled problem, guaranteeing that any solution must begin with the exact action sequence. This ensures maximal stability but restricts the solution space—some repairs available to SF/IPH become impossible. The core assumption is that the underlying HTN planner can efficiently solve the compiled problem and the executed prefix was generated by some valid decomposition. Domains where prefix preservation prevents any valid repair, or problems requiring re-decomposition of partially-executed tasks, break this mechanism.

## Foundational Learning

- Concept: **Decomposition Trees (d-trees)**
  - Why needed here: All three algorithms operate on d-trees; understanding subtree notation (T[t], T[≺t], T[≻t]) is required to follow repair localization logic.
  - Quick check question: Given a d-tree with root task t0 decomposed via method m into subtasks [t1, t2], what does T[⪯t1] return?

- Concept: **pre*() Function for Method Preconditions**
  - Why needed here: SF's Class 3 repair and IPH's Class 4 repair differ precisely in whether they use pre*(a) or pre(a); understanding this recursive precondition accumulation explains the solution-space inclusion relationship.
  - Quick check question: If action a is the second child of method m, and m is the child of task t with pre(t)={p1}, what is pre*(a)?

- Concept: **Plan Stability vs. Prefix Preservation**
  - Why needed here: The paper's central distinction is that RW enforces prefix preservation (syntactic), while SF/IPH pursue stability (semantic similarity via localized changes).
  - Quick check question: Why might a repaired plan that preserves the action prefix still be considered "unstable"?

## Architecture Onboarding

- Component map: Input Layer (HDDL/SHOP3 domain files, initial plan π, disturbance specification) -> Repair Engine (SF: causal-link analyzer → failure localizer → backjump controller → subtree reconstructor | IPH: simulator interface → failure detector → chronological backtracker → forward validator | RW: domain compiler → external HTN planner) -> Output (Repaired d-tree T' or "unrepairable" verdict)

- Critical path:
  1. Parse executed/unexecuted boundary (ac, sc, Tx, Tu)
  2. Detect failure point (df for SF, af for IPH, compiled constraint for RW)
  3. Search for valid repair (backjump + re-decompose | backtrack + re-simulate | re-plan from compiled problem)
  4. Validate repaired plan applicability in sc

- Design tradeoffs:
  - SF: Higher upfront cost (causal graph construction) → faster complex-problem repair; lower solution variance; subset of IPH solutions
  - IPH: Minimal upfront cost → faster simple-problem repair; higher runtime variance; larger solution space
  - RW: Maximum stability guarantee → slowest; smallest solution space; some problems solvable by SF/IPH become unsolvable
  - Assumption: Domain characteristics (problem size, disturbance frequency, stability requirements) should drive selection.

- Failure signatures:
  - SF timeouts on large problems with sparse causal structure (backjumping provides little pruning)
  - IPH timeouts on highly constrained domains (chronological backtracking explores many dead ends)
  - RW returns "unsolvable" when SF/IPH succeed (prefix preservation over-constrains)
  - RW timeouts on problems requiring extensive re-derivation of already-executed portions

- First 3 experiments:
  1. **Domain baseline**: Run all three algorithms on undisturbed plans to measure overhead; expect SF > IPH > RW in runtime.
  2. **Disturbance localization**: Inject single-precondition failures at increasing depths in T; measure how search-space reduction correlates with depth for SF vs. IPH.
  3. **Stability-flexibility tradeoff**: On problems where RW succeeds, compare action-edit-distance between original and repaired plans across all three algorithms; verify SF/IPH produce higher-variance solutions.

## Open Questions the Paper Calls Out

- **Open Question 1**: What is the optimal strategy for scheduling re-grounding relative to the generation of the rewritten repair problem in grounded HTN planning systems? The paper states this remains to be determined, as their implementation avoided the "chicken-and-egg" problem by using a lifted approach while grounded implementations struggled with parsing complexity.

- **Open Question 2**: How do specific HTN domain engineering choices—such as the placement of preconditions or the structure of task hierarchies—influence the tradeoffs between repair efficiency and solution flexibility? The paper proposes studying this, noting current benchmarks were not designed for execution or repairability and often lack necessary domain properties to facilitate stable repair.

- **Open Question 3**: Can specific search heuristics be developed for the Rewrite algorithm to minimize replanning costs by efficiently guiding the planner to replicate the executed action prefix? The authors note Rewrite's efficiency could likely be substantially improved by heuristic guidance to direct early planning towards methods that replicate previously seen actions.

## Limitations
- Theoretical guarantees about solution space relationships are not empirically validated; runtime experiments show IPyHOPPER can fail on problems where SHOPFixer succeeds, suggesting theoretical solution spaces may not directly translate to practical solvability.
- The paper lacks systematic analysis of which domain characteristics favor which algorithms beyond general observations about problem size and complexity.
- Implementation details vary substantially across algorithms (Common Lisp vs Python vs external planner calls), making direct runtime comparisons potentially misleading without controlling for language and implementation overhead.

## Confidence
- **High Confidence**: The theoretical analysis of solution space relationships and the observation that SHOPFixer's causal-link analysis provides pruning benefits for complex problems are well-supported by the paper's formalism.
- **Medium Confidence**: Empirical runtime results showing algorithm preferences on different problem sizes are reasonable but limited by the small number of benchmark problems and lack of systematic domain characteristic analysis.
- **Low Confidence**: Claims about Rewrite's absolute stability guarantees are theoretically sound but practically questionable since some problems solvable by SHOPFixer/IPyHOPPER become unsolvable under prefix preservation constraints.

## Next Checks
1. **Solution Space Validation**: Systematically test problems where SHOPFixer succeeds but IPyHOPPER fails (and vice versa) to empirically verify Theorem 4's claim about solution set relationships.
2. **Domain Characteristic Analysis**: Correlate algorithm performance with measurable domain features (average method depth, precondition count per action, task branching factor) to identify which characteristics predict algorithm success.
3. **Implementation Overhead Control**: Benchmark the algorithms using a common implementation framework or explicitly account for language/runtime differences to isolate algorithmic performance from implementation artifacts.