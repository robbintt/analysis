---
ver: rpa2
title: 'VehicleWorld: A Highly Integrated Multi-Device Environment for Intelligent
  Vehicle Interaction'
arxiv_id: '2509.06736'
source_url: https://arxiv.org/abs/2509.06736
tags:
- value
- call
- system
- self
- state
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: VehicleWorld is the first comprehensive multi-device environment
  for intelligent vehicle interaction, featuring 30 modules, 250 APIs, and 680 properties
  with real-time state information. The study identifies that direct state prediction
  outperforms traditional function calling in complex, state-dependent systems.
---

# VehicleWorld: A Highly Integrated Multi-Device Environment for Intelligent Vehicle Interaction

## Quick Facts
- arXiv ID: 2509.06736
- Source URL: https://arxiv.org/abs/2509.06736
- Reference count: 40
- Primary result: State-based Function Call (SFC) significantly outperforms traditional function calling in complex, state-dependent multi-device control environments

## Executive Summary
VehicleWorld is the first comprehensive multi-device environment for intelligent vehicle interaction, featuring 30 modules, 250 APIs, and 680 properties with real-time state information. Through systematic analysis, the study discovered that direct state prediction outperforms traditional function calling for environmental control in complex, state-dependent systems. Based on this insight, State-based Function Call (SFC) was proposed, maintaining explicit system state awareness and implementing direct state transitions. Experiments show SFC significantly outperforms traditional function calling, achieving superior execution accuracy and reduced latency across all tested models and scenarios.

## Method Summary
The research introduces VehicleWorld as a comprehensive simulation environment for intelligent vehicle interaction, featuring 30 modules, 250 APIs, and 680 properties. The core innovation is State-based Function Call (SFC), a two-stage inference-time prompting strategy that first selects relevant modules based on system state, then generates Python code to directly modify state dictionaries rather than calling APIs sequentially. The evaluation compares final states using accuracy metrics rather than strict API call sequences, allowing for diverse correct paths. The benchmark includes 1291 multi-turn tasks across four domains (Multimedia, Touch Control, Car Control, Light).

## Key Results
- SFC achieves significantly higher execution accuracy than traditional function calling across all tested models and scenarios
- Direct state prediction reduces interaction latency by bypassing exploratory API calls
- State-based evaluation better captures task completion than rule-based API-sequence matching
- Performance degrades as world complexity increases, highlighting the need for improved state representation

## Why This Works (Mechanism)

### Mechanism 1
Direct state prediction outperforms sequential function calling in state-dependent, multi-device control environments. Agents receive complete world-state JSON, predict target states, and generate minimal transition code, bypassing exploratory API calls and reducing planning overhead. The explicit world-state representation allows more accurate intent-to-effect mapping than implicit inference from API signatures.

### Mechanism 2
Real-time, executable state observability improves error recovery and reduces incorrect action confidence. VehicleWorld provides live state JSON during execution, allowing agents to verify actual effects vs. expected outcomes rather than relying solely on API return values, which may be ambiguous. This explicit observability enables better error detection and recovery.

### Mechanism 3
State-based evaluation better aligns with task completion than rule-based API-sequence matching. The evaluation compares final states (did the right attributes change with correct trends?) instead of strict API call sequences, allowing for diverse correct paths. This approach better captures user intent through end-state outcomes rather than rigid action scripts.

## Foundational Learning

- **Finite State Machines (FSMs) for system modeling**: VehicleWorld is essentially a complex FSM with 680 properties; understanding state transitions is core to the SFC approach. Quick check: Given a music player with states {playing, paused, stopped}, what are the valid transitions and their triggering events?

- **Function Calling in LLMs**: The paper contrasts traditional FC with SFC; you must understand what FC is to appreciate the difference. Quick check: In a weather API, what is the typical function call to get the forecast for "Paris, France"?

- **Multi-device coordination and shared resources**: VehicleWorld devices compete for global resources (e.g., sound channel); this is the core complexity being addressed. Quick check: If navigation and music are both active, how should a system decide which uses the audio channel?

## Architecture Onboarding

- **Component map**: Device Classes (30 Python classes) -> Environment Singleton (global shared state) -> State Serializer (JSON conversion) -> Executor (code sandbox) -> Evaluator (state-diff comparison)

- **Critical path**: 1. Initialize world with Environment.init1(), device init() calls 2. Serialize state to JSON for agent 3. Agent generates transition code/API calls 4. Executor runs code, captures results 5. Evaluator compares final state to expected diff

- **Design tradeoffs**: Executable JSON state increases context length but enables direct state manipulation; ReAct prompting provides reasoning trace but adds latency; Singleton Environment enforces consistency but complicates parallel testing

- **Failure signatures**: SFC failure generates syntactically correct but semantically wrong state assignments; FC failure calls non-existent API or misses required sequence; Evaluation mismatch marks creative but correct solutions as wrong

- **First 3 experiments**: 1. Replicate SFC vs. FC comparison on single domain using small model 2. Ablate state observability: provide only API returns to SFC agent 3. Stress-test world complexity: incrementally add irrelevant device states and plot accuracy degradation

## Open Questions the Paper Calls Out

1. How can world model entity classes be automated and standardized to eliminate substantial manual effort for verification and definition?

2. Can agent performance in SFC tasks be maintained as world complexity increases through streamlined state representations or improved agent interpretation?

3. What specific safety and reliability frameworks must be established to bridge the gap between simulated VehicleWorld and real-world in-vehicle deployment?

4. How can the "overthinking" phenomenon—where extended reasoning degrades performance in high-performing models—be mitigated in SFC?

## Limitations

- Substantial manual effort required for constructing and verifying entity classes
- Performance degradation as world complexity increases
- Critical gap between simulated environment and real-world deployment safety requirements
- Model-dependent optimal balance between reasoning steps and direct execution

## Confidence

- **High Confidence**: VehicleWorld architecture and state-based evaluation methodology
- **Medium Confidence**: SFC mechanism performance advantage (depends on undisclosed prompt examples)
- **Low Confidence**: Generalizability to other multi-device environments and robustness of evaluation across task types

## Next Checks

1. Implement ReAct prompts using provided examples to verify SFC vs. FC performance differences persist without original demonstrations

2. Systematically increase irrelevant device states in context and measure accuracy degradation for both SFC and FC approaches

3. Design human evaluation protocol where annotators judge task completion quality independently of state-diff metrics to validate evaluation methodology