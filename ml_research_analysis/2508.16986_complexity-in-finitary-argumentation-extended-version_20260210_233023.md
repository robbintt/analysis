---
ver: rpa2
title: Complexity in finitary argumentation (extended version)
arxiv_id: '2508.16986'
source_url: https://arxiv.org/abs/2508.16986
tags:
- infinite
- extension
- then
- which
- computable
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: This paper investigates the complexity of computational problems
  for infinite but finitary argumentation frameworks, where each argument is attacked
  by only finitely many others. While infinite AFs are expressive and applicable in
  many reasoning scenarios, their computational problems are typically intractable.
---

# Complexity in finitary argumentation (extended version)
## Quick Facts
- arXiv ID: 2508.16986
- Source URL: https://arxiv.org/abs/2508.16986
- Reference count: 40
- Primary result: Finitary AFs with admissibility-based semantics drop from non-arithmetical to Π01-Π03 complexity

## Executive Summary
This paper investigates the computational complexity of infinite but finitary argumentation frameworks, where each argument is attacked by only finitely many others. While infinite AFs are expressive and applicable in many reasoning scenarios, their computational problems are typically intractable. The authors show that the assumption of finitarity does not automatically guarantee a drop in complexity for all semantics. However, for admissibility-based semantics (admissible, stable, and complete), they find a remarkable combinatorial constraint that entails a dramatic decrease in complexity. Specifically, these problems drop from being non-arithmetical in the general infinite case to low levels of the arithmetical hierarchy (Π01 to Π03) in the finitary case.

## Method Summary
The authors analyze computational problems in infinite finitary argumentation frameworks by characterizing their complexity within the arithmetical hierarchy. They establish reductions showing that for admissibility-based semantics, the complexity drops significantly compared to general infinite frameworks. The analysis involves careful examination of the combinatorial properties of finitary AFs and how these properties enable finite-time computations to approximate solutions via limiting procedures. The methodology combines theoretical computer science techniques with argumentation theory to establish these complexity bounds.

## Key Results
- Finitarity alone does not guarantee reduced complexity for all argumentation semantics
- Admissibility-based semantics (admissible, stable, complete) achieve dramatic complexity reduction from non-arithmetical to Π01-Π03 levels
- The complexity drop enables finite-time approximations of solutions via limiting procedures
- This makes finitary frameworks more tractable for practical reasoning tasks compared to general infinite frameworks

## Why This Works (Mechanism)
The complexity reduction occurs because finitary argumentation frameworks have a crucial structural property: while they can be infinite, each argument has only finitely many attackers. This constraint enables a combinatorial analysis that wasn't possible in general infinite frameworks. For admissibility-based semantics, this structure allows the construction of finite approximations that converge to the actual solution. The limiting procedures can be implemented as finite-time computations that progressively refine their approximation of the extension. This is fundamentally different from general infinite frameworks where the non-arithmetical complexity reflects the impossibility of such approximations.

## Foundational Learning
- Arithmetical hierarchy: A classification of decision problems by their logical complexity and computational difficulty. Needed to understand the complexity bounds established in the paper. Quick check: Can you identify problems at different levels of the arithmetical hierarchy?
- Finitary argumentation frameworks: Infinite frameworks where each argument has only finitely many attackers. Needed to understand the specific framework being analyzed. Quick check: Can you distinguish between finitary and general infinite AFs?
- Admissibility-based semantics: Argumentation semantics including admissible, stable, and complete extensions. Needed to understand which semantics benefit from complexity reduction. Quick check: Can you explain the difference between admissible and stable extensions?
- Limiting procedures: Computational methods that approximate solutions through progressive refinement. Needed to understand how finite-time computations can solve infinite problems. Quick check: Can you describe how a limiting procedure might approximate an infinite set?
- Complexity reduction: The phenomenon where certain constraints on problem structure enable dramatic decreases in computational complexity. Needed to understand the main theoretical contribution. Quick check: Can you identify other examples where structural constraints reduce complexity?

## Architecture Onboarding
Component map: Finitary AF -> Admissibility-based semantics -> Limiting procedures -> Complexity reduction
Critical path: The analysis begins with characterizing the combinatorial properties of finitary AFs, then establishes how these properties enable limiting procedures for admissibility-based semantics, and finally proves the complexity bounds through reductions.
Design tradeoffs: The paper trades expressiveness (general infinite frameworks) for tractability (finitary frameworks with admissibility-based semantics). While finitary AFs are less expressive than general infinite frameworks, they enable practical reasoning through complexity reduction.
Failure signatures: If the finitarity constraint is violated (arguments with infinitely many attackers), the complexity reduction fails and problems revert to non-arithmetical complexity. Similarly, if non-admissibility-based semantics are used, the complexity reduction may not occur.
First experiments: 1) Construct a finitary AF and verify that each argument has finitely many attackers. 2) Apply a limiting procedure to approximate an admissible extension. 3) Verify the complexity classification by checking membership in the arithmetical hierarchy.

## Open Questions the Paper Calls Out
None

## Limitations
- The results are primarily theoretical characterizations without concrete implementation or empirical validation of the proposed algorithms
- The paper focuses exclusively on finitary AFs and does not explore how these results extend to other infinite framework variants
- While the complexity bounds are established, the practical efficiency of the limiting procedures for approximation is not quantified

## Confidence
- High confidence in the theoretical complexity reductions for finitary frameworks
- Medium confidence in the practical tractability claims, pending empirical validation
- Medium confidence in the characterization of admissibility-based semantics, as alternative semantic definitions may yield different results

## Next Checks
1. Implement the limiting procedures for approximating admissible/stable/complete extensions and measure their convergence rates on benchmark AFs
2. Test the theoretical complexity results against large-scale finitary argumentation problems to verify practical tractability
3. Compare the finitary framework results with other infinite AF variants to understand the scope and limitations of the findings