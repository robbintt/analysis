---
ver: rpa2
title: Agent-as-a-Service based on Agent Network
arxiv_id: '2505.08446'
source_url: https://arxiv.org/abs/2505.08446
tags:
- agent
- agents
- multi-agent
- aaas-an
- task
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: "This paper proposes Agent-as-a-Service based on Agent Network\
  \ (AaaS-AN), a service-oriented paradigm that unifies the agent lifecycle\u2014\
  including construction, integration, interoperability, and networked collaboration\u2014\
  under a dynamic Agent Network framework. AaaS-AN models agents and agent groups\
  \ as network vertexes and supports service registration, discovery, and distributed\
  \ coordination via a Service Scheduler."
---

# Agent-as-a-Service based on Agent Network

## Quick Facts
- arXiv ID: 2505.08446
- Source URL: https://arxiv.org/abs/2505.08446
- Reference count: 28
- Primary result: Agent-as-a-Service based on Agent Network (AaaS-AN) improves mathematical reasoning accuracy by 5.77% and application-level code generation quality scores up to 0.90

## Executive Summary
This paper introduces Agent-as-a-Service based on Agent Network (AaaS-AN), a service-oriented paradigm that unifies the agent lifecycle under a dynamic Agent Network framework. AaaS-AN models agents and agent groups as network vertexes, supporting service registration, discovery, and distributed coordination via a Service Scheduler. The framework demonstrates superior performance on mathematical reasoning and code generation tasks while reducing token consumption compared to state-of-the-art baselines.

## Method Summary
AaaS-AN implements a service-oriented architecture where agents and agent groups are abstracted as vertexes in a directed acyclic graph. The Service Scheduler receives user tasks, queries a Service Registry for capable vertexes, and manages an Execution Graph for context tracking and distributed coordination. The system employs three routing strategies: HARD routes for fixed workflows, SOFT routes for dynamic intra-group collaboration, and EXT routes for inter-group discovery. Agents are standardized using the RGPS (Role-Goal-Process-Service) model, with inputs/outputs serving as operational constraints.

## Key Results
- Achieved 63.62% accuracy on MATH benchmark, representing a 5.77% improvement over state-of-the-art baselines
- Obtained quality scores up to 0.90 for application-level code generation on SRDD and ProgramDev benchmarks
- Constructed a large-scale multi-agent system with over 100 services and released a dataset of 10,000 long-chain multi-agent workflows
- Demonstrated reduced token consumption through structured context isolation compared to chat-based baselines

## Why This Works (Mechanism)

### Mechanism 1: Structured Context Isolation via Execution Graphs
AaaS-AN reduces token consumption and improves reasoning consistency by replacing full conversation history with structured state tracking. The Service Scheduler maintains an Execution Graph that isolates context per vertex, loading specific structured parameters required for each step instead of passing growing natural language chat logs. This filters out redundant historical messages, allowing LLMs to infer intent and state more accurately from concise, structured inputs.

### Mechanism 2: Hybrid Routing for Generalization
The framework achieves higher generalization on diverse tasks by dynamically mixing fixed and adaptive collaboration patterns. Using HARD routes for tasks with known logical sequences, SOFT routes for dynamic intra-group self-collaboration, and EXT routes for inter-group discovery, the system enforces logic where known while allowing agents to self-organize for novel sub-problems.

### Mechanism 3: Service-Oriented Standardization (RGPS)
Modeling agents as services with standardized I/O enables scalable, plug-and-play interoperability across heterogeneous systems. Agents and Groups are abstracted as Vertexes with strictly defined inputs and outputs, enforcing a contract between upstream and downstream agents and treating interaction as "service invocation" rather than open-ended dialogue.

## Foundational Learning

- **Concept: RGPS (Role-Goal-Process-Service) Standard**
  - Why needed here: This is the meta-model underlying the entire AaaS-AN architecture; you cannot define valid Vertexes or Groups without understanding how Roles map to Goals and Processes
  - Quick check: Can you distinguish between the "Role" (Agent) and the "Goal" (Group) in the RGPS hierarchy?

- **Concept: Model Context Protocol (MCP)**
  - Why needed here: The paper positions AaaS-AN as a layer above MCP; you must understand that MCP handles tool invocation while AaaS-AN handles agent-to-agent organization
  - Quick check: Does AaaS-AN replace MCP, or does it orchestrate agents that utilize MCP servers? (Answer: It orchestrates them)

- **Concept: Directed Acyclic Graphs (DAGs) in Workflows**
  - Why needed here: The Execution Graph and Agent Network rely on graph theory concepts; understanding DAGs is required to visualize how context flows and how loops are detected
  - Quick check: In AaaS-AN, does a "HARD Route" imply a fixed edge in the graph?

## Architecture Onboarding

- **Component map:** User Task Input -> Service Scheduler -> Service Registry -> Execution Graph -> Vertexes (Agents/Groups) -> HARD/SOFT/EXT Routes -> Structured Output

- **Critical path:** 1) User Task Input -> Service Scheduler 2) Scheduler parses Task -> Queries Registry for capable Vertexes 3) Scheduler initiates Execution Graph 4) Execution flows through HARD (fixed) or SOFT (dynamic) routes 5) EXT routes triggered if internal capabilities insufficient 6) Structured Output aggregated from Graph state

- **Design tradeoffs:** Structured vs. Free-text (enforces structured I/O for reliability but requires upfront schema definition); Centralized Scheduler vs. Decentralized Routing (Scheduler acts as central coordinator despite distributed network)

- **Failure signatures:** Infinite Loops (execution paths revisiting same Vertex without state change); Context Stripping (agents claiming "missing context" due to Execution Graph's isolation policy)

- **First 3 experiments:** 1) Vertex Compliance Test: Create Agent Group with conflicting Role definitions to verify RGPS model enforcement 2) Token Efficiency Benchmark: Compare AaaS-AN against ChatDev on code generation to validate token reduction claims 3) Route Switching Test: Submit task requiring HARD→EXT route transition to test dynamic context handoff

## Open Questions the Paper Calls Out

### Open Question 1
- Question: How can multi-agent systems effectively detect and break "looping execution paths" in long-chain workflows to prevent increased failure rates in long-horizon tasks?
- Basis in paper: Section 4.3.1 notes that "Fail tasks often follow incorrect or even looping execution paths, resulting in a longer chain-flow," and the abstract releases a dataset to facilitate research on this specific challenge
- Why unresolved: The paper identifies the correlation between looped paths and failure but does not propose a mechanism to automatically interrupt or reroute cyclic dependencies during runtime
- What evidence would resolve it: An algorithm capable of real-time cycle detection in the Execution Graph and a strategy for dynamic route re-planning, validated on the released 10,000-workflow dataset

### Open Question 2
- Question: What mechanisms can integrate "long-tail" agent services (low-frequency vertexes) into standard workflows to unlock their value despite rare utilization?
- Basis in paper: Section 4.3.3 identifies a long-tail distribution of vertexes where uncommon services have "minimal impact on task execution performance" in current samples, yet acknowledges their "significant value" due to variety and accumulated volume
- Why unresolved: The current Service Scheduler appears to favor high-frequency or high-success-rate agents, potentially overlooking niche services that lack sufficient statistical prominence
- What evidence would resolve it: A modified service discovery algorithm that actively suggests relevant long-tail services for niche sub-tasks, improving success rates of tasks that fail under standard routing

### Open Question 3
- Question: How can the system autonomously determine optimal timing to convert dynamic "Soft" routes into fixed "Hard" routes to preserve effective collaboration structures without sacrificing adaptability?
- Basis in paper: Section 3.2.3 states that Hard routes "can be encoded... by analyzing the correlation between execution traces," implying a need for a threshold or metric to decide when a dynamic pattern becomes a permanent structural asset
- Why unresolved: The paper defines the route types but leaves the automated transition logic as an implementation detail
- What evidence would resolve it: A defined metric for "collaboration pattern stability" and an ablation study showing performance impact of automated route solidification over time

## Limitations
- Heavy reliance on internal metrics and proprietary implementations limits independent verification
- Service Scheduler's routing algorithms and specific agent prompt templates are not fully disclosed
- Scalability claims lack detailed analysis of coordination overhead or failure rates in large-scale deployments

## Confidence
- **High Confidence:** Architectural design principles (RGPS standardization, Service-Oriented abstraction) are well-founded and align with established software engineering patterns; token efficiency mechanism is theoretically sound
- **Medium Confidence:** Experimental results showing performance improvements are internally consistent but lack open-source implementation details for external validation
- **Low Confidence:** Scalability assertions (100+ services, 10,000 workflows) presented without empirical stress testing or analysis of performance degradation

## Next Checks
1. **Token Efficiency Validation:** Implement controlled experiment comparing AaaS-AN against standard chat-based multi-agent system on identical code generation tasks, measuring actual token consumption per task completion

2. **Routing Robustness Test:** Design benchmark suite with tasks requiring multiple HARD→SOFT→EXT route transitions, measuring success rates and execution paths to test Service Scheduler's dynamic reconfiguration capabilities

3. **Edge Case Context Analysis:** Create adversarial tasks where critical information exists only in historical messages, then measure whether AaaS-AN's context isolation policy degrades performance compared to baselines that retain full conversation history