---
ver: rpa2
title: 'Capturing P: On the Expressive Power and Efficient Evaluation of Boolean Retrieval'
arxiv_id: '2601.18747'
source_url: https://arxiv.org/abs/2601.18747
tags:
- retrieval
- query
- standard
- engine
- boolean
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: Modern information retrieval systems are being pushed to support
  complex neuro-symbolic reasoning tasks, but standard architectures face efficiency
  dilemmas. Iterator-based engines struggle with nested Boolean logic graphs, while
  recursive approaches suffer from prohibitive memory costs when handling broad logical
  exclusions.
---

# Capturing P: On the Expressive Power and Efficient Evaluation of Boolean Retrieval

## Quick Facts
- arXiv ID: 2601.18747
- Source URL: https://arxiv.org/abs/2601.18747
- Reference count: 29
- Primary result: Retrieval Language Lð‘… captures complexity class P and enables efficient evaluation of polynomial-time properties over indexes

## Executive Summary
Modern information retrieval systems face efficiency dilemmas when supporting complex neuro-symbolic reasoning tasks. Standard iterator-based engines struggle with nested Boolean logic graphs, while recursive approaches suffer from prohibitive memory costs when handling broad logical exclusions. This paper introduces a Retrieval Language (Lð‘…) based on Directed Acyclic Graphs (DAGs) that provably captures the complexity class P, demonstrating that retrieval engines can evaluate any polynomial-time property directly over their index.

The proposed ComputePN algorithm achieves this by combining native DAG traversal with a memory-efficient Positive-Negative response mechanism. This eliminates both the Universal Scan penalty of negation and the exponential blowup of tree-based iterators. Stress tests on the MS MARCO corpus demonstrate that while standard engines fail with combinatorial explosion for complex arithmetic constraints, ComputePN executes equivalent logic circuits in 0.8 seconds, validating native DAG evaluation over static tree expansion.

## Method Summary
The paper formalizes a Retrieval Language (Lð‘…) based on Directed Acyclic Graphs (DAGs) and proves it captures the complexity class P. The ComputePN algorithm implements native DAG traversal with a Positive-Negative response mechanism to evaluate polynomial-time properties efficiently. The approach eliminates the Universal Scan penalty of negation and avoids the exponential blowup of tree-based iterators by maintaining memory-efficient state during evaluation.

## Key Results
- ComputePN algorithm achieves 0.8-second execution time for complex arithmetic constraints on MS MARCO corpus
- Native DAG evaluation outperforms standard engines that fail with combinatorial explosion (>10,000 clauses)
- Memory-efficient Positive-Negative response mechanism eliminates Universal Scan penalty and exponential blowup

## Why This Works (Mechanism)
The ComputePN algorithm works by traversing a Directed Acyclic Graph (DAG) representation of Boolean retrieval queries while maintaining a Positive-Negative response mechanism. This approach allows efficient evaluation of polynomial-time properties by avoiding redundant computations and memory-intensive operations that plague traditional iterator-based and recursive approaches.

## Foundational Learning
- Directed Acyclic Graphs (DAGs): Directed graphs with no cycles, enabling efficient traversal without infinite loops
  - Why needed: Provides the structural foundation for representing complex Boolean logic without redundancy
  - Quick check: Verify that all query representations are acyclic before evaluation

- Polynomial-time properties: Computable functions that complete in time polynomial to input size
  - Why needed: Establishes the theoretical bound for what retrieval engines can efficiently evaluate
  - Quick check: Confirm that query complexity scales polynomially with input size

- Positive-Negative response mechanism: Dual-state tracking system for handling Boolean operations
  - Why needed: Enables efficient negation without expensive Universal Scan operations
  - Quick check: Validate that negation operations maintain constant-time complexity

## Architecture Onboarding

**Component map:**
Query DAG -> ComputePN Engine -> Index Traversal -> Result Set

**Critical path:**
Query parsing -> DAG construction -> ComputePN traversal -> Index access -> Result aggregation

**Design tradeoffs:**
- Memory efficiency vs. computational complexity
- Native DAG traversal vs. traditional tree expansion
- Positive-Negative mechanism vs. recursive negation

**Failure signatures:**
- Cyclic dependencies in query DAG
- Exponential blowup in query complexity
- Memory exhaustion during traversal

**First 3 experiments to run:**
1. Evaluate simple Boolean queries to verify basic DAG traversal
2. Test negation operations to validate Positive-Negative mechanism
3. Execute arithmetic constraint queries to benchmark performance against standard engines

## Open Questions the Paper Calls Out
None

## Limitations
- Theoretical claims regarding P-completeness require independent verification of reduction construction
- Practical significance depends heavily on assumed cost model for retrieval engines
- Memory-efficiency advantage needs validation across diverse query patterns and index sizes

## Confidence
- P-completeness proof: **Medium** (requires independent verification)
- Memory-efficiency claims: **High** (well-grounded but needs broader validation)
- 0.8s runtime on complex queries: **Low** (single dataset, synthetic workload)

## Next Checks
1. Benchmark ComputePN against recursive approaches on queries with deep nesting and mixed Boolean/arithmetic constraints
2. Test scalability with increasing index size and varying posting list lengths
3. Verify P-completeness reduction with standard complexity theory benchmarks beyond arithmetic properties