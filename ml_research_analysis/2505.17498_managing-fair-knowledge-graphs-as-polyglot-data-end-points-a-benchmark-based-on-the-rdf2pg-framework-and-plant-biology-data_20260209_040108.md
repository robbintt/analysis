---
ver: rpa2
title: 'Managing FAIR Knowledge Graphs as Polyglot Data End Points: A Benchmark based
  on the rdf2pg Framework and Plant Biology Data'
arxiv_id: '2505.17498'
source_url: https://arxiv.org/abs/2505.17498
tags:
- data
- graph
- have
- query
- sparql
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: The paper introduces rdf2pg, an extensible framework for mapping
  RDF data to semantically equivalent labelled property graph (LPG) formats and databases.
  The core idea is to define SPARQL queries that map RDF nodes and relations to LPG
  structures, allowing for customised and domain-aware mappings.
---

# Managing FAIR Knowledge Graphs as Polyglot Data End Points: A Benchmark based on the rdf2pg Framework and Plant Biology Data

## Quick Facts
- arXiv ID: 2505.17498
- Source URL: https://arxiv.org/abs/2505.17498
- Reference count: 40
- Introduces rdf2pg framework for mapping RDF to LPG formats with semantic preservation

## Executive Summary
This paper presents rdf2pg, an extensible framework that enables FAIR (Findable, Accessible, Interoperable, Reusable) knowledge graphs by mapping RDF data to semantically equivalent labelled property graphs (LPGs). The framework uses SPARQL queries to define custom mappings between RDF triples and LPG structures, supporting multiple target formats including Neo4j and GraphML. A benchmark comparing Virtuoso, Neo4j, and ArcadeDB databases using plant biology datasets demonstrates that while Virtuoso excels at RDF data loading, Neo4j generally provides superior query performance across SPARQL, Cypher, and Gremlin languages.

## Method Summary
The rdf2pg framework converts RDF data to LPG formats through user-defined SPARQL queries that extract nodes, node attributes, relations, and relation properties. These queries are executed in parallel batches against a SPARQL endpoint, with results processed by handler classes that build an abstract LPG representation. Target-specific serializers then convert this representation to formats like Cypher CREATE statements for Neo4j or GraphML XML. The benchmark evaluated three graph databases (Virtuoso, Neo4j, ArcadeDB) using plant biology datasets from KnetMiner, comparing loading times and query performance across their respective query languages.

## Key Results
- Neo4j consistently delivered best query performance across all tested workloads
- Virtuoso showed superior loading speed for RDF data compared to Neo4j and ArcadeDB
- All three databases successfully handled the plant biology datasets within reasonable time frames
- The framework enables polyglot access to knowledge graphs while maintaining semantic alignment

## Why This Works (Mechanism)

### Mechanism 1: SPARQL-Based Semantic Mapping
Defining RDF-to-LPG mappings via SPARQL queries enables domain-aware, customizable transformations. Four SPARQL query types select RDF nodes, node attributes, relations, and relation properties. Each query extracts structured data from RDF, which handlers transform into target LPG formats. This allows mapping reified statements to single LPG edges with properties.

### Mechanism 2: Parallel Batch Processing with Handler Abstraction
Batched parallel processing of RDF nodes/relations improves throughput while maintaining extensibility. Node URIs are fetched via SPARQL, batched, and distributed to parallel handler instances. Abstract base handlers fetch details via parameterized queries; concrete implementations serialize to target formats. Relation processing follows the same pattern.

### Mechanism 3: Abstract LPG Intermediate Representation
Decoupling RDF extraction from LPG serialization via an abstract representation enables multi-target extensibility. Handlers first produce an abstract LPG view (nodes with labels/properties, relations with types/properties). Target-specific converters serialize this common representation. Adding new targets requires implementing node/relation handlers for the new format.

## Foundational Learning

- **RDF triple model vs. LPG labelled property graph**: RDF is fine-grained (everything is a triple, reification needed for edge properties) while LPG nodes/edges directly hold attributes. This distinction is essential for designing mappings. *Quick check: Given an RDF reified statement about a relationship with evidence, how would you map it to an LPG edge?*

- **SPARQL query patterns (SELECT, OPTIONAL, FILTER)**: Mappings are defined as SPARQL queries; understanding parameterized queries and graph pattern matching is required to write correct node/relation selectors. *Quick check: Write a SPARQL query that selects all instances of `ex:Gene` and their `rdfs:label` values.*

- **Graph database performance characteristics (loading vs. querying)**: Benchmark results show Virtuoso excels at loading, Neo4j at querying; architectural decisions depend on workload patterns. *Quick check: If your use case requires weekly bulk loads but frequent complex traversals, which database characteristics matter most?*

## Architecture Onboarding

- **Component map**:
  RDF Source (Jena TDB/Virtuoso) -> SPARQL queries -> Batch Selector (node URIs, relation URIs) -> parallel dispatch -> Node Handlers / Relation Handlers (abstract base + target-specific) -> SPARQL parameterized queries for details -> Abstract LPG Representation (in-memory) -> target serialization -> LPG Targets: Neo4j (Cypher CREATE), GraphML (XML), Gremlin-compatible DBs

- **Critical path**:
  1. Define SPARQL mapping queries for your domain schema
  2. Run rdf2pg converter against RDF source
  3. Verify output in target LPG database
  4. Validate semantic equivalence via sample queries

- **Design tradeoffs**:
  - Custom mappings vs. fixed mappings: Custom requires SPARQL expertise but produces more natural LPG structures; fixed mappings are automatic but flatten reification patterns
  - Single-pass vs. multi-pass: Current architecture queries SPARQL per-entity for details; could be optimized for single-pass streaming
  - Information preservation: Not guaranteed; consolidating classes (Car+Vanâ†’Vehicle) loses distinction

- **Failure signatures**:
  - Empty LPG output: SPARQL selectors match nothing (check namespace prefixes, property paths)
  - Missing relations: Relation selector queries fail or endpoint URIs don't match node URIs
  - Slow conversion: SPARQL endpoint overloaded; reduce parallelism or increase batch size
  - Inconsistent counts between RDF and LPG: Mapping queries have filters or optionals that exclude data

- **First 3 experiments**:
  1. Run the provided plant biology benchmark on a small dataset subset; verify query results match across Virtuoso (SPARQL), Neo4j (Cypher), and ArcadeDB (Gremlin)
  2. Define a minimal custom mapping for a new domain (e.g., 2-3 entity types, 2 relation types); trace through the handler pipeline with logging enabled
  3. Measure conversion time with varying batch sizes (100, 1000, 10000 nodes) and parallelism levels (1, 4, 8 threads); identify bottleneck (SPARQL vs. serialization)

## Open Questions the Paper Calls Out

### Open Question 1
How does the performance and mapping expressivity of the rdf2pg framework change when extended to support the emerging GQL graph query language standard? The authors plan to support GQL as a future standard language to query graph databases.

### Open Question 2
How do SQL-like graph query languages compare to SPARQL, Cypher, and Gremlin in terms of qualitative usability and quantitative performance within this specific architecture? The authors want to analyze SQL-like languages and conduct a qualitative and quantitative evaluation.

### Open Question 3
Can the rdf2pg framework be modified to support bi-directional mapping (LPG-to-RDF) through the use of declarative mapping languages rather than procedural SPARQL queries? The current approach is not bi-directional and may need more declarative mapping languages similar to R2RML.

### Open Question 4
Does the adoption of RDF-Star as a target format or input format improve the semantic fidelity of the mapping compared to standard RDF reification? RDF-Star could be both a possible LPG target for rdf2pg or a richer RDF format to support as input.

## Limitations
- Semantic preservation depends entirely on user-defined SPARQL mappings with no automated validation
- Benchmark uses only plant biology datasets, limiting generalizability to other domains
- Framework requires SPARQL endpoint access, potentially creating bottlenecks for very large datasets

## Confidence

- RDF-to-LPG semantic mapping mechanism: **Medium** - Well-documented architecture but lacks empirical validation of semantic preservation
- Parallel batch processing performance: **High** - Clear implementation pattern with predictable scaling behavior
- Cross-database query performance results: **High** - Benchmark methodology is sound, though dataset scope is narrow
- Abstract LPG representation extensibility: **Medium** - Theoretically sound but not tested with diverse LPG targets beyond Neo4j and GraphML

## Next Checks

1. **Semantic Equivalence Testing**: Implement automated comparison of RDF and LPG query results on overlapping subsets to quantify information preservation across diverse schemas.

2. **Performance Scaling Analysis**: Run the conversion pipeline on datasets 10x and 100x larger than the benchmark, measuring SPARQL endpoint load, memory usage, and conversion throughput.

3. **LPG Feature Coverage**: Test conversion of RDF datasets containing complex edge properties, multi-relational patterns, and reification scenarios to identify gaps between the abstract LPG model and target database capabilities.