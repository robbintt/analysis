---
ver: rpa2
title: 'CodeDelegator: Mitigating Context Pollution via Role Separation in Code-as-Action
  Agents'
arxiv_id: '2601.14914'
source_url: https://arxiv.org/abs/2601.14914
tags:
- context
- delegator
- tasks
- coder
- traces
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: The paper identifies context pollution as a major bottleneck in
  code-as-action agents, where debugging traces from earlier sub-tasks dilute task-relevant
  information in shared context, degrading long-horizon performance. To address this,
  the authors propose CodeDelegator, a multi-agent framework that separates strategic
  planning from code implementation through role specialization.
---

# CodeDelegator: Mitigating Context Pollution via Role Separation in Code-as-Action Agents

## Quick Facts
- arXiv ID: 2601.14914
- Source URL: https://arxiv.org/abs/2601.14914
- Authors: Tianxiang Fei, Cheng Chen, Yue Pan, Mao Zheng, Mingyang Song
- Reference count: 17
- Key outcome: Achieves 82.0% pass@1 on retail tasks vs 70.2% for CodeAct, and 38.4% overall success on MCPMark vs 26.4% for CodeAct by separating strategic planning from code implementation

## Executive Summary
CodeDelegator addresses context pollution in code-as-action agents by separating strategic planning from code implementation through role specialization. The framework employs a persistent Delegator for task decomposition and orchestration, and ephemeral Coders for atomic sub-task implementation in isolated contexts. Experiments on τ 2-bench and MCPMark demonstrate substantial improvements over baselines, with the Ephemeral-Persistent State Separation (EPSS) dual-layer workspace architecture preventing debugging traces from diluting task-relevant information.

## Method Summary
CodeDelegator implements role separation through a two-agent architecture: a persistent Delegator handles task decomposition, specification generation, and progress monitoring without executing code; ephemeral Coders implement atomic sub-tasks in isolated sandboxes. The EPSS dual-layer workspace maintains global coherence in an orchestration layer while isolating execution traces in per-Coder execution layers. Structured schemas govern asymmetric communication, preventing both under-specification and context leakage.

## Key Results
- Achieves 82.0% pass@1 on retail tasks compared to 70.2% for CodeAct
- Achieves 38.4% overall success on MCPMark versus 26.4% for CodeAct
- Ablation study shows 4.7% degradation when removing EPSS and structured asymmetric communication

## Why This Works (Mechanism)

### Mechanism 1
- Claim: Role separation between planning and execution mitigates context pollution in long-horizon code-as-action tasks.
- Mechanism: A persistent Delegator handles task decomposition, specification writing, and progress monitoring without executing code. Ephemeral Coders implement atomic sub-tasks in isolated contexts. Debugging traces from Coder instances are discarded upon completion, preventing cross-sub-task pollution.
- Core assumption: Planning requires abstract reasoning while implementation demands fine-grained attention to detail—these compete within fixed context windows.
- Evidence anchors: Abstract and section 4.1 describe the role separation and trace discarding mechanism. CoDA identifies "Context Explosion" as a similar failure mode.
- Break condition: If sub-tasks are highly interdependent requiring frequent replanning with trace visibility, the Delegator may lack sufficient diagnostic information for effective retry decisions.

### Mechanism 2
- Claim: Ephemeral-Persistent State Separation (EPSS) preserves global coherence while isolating execution traces.
- Mechanism: Dual-layer workspace—Orchestration Layer (persistent) stores task specifications, committed artifacts, and progress journals; Execution Layer (ephemeral) provides per-Coder sandboxes with namespace isolation and trace confinement. Only structured results propagate upward.
- Core assumption: Python objects lose fidelity when serialized to text; typed references preserve semantic information more efficiently.
- Evidence anchors: Abstract and section 4.2 describe the dual-layer workspace and artifact storage as objects. HiRA supports hierarchical decomposition patterns.
- Break condition: If artifacts are too large for memory or require cross-Coder mutation, isolated sandboxes may introduce synchronization overhead or stale reference issues.

### Mechanism 3
- Claim: Schema-driven asymmetric communication prevents both under-specification and context leakage.
- Mechanism: Downward specifications (σi) include directive, typed input bindings, and return schema. Upward results (ρi) include status, artifact references, summary, and error diagnostics—but no raw execution traces. Structured schemas enforce information boundaries.
- Core assumption: Natural language handoffs between agents risk information loss (under-specification) or pollution (over-sharing irrelevant details).
- Evidence anchors: Section 4.2 and ablation study show structured schemas replace lossy natural language summaries and cause 4.7% degradation when removed. PACEvolve identifies context pollution as a failure mode.
- Break condition: If error diagnostics (Ei) are insufficiently expressive, the Delegator may misclassify recoverable vs. structural failures, leading to unnecessary replanning or premature termination.

## Foundational Learning

- Concept: **Context window attention dynamics**
  - Why needed here: The paper relies on the premise that later tokens progressively overshadow earlier content, making accumulated debugging traces compete with task-relevant planning information.
  - Quick check question: Can you explain why adding more relevant information to context can paradoxically degrade performance in long-horizon tasks?

- Concept: **Code-as-action paradigm (CodeAct)**
  - Why needed here: CodeDelegator builds on CodeAct's use of executable Python for actions, addressing a specific limitation (context pollution) while preserving expressiveness benefits.
  - Quick check question: What advantages does executable code offer over JSON/structured text for agent actions, and what tradeoffs does it introduce?

- Concept: **Hierarchical task decomposition**
  - Why needed here: The Delegator's effectiveness depends on decomposing tasks into atomic, verifiable sub-tasks with clear completion criteria.
  - Quick check question: Given a task "analyze competitor pricing and generate a report," what makes a good sub-task decomposition versus a poor one?

## Architecture Onboarding

- Component map: Delegator -> Task Decomposition -> Specification Generation -> Progress Assessment (PROCEED/RETRY/REPLAN) -> Coder -> Isolated Sandbox Execution -> Structured Result Return -> Orchestration Layer Update

- Critical path:
  1. Delegator receives task T → decomposes into sub-tasks S
  2. For each sub-task si: generate specification σi → spawn fresh Coder
  3. Coder executes interactive loop (code → observe → refine) until success or budget K exhausted
  4. Coder returns ρi (status, artifacts, summary, diagnostics)
  5. Delegator assesses → PROCEED (commit artifacts), RETRY (refine spec), or REPLAN (re-decompose)

- Design tradeoffs:
  - Sequential vs. parallel sub-tasks: Current implementation is sequential; DAG-structured plans would improve resource utilization but complicate isolation guarantees
  - Trace discarding vs. diagnostic richness: Losing traces may impair retry decisions; the paper accepts this tradeoff based on pilot study showing trace accumulation degrades planning
  - Structured vs. natural language communication: Schemas add overhead but reduce ambiguity (-4.7% without this per ablation)

- Failure signatures:
  - Excessive RETRY loops: Specification may be ambiguous or sub-task insufficiently atomic
  - Premature REPLAN: Error diagnostics (Ei) may misclassify recoverable errors as structural issues
  - Artifacts not found: Input bindings (Ii) may reference wrong Orchestration Layer objects or type mismatches
  - Context still growing: Check that Delegator is not accidentally receiving execution traces (implementation bug in EPSS)

- First 3 experiments:
  1. Reproduce the pilot study (Section 3) on a small subset: run CodeAct on 10 tasks, stratify by difficulty, verify negative correlation between context length and success
  2. Ablation test: Disable EPSS (use natural language handoffs), measure degradation on MCPMark subset—should see ~4.7% drop
  3. Trace isolation validation: Log what the Delegator receives after each Coder completion—confirm no execution traces, only ρi structured results

## Open Questions the Paper Calls Out

- How can CodeDelegator be extended to support Directed Acyclic Graph (DAG) structured plans and asynchronous execution?
- How can the framework better manage transactional semantics to prevent partial failures in stateful environments like databases?
- What is the precise trade-off between the computational overhead of spawning multiple ephemeral Coders versus the performance gains from reduced context pollution?

## Limitations

- Experimental scope limited to specific task domains (retail customer service, MCP service interactions); broader programming tasks remain untested
- Critical implementation details like prompt templates and ISRECOVERABLE logic are underspecified, making faithful reproduction difficult
- Framework assumes effective decomposition into atomic, verifiable sub-tasks; may not benefit tasks requiring tight coupling or frequent replanning

## Confidence

- **High confidence**: Core mechanism of role separation is well-supported by experimental results showing 12% improvement on τ²-bench and 12% on MCPMark
- **Medium confidence**: EPSS dual-layer workspace architecture effectively isolates traces while preserving coherence, though cross-domain robustness needs validation
- **Low confidence**: Specification schema definitions and ISRECOVERABLE logic are critical but underspecified components that could significantly impact effectiveness

## Next Checks

1. **Trace isolation verification**: Instrument the framework to log all data flowing between Delegator and Coder agents. Confirm that no execution traces, debugging outputs, or intermediate code cells reach the Delegator context, validating the core isolation claim.

2. **Specification schema validation**: Test the framework with modified ISRECOVERABLE logic (e.g., more aggressive vs. conservative error classification). Measure impact on RETRY loop frequency and overall task completion rates to assess sensitivity to error handling design.

3. **Cross-domain transferability**: Apply CodeDelegator to a programming benchmark outside the τ²-bench and MCPMark domains (e.g., competitive programming problems or software development tasks). Compare performance against CodeAct and other baselines to evaluate domain generalization.