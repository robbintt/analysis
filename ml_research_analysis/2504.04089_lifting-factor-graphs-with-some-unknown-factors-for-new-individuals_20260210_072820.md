---
ver: rpa2
title: Lifting Factor Graphs with Some Unknown Factors for New Individuals
arxiv_id: '2504.04089'
source_url: https://arxiv.org/abs/2504.04089
tags:
- factors
- unknown
- known
- factor
- sick
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: This paper addresses the problem of performing probabilistic inference
  in factor graphs containing unknown factors, where the underlying potential mappings
  are not fully specified. The proposed LIFAGU algorithm generalizes the ACP algorithm
  to handle unknown factors by exploiting symmetries in the graph structure to transfer
  known potentials to unknown ones, ensuring a well-defined semantics and enabling
  (lifted) probabilistic inference.
---

# Lifting Factor Graphs with Some Unknown Factors for New Individuals

## Quick Facts
- arXiv ID: 2504.04089
- Source URL: https://arxiv.org/abs/2504.04089
- Authors: Malte Luttermann; Ralf Möller; Marcel Gehrke
- Reference count: 7
- Primary result: LIFAGU algorithm generalizes ACP to handle unknown factors by transferring known potentials based on structural indistinguishability, achieving KLDs below 0.01 on synthetic data while enabling significantly faster lifted inference

## Executive Summary
This paper addresses the problem of performing probabilistic inference in factor graphs containing unknown factors, where the underlying potential mappings are not fully specified. The proposed LIFAGU algorithm generalizes the ACP algorithm to handle unknown factors by exploiting symmetries in the graph structure to transfer known potentials to unknown ones, ensuring a well-defined semantics and enabling (lifted) probabilistic inference. LIFAGU identifies indistinguishable 2-step neighborhoods around factors and groups unknown factors with known ones based on pairwise similarity and a user-defined threshold. Background knowledge can further refine these groupings by supporting candidate sets of known factors. Empirical results on synthetic data show that LIFAGU achieves query results very close to the ground truth (KLDs below 0.01) while enabling lifted inference that is significantly faster than standard variable elimination, especially for larger graphs.

## Method Summary
LIFAGU takes as input a factor graph with known and unknown factors, evidence, a threshold θ, and optional background knowledge. It initializes by coloring known factors based on their potentials and assigning unique colors to unknown factors. For each unknown factor, LIFAGU finds possibly identical factors by checking for indistinguishable 2-step neighborhoods (bijective mappings between neighbors with matching properties). It computes the maximal subset of pairwise-identical known factors and transfers potentials if the threshold condition is met. Finally, it calls the ACP algorithm to compress the graph into a Parameterized Factor Graph for lifted inference. The algorithm ensures well-defined semantics by requiring each unknown factor to have at least one possibly identical known factor.

## Key Results
- LIFAGU achieves query results very close to ground truth with KL divergences below 0.01 on synthetic data
- Lifted inference using LIFAGU is significantly faster than standard variable elimination, especially for larger graphs
- The method effectively handles unknown factors by transferring potentials from structurally similar known factors
- Background knowledge can improve accuracy by guiding the grouping of ambiguous unknown factors

## Why This Works (Mechanism)

### Mechanism 1
- Claim: Structural indistinguishability serves as a proxy for functional identity, allowing the transfer of potentials from known to unknown factors
- Mechanism: LIFAGU defines a "2-step neighbourhood" around factors. It compares the local graph structure (neighbour degrees, variable ranges, observed evidence) of an unknown factor $f_i$ against all known factors. If a bijective mapping exists between the neighbours of an unknown factor $f_i$ and a known factor $f_j$ such that their properties match, they are deemed "possibly identical"
- Core assumption: Factors with indistinguishable local graph structures and identical argument ranges encode identical potential mappings (Markov property of factor behaviour)
- Evidence anchors:
  - [section 3, Definition 3.3] Defines "possibly identical" factors based on indistinguishable 2-step neighbourhoods
  - [abstract] Mentions identifying indistinguishable subgraphs to transfer known potentials
  - [corpus] "Approximate Lifted Model Construction" corroborates the use of colour passing for lifted representation but lacks specific validation for the unknown factor transfer heuristic
- Break condition: If an unknown factor's local structure is unique (no bijection found with any known factor), LIFAGU cannot transfer potentials, failing to define the model semantics

### Mechanism 2
- Claim: Lifted inference is enabled by resolving unknown factors into existing symmetric groups (colours)
- Mechanism: The algorithm initializes by colouring known factors by their potentials and unknown factors uniquely. It iteratively passes these colours to neighbours. If an unknown factor accumulates a colour signature matching a group of known factors (surpassing a threshold $\theta$), it inherits their potentials and colour. Finally, the Advanced Colour Passing (ACP) algorithm is invoked on the completed graph to compress it into a Parameterised Factor Graph (PFG)
- Core assumption: The "guessed" potential for the unknown factor is correct, ensuring the resulting PFG maintains the semantic equivalence required for exact lifted inference
- Evidence anchors:
  - [algorithm 1, lines 14-16] Describes the colour assignment and potential transfer before calling ACP
  - [section 3] States LIFAGU generalizes ACP to handle unknowns to ensure well-defined semantics
  - [corpus] Evidence weak; corpus focuses on factor graphs in general (hybrid/contact) rather than the specific "unknown factor" resolution mechanism
- Break condition: If the threshold $\theta$ is set too conservatively (e.g., 1.0) and candidates have slight structural variations, valid transfers are blocked

### Mechanism 3
- Claim: Background knowledge regarding individual membership reduces transfer ambiguity
- Mechanism: If multiple known factors are structurally similar to an unknown factor (ambiguity), LIFAGU checks if the unknown factor belongs to a specific individual (via sets $K_i$). It prioritizes transferring potentials from known factors belonging to a different individual $K_o$ that shares other identical factors with the unknown factor's individual $K_i$
- Core assumption: Objects (individuals) exhibit consistent behaviour across their set of factors; if individual $A$ matches individual $B$ on factors $f_1$ and $f_2$, they likely match on unknown factor $f_3$
- Evidence anchors:
  - [section 4, Definition 4.2] Defines "Supporting Background Knowledge"
  - [section 4] Describes how background knowledge hints at grouping dave and eve
  - [corpus] No direct corpus support for this specific background knowledge heuristic
- Break condition: Conflicting background knowledge or "valid" knowledge that points to the wrong individual (adversarial or noisy grouping) forces incorrect potential transfers

## Foundational Learning

- Concept: **Factor Graphs (FGs) and Semantics**
  - Why needed here: The paper addresses the breakdown of FG semantics when potentials are missing. Understanding that a Joint Distribution $P \propto \prod \phi_j$ requires defined $\phi_j$ is the core motivation
  - Quick check question: Can we perform inference on an FG if one factor $\phi_?$ returns "undefined" for all inputs?

- Concept: **Colour Passing / Weisfeiler-Leman Algorithm**
  - Why needed here: This is the engine of LIFAGU. You must understand how iterative neighbourhood colour aggregation identifies symmetries (isomorphism) to know *how* the algorithm finds "indistinguishable" subgraphs
  - Quick check question: If two nodes start with different colours, can they ever end up with the same colour after one iteration of colour passing?

- Concept: **Lifted Inference (PFGs)**
  - Why needed here: The goal of LIFAGU is not just to fill missing data, but to render the graph *compressible* into a Parameterised Factor Graph for efficiency
  - Quick check question: Why is lifted inference generally faster than standard variable elimination for graphs with repeated substructures?

## Architecture Onboarding

- Component map: Input -> Pre-processor -> Comparator -> Resolver -> Executor
- Critical path: The **Comparator** (Def 3.2/3.3). If the implementation of the neighbourhood check or bijection is inefficient or buggy, the algorithm fails to identify candidates. The logic must correctly handle the "unknown" state during comparison
- Design tradeoffs:
  - **Threshold θ**: A low threshold (e.g., 0) guarantees semantics are defined (if any match exists) but risks high error (KLD) if the match is poor. A high threshold prevents inference (semantics remain undefined) if consensus isn't reached
  - **Neighbourhood Size**: The paper uses a 2-step neighbourhood. Increasing this (e.g., 3-step) increases structural matching accuracy but exponentially increases computational cost
- Failure signatures:
  - **Silent Failure (High Error)**: Low KLD on synthetic data, but real-world data with non-Markovian factor dependencies causes "structural similarity" to pick the wrong potential
  - **Mode Collapse**: If θ is too low and the graph is dense, an unknown factor might be forced into a group with arbitrary potentials just to satisfy the "well-defined semantics" constraint
- First 3 experiments:
  1. **Sanity Check (Theorem 3.3)**: Run LIFAGU on a fully known FG. Verify output is identical to standard ACP (should be identity generalization)
  2. **Stress Test Ambiguity**: Construct an FG where an unknown factor is equidistant (structurally) from two groups with *different* potentials. Vary θ to observe if the algorithm blocks inference or picks a dominant group
  3. **Scalability**: Measure runtime of the "Comparator" component specifically as domain size d increases (as in Fig 9) to verify polynomial time complexity vs. the exponential nature of standard Variable Elimination

## Open Questions the Paper Calls Out

### Open Question 1
- Question: Can LIFAGU be generalised to allow for small deviations between the potentials of known factors during grouping while maintaining a bounded error on probabilistic queries?
- Basis in paper: [explicit] The conclusion states the authors aim to "generalise the ACP algorithm to allow for a small deviation between the potentials of two known factors... while at the same time maintaining a bounded error"
- Why unresolved: The current implementation relies on strict identity (Definition 3.3) to transfer potentials, which prevents the grouping of factors that are similar but not identical
- What evidence would resolve it: An extended algorithm that theoretically defines "similarity" bounds and empirically demonstrates query accuracy remains within those bounds compared to the ground truth

### Open Question 2
- Question: What is the trade-off between inference accuracy and run-time when increasing the neighbourhood size (beyond 2-step) to identify possibly identical factors?
- Basis in paper: [explicit] The evaluation section notes that "error might be further reduced by increasing the effort... for example, it is conceivable to increase the size of the neighbourhood... at the expense of a higher run time"
- Why unresolved: The current algorithm limits the search to a 2-step neighbourhood to ensure polynomial time complexity, but the impact of deeper searches on accuracy is untested
- What evidence would resolve it: An empirical analysis measuring Kullback-Leibler divergence and execution time for LIFAGU using $k$-step neighbourhoods where $k > 2$

### Open Question 3
- Question: How can LIFAGU effectively handle unknown factors when the assumption that "at least one known factor is possibly identical" does not hold?
- Basis in paper: [inferred] The authors acknowledge that assuming the existence of a suitable known group is "clearly a strong assumption that might not hold in practical settings," yet the algorithm currently relies on this for well-defined semantics
- Why unresolved: The paper provides no fallback mechanism or theoretical guarantees for scenarios where an unknown factor has no structural matches among known factors
- What evidence would resolve it: A modification to the algorithm capable of inferring potentials or quantifying uncertainty for structurally unique unknown factors without relying on direct transfer

## Limitations
- The method relies on the strong assumption that each unknown factor has at least one structurally identical known factor, which may not hold in practical settings
- The algorithm's accuracy depends heavily on the quality of background knowledge when available, and performance degrades with noisy or conflicting information
- The 2-step neighbourhood approach limits structural matching accuracy, with no analysis of the trade-off between deeper searches and computational cost

## Confidence
- **High**: LIFAGU correctly generalizes ACP to handle unknown factors and maintains semantic equivalence when at least one structurally identical known factor exists
- **Medium**: Background knowledge effectively resolves transfer ambiguity and improves accuracy
- **Low**: Structural similarity heuristic reliably selects correct potentials in domains with complex dependencies

## Next Checks
1. Test LIFAGU on real-world factor graphs where ground truth potentials are available, measuring KLD and verifying structural similarity doesn't select incorrect potentials
2. Conduct stress tests with ambiguous unknown factors equidistant from multiple candidate groups with different potentials, varying θ to observe inference blocking vs. incorrect grouping
3. Evaluate LIFAGU performance when background knowledge is noisy or adversarial, measuring degradation in KLD and identifying failure thresholds