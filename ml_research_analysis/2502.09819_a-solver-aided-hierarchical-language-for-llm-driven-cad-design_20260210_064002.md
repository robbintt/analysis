---
ver: rpa2
title: A Solver-Aided Hierarchical Language for LLM-Driven CAD Design
arxiv_id: '2502.09819'
source_url: https://arxiv.org/abs/2502.09819
tags:
- constraints
- aidl
- design
- geometry
- constraint
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: The paper introduces AIDL, a solver-aided hierarchical domain specific
  language for LLM-driven CAD design. AIDL addresses the challenge of spatial reasoning
  in CAD generation by offloading constraint solving to an external solver, allowing
  LLMs to focus on high-level design.
---

# A Solver-Aided Hierarchical Language for LLM-Driven CAD Design

## Quick Facts
- arXiv ID: 2502.09819
- Source URL: https://arxiv.org/abs/2502.09819
- Reference count: 30
- Primary result: AIDL outperforms OpenSCAD in CLIP scores (28.90 vs 27.32) and perceptual studies for LLM-driven CAD generation

## Executive Summary
This paper introduces AIDL, a solver-aided hierarchical domain specific language designed to enable large language models to generate Computer-Aided Design (CAD) programs through natural language prompts. The key innovation is offloading spatial reasoning and geometric constraint solving to an external solver, allowing LLMs to focus on high-level design intent rather than coordinate calculations. AIDL supports semantically meaningful references, constraints between parts, and hierarchical structures, demonstrating significant improvements over traditional CAD languages like OpenSCAD when used with LLMs.

## Method Summary
The approach uses GPT-4o to generate AIDL code (a Python-embedded DSL) from natural language prompts. The system employs a "validate-until-correct" loop where generated code is executed, and any errors are fed back to the LLM as tracebacks for up to 5 retries. Valid code is compiled into a hierarchical structure tree, which is then processed by a geometric constraint solver (SolveSpace) using an iterative deepening recursive Newton's method. The resulting geometry is rendered using OpenCascade (OCCT3D) for boolean operations. The evaluation used 36 manually generated prompts and 6 few-shot examples to compare AIDL against OpenSCAD baselines.

## Key Results
- AIDL achieves higher CLIP scores (28.90 vs 27.32) compared to OpenSCAD
- Human perceptual studies show users prefer AIDL-generated designs
- AIDL programs demonstrate superior editability and semantic structure
- Ablation studies confirm both hierarchy and constraints are essential for editability and precision

## Why This Works (Mechanism)

### Mechanism 1: Solver-Aided Spatial Indirection
If LLMs are relieved of calculating absolute geometric coordinates and instead specify high-level relational constraints, output precision improves. The LLM outputs semantic constraints (e.g., "tangent," "coincident") and named references rather than numerical coordinates. A backend geometric constraint solver resolves these relationships into valid geometry, bypassing the LLM's weakness in spatial arithmetic and long-range numerical planning.

### Mechanism 2: Hierarchical Error Reduction via Encapsulation
If the generation task is structured hierarchically, syntax and logic errors are contained within local substructures, preventing total model failure. AIDL enforces a tree-structured "Structure" (Assembly > Solid > Geometry). Constraints and references are validated to ensure they only point to geometry within the same subtree, allowing the system to solve sub-problems recursively.

### Mechanism 3: Semantic Robustness via Synonyms
If the DSL accepts semantically equivalent terms for the same operator, the likelihood of syntax errors decreases. AIDL implements a "robust API vocabulary" where synonymous calls (e.g., `Perpendicular` vs. `Orthogonal`) map to the same internal constraint. This leverages the LLM's semantic strength while mitigating its precision weakness regarding exact token recall from a fixed API list.

## Foundational Learning

- **Concept: Constraint Satisfaction Problems (CSP) in Geometry**
  - Why needed here: AIDL relies on a solver to resolve geometric relationships. You must understand the difference between under-constrained (infinite solutions) and over-constrained (no solutions) systems to debug why an AIDL program might fail to render.
  - Quick check question: If an LLM generates three lines and defines the angle between the first two and the length of the third, is the system fully constrained?

- **Concept: Constructive Solid Geometry (CSG) vs. Boundary Representation (B-Rep)**
  - Why needed here: The paper positions AIDL against CSG (combining primitives via booleans). Understanding that AIDL uses a solver to determine positions *before* performing boolean operations (union/subtract) is key to separating "design intent" from "final geometry."
  - Quick check question: Does AIDL perform boolean operations before or after the constraint solver runs?

- **Concept: Recursive Tree Traversal (Post-Order)**
  - Why needed here: The AIDL solver processes the design tree recursively (children before parents). Understanding this order is necessary to debug why a constraint on a parent assembly might fail to propagate correctly or why a child structure remains fixed.
  - Quick check question: In a post-order traversal used by AIDL, does the solver determine the position of the "wheel" before or after the "car"?

## Architecture Onboarding

- **Component map:** Frontend (LLM) -> Executor/Validator -> Compiler -> Solver Core -> Post-Processor
- **Critical path:** The constraint solving logic. If the solver fails to converge (returns `None`), the pipeline stops. The most common point of failure is the LLM generating logically inconsistent constraints.
- **Design tradeoffs:**
  - References vs. Expressivity: AIDL restricts references to *constructed* geometry (pre-boolean) to avoid "naming problem" ambiguities.
  - Hierarchy vs. Speed: Recursive solving is slower than flat solving but enables editability and localized constraints.
- **Failure signatures:**
  - Detached Geometry: Visual output shows floating parts due to omitted explicit constraints.
  - Hallucinated Constraints: LLM uses undefined operators (e.g., `Rotate`) not covered by the robust vocabulary.
  - Solver Timeout: Complex models with circular dependencies or excessive constraints.
- **First 3 experiments:**
  1. "Hello World" Solvability: Prompt for a simple "L-bracket" and verify the solver successfully places two rectangles at right angles using a `Perpendicular` constraint rather than hard-coded coordinates.
  2. Syntax Robustness Test: Inject code using `Orthogonal` and then `Perpendicular` for the same geometry to confirm the compiler accepts both and outputs identical geometry.
  3. Editability Stress Test: Generate a "hierarchical" phone (base + receiver), programmatically change the `receiver` dimensions, and verify only the receiver updates while the `base` remains stable.

## Open Questions the Paper Calls Out

### Open Question 1
To what extent would fine-tuning LLMs on AIDL code reduce language feature hallucination and improve success rates compared to the few-shot approach? The authors explicitly isolated language design as the primary variable, leaving model training synergies unexplored. A comparative study evaluating the performance of a general-purpose LLM against an LLM fine-tuned on AIDL programs would resolve this.

### Open Question 2
Can the hierarchical solver and constraint system maintain performance and tractability when scaled to complex 3D assemblies? While the language syntax includes 3D frame types, the experiments are restricted to 2D. Benchmarks of AIDL on standard 3D CAD generation datasets would resolve this uncertainty.

### Open Question 3
How can the error feedback loop be improved to preserve design intent when the LLM hallucinates invalid constraints? The current "validate-until-correct" pattern leads to a regression in design complexity rather than a correction of the specific invalid constraint. A new feedback mechanism that suggests valid synonyms or constraints would resolve this.

### Open Question 4
Does the semantic structure of AIDL actually improve user workflow efficiency during post-processing and editing compared to existing languages? The paper claims AIDL creates objects "easier to post-process," but the evaluation relies on CLIP scores and a perceptual study that asked users to "select the best one [rendering]" rather than edit the code. A user study where participants modify generated designs would resolve this.

## Limitations
- The few-shot examples and language description provided to GPT-4o are unspecified, making exact reproduction difficult
- The 36 test prompts and 6 example programs are not publicly available
- The solver's iterative deepening strategy may not converge efficiently for highly complex multi-part designs
- The paper does not demonstrate AIDL's performance on standard 3D CAD generation datasets

## Confidence

- **High Confidence**: The solver-aided mechanism for relieving LLMs of coordinate arithmetic is well-supported by ablation studies and demonstrated improvement over OpenSCAD baselines. The hierarchical structure's contribution to editability is empirically validated.
- **Medium Confidence**: The claim that semantically equivalent synonyms improve LLM robustness is supported by language design but lacks direct quantitative evidence from controlled experiments.
- **Low Confidence**: The generalizability of AIDL's performance across diverse CAD domains and its scalability to highly complex, real-world mechanical assemblies remains unproven.

## Next Checks

1. **Solver Convergence Test**: Generate 50 complex multi-part assemblies (e.g., 10+ interacting components) and measure solver convergence rate and time. Identify if specific constraint patterns cause failures.
2. **Few-Shot Sufficiency Test**: Re-run the LLM generation with only 3 examples (removing 3 from the original 6) and measure the drop in valid program generation rate and CLIP score.
3. **Editability Stress Test**: Create a complex hierarchical model (e.g., a bicycle). Perform 20 sequential, localized edits and measure the proportion of edits that preserve the integrity of unrelated parts, comparing against a flat AIDL model and OpenSCAD.