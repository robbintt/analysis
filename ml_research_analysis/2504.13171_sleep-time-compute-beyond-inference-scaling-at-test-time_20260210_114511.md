---
ver: rpa2
title: 'Sleep-time Compute: Beyond Inference Scaling at Test-time'
arxiv_id: '2504.13171'
source_url: https://arxiv.org/abs/2504.13171
tags:
- compute
- sleep-time
- test-time
- context
- question
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: Sleep-time compute enables large language models to perform reasoning
  about contexts during idle periods before queries arrive, reducing test-time compute
  requirements by up to 5x while maintaining accuracy. The approach was validated
  on modified reasoning benchmarks Stateful GSM-Symbolic and Stateful AIME, where
  sleep-time compute achieved comparable accuracy with significantly fewer test-time
  tokens.
---

# Sleep-time Compute: Beyond Inference Scaling at Test-time

## Quick Facts
- arXiv ID: 2504.13171
- Source URL: https://arxiv.org/abs/2504.13171
- Reference count: 40
- Key result: Reduces test-time compute by up to 5x while maintaining accuracy through pre-computation during idle periods

## Executive Summary
Sleep-time compute is a novel approach that enables large language models to perform reasoning about contexts during idle periods before queries arrive, fundamentally changing how we think about inference scaling. Unlike traditional test-time compute methods that optimize during query processing, this approach leverages downtime to pre-compute context processing, achieving comparable accuracy with significantly fewer test-time tokens. The method has been validated on modified reasoning benchmarks and shows particular promise for multi-query scenarios where context can be amortized across related questions.

## Method Summary
Sleep-time compute introduces a two-phase processing approach where LLMs perform context reasoning during idle periods before queries arrive. The system first processes the context during these "sleep" periods, then uses the pre-computed context to answer queries with reduced test-time compute requirements. This is achieved by modifying reasoning benchmarks to include context processing phases and implementing a scheduling system that balances sleep-time and test-time computation based on predicted query patterns.

## Key Results
- Achieved up to 5x reduction in test-time compute while maintaining accuracy on modified reasoning benchmarks
- Further scaling sleep-time compute improved accuracy by up to 13% on Stateful GSM-Symbolic and 18% on Stateful AIME
- In multi-query settings, reduced average cost per query by 2.5x through amortization of pre-computed context processing
- Demonstrated effectiveness in realistic software engineering tasks

## Why This Works (Mechanism)
Sleep-time compute works by shifting computational burden from the query-response cycle to idle periods, allowing for more thorough context processing without impacting user experience. The approach is particularly effective when queries are predictable from context, as the pre-computed context can be reused across multiple related questions. This amortization effect is especially pronounced in multi-query settings where similar contexts can be processed once and used repeatedly.

## Foundational Learning
- Context prediction modeling - Needed to identify which contexts will likely receive queries; quick check: measure prediction accuracy on real query logs
- Token-level cost analysis - Required to quantify compute savings; quick check: compare token usage before/after implementation
- Multi-query clustering patterns - Essential for understanding amortization opportunities; quick check: analyze query similarity in typical workloads
- Sleep-time scheduling algorithms - Critical for optimal idle period utilization; quick check: measure idle time utilization rates
- Reasoning benchmark modification - Necessary for controlled evaluation; quick check: validate benchmark representativeness
- Context-state tracking - Required for maintaining consistency across sleep and test phases; quick check: verify state preservation across phases

## Architecture Onboarding

Component map: Context Processor -> Sleep-time Scheduler -> Query Predictor -> Test-time Processor

Critical path: Context arrives -> Sleep-time processing begins -> Context predictions made -> Idle periods utilized -> Query arrives -> Pre-computed context retrieved -> Response generated

Design tradeoffs: The system trades increased memory usage for context storage against reduced computational costs during active query processing. There's also a balance between prediction accuracy and computational overhead during the sleep phase.

Failure signatures: Incorrect context predictions lead to wasted sleep-time compute and increased test-time costs. Unexpected query patterns can cause context mismatches requiring fallback to full test-time processing. Timing mismatches between sleep-time completion and query arrival can reduce effectiveness.

First experiments:
1. Measure baseline token usage without sleep-time compute on modified benchmarks
2. Evaluate prediction accuracy of context-to-query mappings on historical data
3. Test sleep-time compute effectiveness across varying idle period durations

## Open Questions the Paper Calls Out
The paper acknowledges that sleep-time compute is most effective when queries are predictable from context, a condition not always present in real-world applications. It also notes that the effectiveness depends heavily on query clustering patterns that may not generalize across different domains.

## Limitations
- Effectiveness depends on query predictability from context, which varies by application domain
- Multi-query cost reduction relies on specific clustering patterns that may not generalize
- Implementation complexity and overhead may vary significantly with context sizes and query arrival patterns
- Limited evaluation on diverse, less predictable real-world query distributions

## Confidence
- High confidence: 5x reduction in test-time compute while maintaining accuracy (validated on benchmarks)
- Medium confidence: 13-18% accuracy improvement from scaling sleep-time compute (depends on benchmark characteristics)
- Medium confidence: Real-world applicability demonstrated through single software engineering task scenario

## Next Checks
1. Test sleep-time compute effectiveness across diverse, less predictable query distributions in production environments to validate generalization beyond benchmark settings.
2. Evaluate performance degradation when sleep-time context predictions are incorrect or when query patterns shift unexpectedly.
3. Measure the practical overhead and implementation complexity in real-world systems with varying context sizes and query arrival patterns.