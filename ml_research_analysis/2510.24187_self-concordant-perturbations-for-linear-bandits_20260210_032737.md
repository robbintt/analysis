---
ver: rpa2
title: Self-Concordant Perturbations for Linear Bandits
arxiv_id: '2510.24187'
source_url: https://arxiv.org/abs/2510.24187
tags:
- self-concordant
- regret
- sc-ftpl
- have
- proposition
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: The paper introduces Self-Concordant FTPL (SC-FTPL), a new algorithm
  for adversarial linear bandits that combines self-concordant regularization with
  FTPL-based sampling. The key innovation is the introduction of self-concordant perturbations,
  probability distributions that replicate the properties of self-concordant barriers
  within an FTPL framework.
---

# Self-Concordant Perturbations for Linear Bandits

## Quick Facts
- arXiv ID: 2510.24187
- Source URL: https://arxiv.org/abs/2510.24187
- Reference count: 0
- Primary result: Achieves O(d√(n lnn)) regret on hypercube and Euclidean ball

## Executive Summary
This paper introduces Self-Concordant FTPL (SC-FTPL), a novel algorithm for adversarial linear bandits that bridges self-concordant regularization and follow-the-perturbed-leader sampling. The key innovation is self-concordant perturbations - probability distributions that mimic self-concordant barrier properties within an FTPL framework. The algorithm achieves O(d√(n lnn)) regret bounds on both the d-dimensional hypercube and Euclidean ball, representing a √d improvement over previous self-concordant FTRL methods on the hypercube while matching existing bounds on the Euclidean ball. The method maintains per-round computational complexity linear in d.

## Method Summary
SC-FTPL combines self-concordant regularization with follow-the-perturbed-leader sampling by introducing self-concordant perturbations - specialized probability distributions that replicate the geometric properties of self-concordant barriers. The algorithm samples from these distributions to create perturbations that, when combined with observed losses, yield an FTPL-style update rule. This approach allows the method to inherit the strong regret guarantees of self-concordant regularization while maintaining the computational efficiency of FTPL. The key insight is that these perturbations can be designed to respect the curvature properties of self-concordant barriers, enabling tighter control of the regret analysis.

## Key Results
- Achieves O(d√(n lnn)) regret on d-dimensional hypercube, improving previous self-concordant FTRL by √d factor
- Matches existing self-concordant FTRL regret bounds on Euclidean ball
- Maintains per-round computational complexity linear in d
- Demonstrates that self-concordant properties can be preserved within FTPL framework

## Why This Works (Mechanism)
The algorithm works by constructing probability distributions whose geometry mimics self-concordant barriers. When these distributions are used to sample perturbations in an FTPL framework, they preserve the curvature properties that make self-concordant regularization effective for regret control. The perturbations effectively linearize the self-concordant barrier locally while maintaining global curvature properties, allowing the FTPL update to approximate the optimal self-concordant FTRL solution. This hybrid approach combines the strong theoretical guarantees of self-concordant methods with the computational simplicity of FTPL.

## Foundational Learning

**Self-concordant barriers** - Convex functions that satisfy a specific curvature condition relating to their Hessian. Needed to ensure strong convexity properties for regret analysis. Quick check: Verify barrier satisfies γ³|H(x)| ≥ |∇²f(x)| for appropriate constant γ.

**Follow-the-Perturbed-Leader (FTPL)** - Algorithm that adds random perturbations to cumulative losses before selecting actions. Needed for computational efficiency. Quick check: Confirm perturbations are independent across rounds.

**Adversarial linear bandits** - Online learning setting where losses are linear functions chosen by adversary. Needed to establish problem context. Quick check: Verify constraint set is known and fixed.

**Regret bounds** - Performance metric comparing algorithm to best fixed action in hindsight. Needed to evaluate algorithm effectiveness. Quick check: Confirm O(d√(n lnn)) scaling is tight up to logarithmic factors.

## Architecture Onboarding

**Component map**: Constraint set → Self-concordant barrier → Self-concordant perturbations → FTPL sampling → Action selection

**Critical path**: The algorithm's performance depends on correctly constructing self-concordant perturbations that preserve barrier properties. The sampling step must be efficient (O(d)) and the perturbations must maintain the required geometric properties throughout execution.

**Design tradeoffs**: Choosing between the hypercube and Euclidean ball constraint sets affects the specific self-concordant barrier construction. The hypercube allows for better regret bounds but may require more complex perturbation sampling. The Euclidean ball offers simpler implementation at the cost of worse regret scaling.

**Failure signatures**: If regret exceeds O(d√(n lnn)), likely causes include incorrect perturbation distribution construction, violation of self-concordant properties, or constraint set mis-specification. Computational complexity exceeding O(d) suggests inefficient sampling implementation.

**First experiments**:
1. Verify O(d) per-round complexity by timing implementation on varying dimensional problems
2. Test regret scaling on synthetic data with known optimal solutions
3. Compare performance against baseline FTPL and self-concordant FTRL on both constraint sets

## Open Questions the Paper Calls Out
None

## Limitations
- Theoretical guarantees rely on specific geometric constraints (hypercube and Euclidean ball)
- Performance in non-stationary or corrupted data regimes remains unvalidated
- Self-concordant properties may not extend to more general constraint sets

## Confidence

**Theoretical regret bounds**: High
**Computational complexity claims**: Medium  
**Generalizability beyond presented constraint sets**: Low
**Practical performance vs. theoretical guarantees**: Low

## Next Checks

1. Implement SC-FTPL and conduct empirical comparisons against existing self-concordant FTRL methods on both hypercube and Euclidean ball domains
2. Extend analysis to verify regret bounds hold for other common constraint sets (e.g., simplex, ℓp balls)
3. Test algorithm robustness to data corruption and non-stationary environments