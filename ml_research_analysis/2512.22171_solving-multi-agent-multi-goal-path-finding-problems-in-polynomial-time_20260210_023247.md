---
ver: rpa2
title: Solving Multi-Agent Multi-Goal Path Finding Problems in Polynomial Time
arxiv_id: '2512.22171'
source_url: https://arxiv.org/abs/2512.22171
tags:
- agents
- time
- agent
- problem
- goal
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: This paper addresses multi-agent multi-goal path finding (CMAPF)
  problems in undirected graphs, where multiple goals must be assigned to agents.
  The key insight is that, unlike traditional vehicle routing which is NP-hard, CMAPF
  can be solved in polynomial time by exploiting the undirected nature of the graph
  and allowing dynamic goal reassignment during execution.
---

# Solving Multi-Agent Multi-Goal Path Finding Problems in Polynomial Time

## Quick Facts
- **arXiv ID:** 2512.22171
- **Source URL:** https://arxiv.org/abs/2512.22171
- **Reference count:** 20
- **Primary result:** CMAPF problems solvable in polynomial time using goal agenda exchange, cuckoo'ing, and local assignment; 50% makespan reduction vs fixed assignment on benchmarks.

## Executive Summary
This paper demonstrates that multi-agent multi-goal path finding (CMAPF) problems on undirected graphs can be solved in polynomial time, contrary to the NP-hard nature of vehicle routing variants. The key insight is exploiting undirected graph structure to allow dynamic goal reassignment during execution rather than fixed pre-assignment. The approach combines shortest-path precomputation, polynomial-time assignment algorithms, and a novel "agents-on-a-graph" simulation that handles conflicts by swapping goal agendas on collisions. For anonymous MAPF, the method achieves 50% reduction in makespan and 90% reduction in sum-of-cost compared to fixed assignment, with conflicts reduced by two orders of magnitude.

## Method Summary
The method precomputes all-pairs shortest paths from goal locations using Dijkstra's algorithm, then solves an initial assignment problem using the Hungarian algorithm variant. During simulation, agents move along precomputed shortest paths while exchanging goal agendas when conflicts occur. Edge conflicts trigger agenda swaps, node conflicts use alternating waits ("zipping"), multi-agent junction conflicts invoke local assignment solving, and blocked goals trigger recursive "cuckoo'ing" where arrived agents are displaced. The dependency graph tracks which agents must wait when others wait, preventing deadlock. For CMAPF, the approach wraps NRPA with bounded rollouts to generate tour assignments, integrating the same conflict resolution mechanisms.

## Key Results
- Solves 500 benchmark instances in under 30 minutes each
- AMAPF: 90% reduction in sum-of-cost and 98% reduction in conflicts vs fixed assignment
- CMAPF: 50% reduction in makespan and 90% reduction in sum-of-cost vs fixed assignment
- Theoretical proof of polynomial-time solvability for both AMAPF and CMAPF variants

## Why This Works (Mechanism)

### Mechanism 1: Goal Agenda Exchange on Collision
- Claim: Exchanging goal agendas when agents collide preserves shortest-path optimality while avoiding physical collision resolution.
- Mechanism: When two agents on precomputed shortest paths meet (edge or node conflict), they swap their goal agendas and associated shortest-path tables rather than bouncing. This is equivalent to agents passing through each other while their "identities" (goal assignments) continue in the original directions.
- Core assumption: Agents are treated as infinitesimally small (point agents) and the graph is undirected with symmetric edge weights.
- Evidence anchors:
  - [abstract] "elaborating on the concept of ants-on-a-stick, by solving local assignment problems, by interleaving agent paths"
  - [section: Solution Principle] "We exploit the solution principle with agents moving on individual shortest path towards their targets, while exchanging goals agendas on every collision"
  - [corpus] Weak direct corpus support; neighboring papers focus on alternative conflict resolution strategies (potential fields, LLM-based assignment).

### Mechanism 2: Cuckoo'ing for Goal Location Displacement
- Claim: Displacing arrived agents from goal locations enables subsequent agents to complete their missions without deadlock.
- Mechanism: When an agent reaches its goal but occupies a location needed by another agent on a shortest path, the arrived agent is "kicked out" and continues with the incoming agent's goal agenda. This propagates recursively along shortest-path chains.
- Core assumption: Goals can be serviced by any agent (anonymous/combinatorial assignment), and agents can resume movement after reaching initial goals.
- Evidence anchors:
  - [abstract] "by kicking agents that have already arrived out of their destinations"
  - [section: Solution Principle, Theorem 1] "If one agent has terminated at its destination and is on the way of some other agent, it is kicked out of it for the incoming agent to take its place (a process that we call cuckoo'ing)"
  - [corpus] No direct corpus evidence; cuckoo'ing appears novel to this approach.

### Mechanism 3: Local Assignment Re-optimization at Junctions
- Claim: Resolving multi-agent junction conflicts via local assignment solving maintains solution quality without global replanning.
- Mechanism: When l > 1 agents simultaneously approach a junction, a local assignment problem is solved in O(l³) time using the Hungarian algorithm variant, optimally reassigning their next goals among them based on shortest-path distances.
- Core assumption: The number of agents meeting at any single junction is bounded by a small constant relative to total agents.
- Evidence anchors:
  - [section: Theorem 1 Proof] "When they are infinitesimally close to j we reassign their goal agendas, with a resolution found by calling the cubic-time assignment problem solver"
  - [section: Polynomial-Time Solutions, Theorem 2] "we have to apply the assignment problem solver locally for all agents participating in the conflict to resolve it in polynomial time"
  - [corpus] Weak support; neighboring papers on decentralized assignment (LLM-based, graph coloring) use different decomposition strategies.

## Foundational Learning

- Concept: **Assignment Problem (Hungarian Algorithm)**
  - Why needed here: Core subroutine for optimally matching k agents to k goals in O(k³) time; used both globally for initial AMAPF assignment and locally for junction conflict resolution.
  - Quick check question: Given a 3×3 cost matrix of agent-to-goal distances, can you trace one iteration of shortest augmenting path selection?

- Concept: **Shortest-Path Precomputation (All-Targets Single-Source)**
  - Why needed here: Agents navigate via precomputed shortest-path tables; Dijkstra from each goal yields O(k(e + n log n)) preprocessing, enabling O(1) next-move lookups during simulation.
  - Quick check question: For a 4-connected grid with uniform edge weights, what algorithm replaces Dijkstra and what is its complexity?

- Concept: **Agent Dependency Graph**
  - Why needed here: Encodes which agents must wait when another waits; propagates delays through the tree to prevent deadlock and ensure progress guarantees.
  - Quick check question: If agent A depends on B which depends on C, and C is forced to wait, which agents must also wait and how is this detected efficiently?

## Architecture Onboarding

- Component map:
  Preprocessor -> Assignment Engine -> Conflict Simulator -> Resolution Handlers (Edge-swap, Node-zip, Cuckoo, Local-assignment)

- Critical path:
  1. Load graph and agent/goal locations → validate connectivity.
  2. Precompute shortest-path tables from all goals (O(k·(e + n log n))).
  3. Compute distance matrix; solve global assignment (cubic in k).
  4. Initialize simulation: positions, orientations, dependency graph.
  5. Per iteration: detect conflicts → resolve via appropriate handler → update positions → repeat until all goals visited.

- Design tradeoffs:
  - **NRPA iterations vs. solution quality**: More rollouts improve tour assignments but increase runtime; paper uses bounded iterations for <30 min solves on benchmarks.
  - **Waiting vs. reassignment**: Aggressive agenda-swapping reduces conflicts but may increase individual agent travel; cuckoo'ing reduces makespan at cost of movement continuity.
  - **Local vs. global optimality**: Polynomial-time guarantee sacrifices global optimality for CMAPF (NP-hard); AMAPF solutions often optimal when conflicts are sparse.

- Failure signatures:
  - **Unsolvable instance spike**: Goals in disconnected components detected in O(n) preprocessing; manifests as immediate termination.
  - **Infinite wait loop**: Breaks if dependency graph has cycles; prevented by alternating which agent waits in repeated conflicts (progress guarantee).
  - **Runtime explosion on dense junctions**: Many agents meeting at single node triggers repeated O(l³) local assignments; threshold on l may be needed.

- First 3 experiments:
  1. **Single-map AMAPF validation**: Run on Boston map (950 agents); compare sum-of-cost, makespan, and conflict count against fixed-assignment MAPF baseline. Verify ~90% sum-of-cost reduction and ~98% conflict reduction reported.
  2. **Conflict-type profiling**: Instrument simulator to count edge-conflicts vs. node-conflicts vs. cuckoo events; validate that agenda-swapping handles majority without invoking local assignment solver.
  3. **CMAPF scalability sweep**: Run on 500 benchmark instances with varying agent/goal ratios; plot runtime distribution and identify unsolvable-instance detection accuracy (should be fast spikes in runtime plot).

## Open Questions the Paper Calls Out

### Open Question 1
- Question: Can the polynomial-time guarantees and "ants-on-a-stick" conflict resolution mechanism be extended to directed graphs?
- Basis in paper: [explicit] The paper cites work showing Regular MAPF on directed graphs is NP-complete (Nebel 2023) and explicitly limits its own polynomial-time proof to undirected graphs $G=(V,E,w)$ where $(u,v) \in E \implies (v,u) \in E$.
- Why unresolved: The collision resolution strategy relies on swapping directions and agendas, which may require reverse traversals that are impossible or computationally hard in directed graphs.
- What evidence would resolve it: A proof of NP-hardness for CMAPF on directed graphs, or a modified algorithm that maintains polynomial time complexity for the directed case.

### Open Question 2
- Question: Can the algorithm retain polynomial-time complexity when extended to strict temporal constraints such as time windows or precedence constraints (pickup and delivery)?
- Basis in paper: [explicit] The conclusion explicitly identifies the extension to "pickup and delivery problem, as well as to constraints on limited resources like time windows" as a future research avenue.
- Why unresolved: The current algorithm uses "cuckooing" (pushing agents out of goals) and delay propagation which may violate hard time constraints, making it unclear if the collision resolution remains tractable.
- What evidence would resolve it: An extended algorithm handling precedence constraints with a complexity analysis, or a proof showing that time windows force the problem into a higher complexity class.

### Open Question 3
- Question: What is the theoretical approximation ratio for the CMAPF solution quality compared to the global optimum?
- Basis in paper: [inferred] The paper states that while the decision problem is in P, the optimization variant of CMAPF is NP-hard. The authors use NRPA to find "optimized" solutions but acknowledge "optimality is not guaranteed" and provide no theoretical bound on the gap.
- Why unresolved: The solution quality depends on the stochastic NRPA search and heuristic local reassignments, which lack formal worst-case guarantees relative to the optimal tour.
- What evidence would resolve it: A theoretical analysis bounding the makespan or sum-of-cost of the generated solution relative to the optimal solution, or a counter-example showing the approximation ratio is unbounded.

## Limitations

- Polynomial-time guarantee assumes undirected graphs with symmetric edge weights and infinitesimal agents, limiting real-world applicability
- NRPA hyperparameters (level, iterations) are unspecified, making solution quality and runtime characterization difficult to reproduce
- Dense junction conflicts could trigger many O(l³) local assignments, potentially creating super-polynomial behavior in practice

## Confidence

- **High confidence**: The AMAPF polynomial-time solvability proof and conflict resolution mechanisms (edge swaps, zipping, cuckoo'ing) are well-specified and reproducible. The reported 90% sum-of-cost reduction and conflict reduction are verifiable through the Boston benchmark.
- **Medium confidence**: The CMAPF NRPA implementation details are insufficient for exact reproduction. While the general framework is clear, the lack of hyperparameter specification and policy initialization details means implementations may produce different tour quality and runtime characteristics.
- **Low confidence**: The theoretical extension from AMAPF to CMAPF polynomial-time solvability isn't fully detailed. The proof relies on NRPA's polynomial runtime but doesn't account for potential exponential behavior in worst-case tour assignment scenarios.

## Next Checks

1. **Dependency graph cycle detection**: Implement cycle detection in the agent dependency graph and verify that the alternating-wait mechanism always breaks potential deadlock loops within bounded steps.

2. **NRPA sensitivity analysis**: Systematically vary NRPA level and iteration parameters on small CMAPF instances to characterize the solution quality-runtime tradeoff curve and identify reasonable default settings.

3. **Directed graph adaptation**: Modify the implementation to handle directed graphs and measure how frequently the conflict resolution mechanisms fail or require significant modifications when edge symmetry assumptions are violated.