---
ver: rpa2
title: 'Social, Legal, Ethical, Empathetic, and Cultural Rules: Compilation and Reasoning
  (Extended Version)'
arxiv_id: '2312.09699'
source_url: https://arxiv.org/abs/2312.09699
tags:
- user
- rules
- sleec
- unless
- curtains
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: We translate social, legal, ethical, empathetic, and cultural rules
  into classical logic, enabling precise semantics and automated reasoning. SLEEC
  rules follow a simple pattern amenable to efficient compilation into propositional
  logic.
---

# Social, Legal, Ethical, Empathetic, and Cultural Rules: Compilation and Reasoning (Extended Version)

## Quick Facts
- arXiv ID: 2312.09699
- Source URL: https://arxiv.org/abs/2312.09699
- Authors: 
- Reference count: 5
- Primary result: Translating SLEEC rules into classical logic enables automated reasoning about obligations in AI systems.

## Executive Summary
This paper addresses the challenge of enabling AI systems to comply with social, legal, ethical, empathetic, and cultural (SLEEC) rules by translating them into classical logic. The authors identify a consistent linguistic pattern in SLEEC rules and provide a systematic compilation method to convert them into propositional formulas. This translation allows for automated reasoning about obligations using SAT solvers and logic programming frameworks (PROLOG, ASP). The approach bridges the gap between natural language norms and executable decision-making in AI systems.

## Method Summary
The method involves three key steps: (1) Disambiguating natural language SLEEC rules and identifying atomic sensing facts and obligations, (2) Compiling the disambiguated rules into classical propositional logic using a systematic translation of the "UNLESS... IN WHICH CASE..." pattern into logical implications, and (3) Implementing the compiled rules in logic programming frameworks (PROLOG or ASP) to enable automated reasoning about obligations based on current world facts.

## Key Results
- SLEEC rules follow a simple linguistic pattern amenable to direct compilation into classical propositional logic
- Entailment is CONP-complete in general but becomes PTIME under restrictions (negative conditions, positive obligations)
- Demonstrated reasoning via SAT and logic programming (ASP, PROLOG), enabling seamless integration into AI systems

## Why This Works (Mechanism)

### Mechanism 1
- Claim: Translating SLEEC rules into classical logic preserves their intended meaning while enabling automated reasoning.
- Mechanism: The linguistic analysis of the SLEEC rule pattern justifies a direct translation of "UNLESS" as logical implication (¬ψ → ϕ), and the full construction "UNLESS... IN WHICH CASE..." as a conjunction of implications. This allows natural language rules to be compiled into propositional formulas without losing semantic content.
- Core assumption: The SLEEC rules follow a consistent syntactic pattern that can be captured by a small set of logical operators and connectives.
- Evidence anchors:
  - [abstract] "We translate social, legal, ethical, empathetic, and cultural rules into classical logic, enabling precise semantics and automated reasoning."
  - [section] Section 3.2 and 3.3 define the logical form of "UNLESS" and "UNLESS... IN WHICH CASE..." and show how they compile into classical logic.
  - [corpus] Weak evidence; no direct corpus examples of this specific compilation, but related work exists on formal rule validation.
- Break condition: If SLEEC rules deviate from the identified pattern (e.g., nesting of UNLESS clauses, or mixed logical connectives not covered), the compilation would fail or require additional rules.

### Mechanism 2
- Claim: Using logic programming frameworks (PROLOG, ASP) allows direct implementation of SLEEC rules and automated reasoning about obligations.
- Mechanism: Once compiled, SLEEC rules can be encoded as clauses in PROLOG or ASP, where facts about the world are asserted and queries about obligations are answered by the inference engine. This bridges the gap between natural language norms and executable decision-making.
- Core assumption: The logical form of SLEEC rules after compilation is compatible with the clause-based reasoning of logic programming languages.
- Evidence anchors:
  - [abstract] "We demonstrate reasoning via SAT and logic programming (ASP, PROLOG), enabling seamless integration into AI systems."
  - [section] Section 7.2 and 7.3 provide working ASP and PROLOG encodings of Example 1 and show how obligations are inferred.
  - [corpus] Weak evidence; the corpus neighbors discuss normative requirements but do not validate this specific implementation approach.
- Break condition: If the compiled rules require disjunctions or complex combinations that logic programming cannot handle efficiently, the implementation may become impractical or incorrect.

### Mechanism 3
- Claim: The computational complexity of reasoning about SLEEC rules is manageable under certain restrictions, making them feasible for real-time AI systems.
- Mechanism: The paper shows that entailment is CONP-complete in general, but becomes PTIME under restrictions where conditions are negative literals and obligations are positive literals. This allows efficient reasoning in constrained but practical scenarios.
- Core assumption: Many real-world SLEEC rules can be structured to fit the restricted form (negative conditions, positive obligations), enabling efficient reasoning.
- Evidence anchors:
  - [abstract] "Entailment is CONP-complete, but practical in PTIME under restrictions."
  - [section] Proposition 1 and 2 formally analyze complexity and show PTIME reasoning is possible under the stated restrictions.
  - [corpus] No direct corpus support; complexity analysis is novel to this paper.
- Break condition: If real-world rules frequently violate the restriction (e.g., require disjunctions in conditions or obligations), the PTIME reasoning guarantee no longer holds, potentially making the approach infeasible for large rule sets.

## Foundational Learning

- Concept: Propositional logic and logical connectives (implication, conjunction, disjunction, negation)
  - Why needed here: The entire compilation process relies on translating natural language rules into propositional formulas using these connectives.
  - Quick check question: How would you write "A UNLESS B" in propositional logic using only →, ∧, ∨, and ¬?

- Concept: Logic programming (PROLOG, ASP) and inference mechanisms
  - Why needed here: After compilation, rules must be implemented in a reasoning engine; understanding how these languages work is essential to encode and query obligations.
  - Quick check question: Given a PROLOG rule `o(X) :- a(X), d(X).`, what does the query `o(user).` return if `a(user).` and `d(user).` are facts?

- Concept: Computational complexity classes (P, NP, CONP) and satisfiability problems
  - Why needed here: To understand the feasibility of reasoning with large sets of SLEEC rules and under what conditions efficient reasoning is possible.
  - Quick check question: What is the complexity class of HORNSAT, and why is it relevant to the PTIME result in Proposition 2?

## Architecture Onboarding

- Component map:
  - Rule Elicitation Module -> Disambiguation Layer -> Compilation Engine -> Logic Programming Interface -> Reasoning Engine -> Robot Development Platform

- Critical path:
  1. User provides SLEEC rule in natural language
  2. Rule is disambiguated and mapped to logical variables
  3. Compilation engine produces propositional formula
  4. Formula is encoded in PROLOG/ASP with current world facts
  5. Reasoning engine answers obligation queries
  6. Results are passed to robot's planning module

- Design tradeoffs:
  - Expressiveness vs. Efficiency: More complex SLEEC rules increase expressiveness but may push reasoning into CONP-hard territory, making real-time reasoning infeasible.
  - Natural Language Ambiguity vs. Precision: Disambiguation is manual and error-prone; ambiguous rules may compile incorrectly, leading to wrong obligations.
  - PROLOG vs. ASP: PROLOG is more intuitive for rule encoding but may lack some ASP features (e.g., stable model semantics); ASP may be more powerful but harder to integrate with existing robot platforms.

- Failure signatures:
  - Compilation fails: Indicates rule pattern not covered by current compilation scheme (e.g., nested UNLESS clauses).
  - Reasoning engine times out: Suggests rule set is too large or complex for efficient reasoning; may need restriction to PTIME form.
  - Incorrect obligations inferred: Likely due to disambiguation errors or incorrect mapping of natural language statements to logical variables.

- First 3 experiments:
  1. Encode Example 1 (curtains rule) in PROLOG and verify obligations for all combinations of user being dressed/undressed and distressed/not distressed.
  2. Test compilation of a rule with a disjunction in the condition (e.g., "IF user is dressed OR user is distressed THEN...") and check if reasoning still works.
  3. Create a large set of simple SLEEC rules (all conditions negative literals, all obligations positive literals) and measure reasoning time to confirm PTIME behavior.

## Open Questions the Paper Calls Out

### Open Question 1
- Question: What are the computational complexity implications when SLEEC rules include complex obligations beyond simple literals, such as disjunctions or nested conditions?
- Basis in paper: [inferred] The paper discusses that using complex Oi (obligations) like n ∧ s does not impact computational complexity, but does not explore more intricate cases.
- Why unresolved: The paper only briefly mentions the use of complex obligations without delving into the computational complexity of more complex logical structures within obligations.
- What evidence would resolve it: Detailed analysis or experiments showing the impact of complex logical structures within obligations on computational complexity.

### Open Question 2
- Question: How does the integration of SLEEC rules into AI systems handle real-time dynamic environments where conditions and obligations can change rapidly?
- Basis in paper: [inferred] The paper discusses the translation of SLEEC rules into classical logic for automated reasoning but does not address real-time dynamic environments.
- Why unresolved: The paper focuses on the logical compilation and reasoning aspects but does not explore the challenges of applying these rules in rapidly changing environments.
- What evidence would resolve it: Case studies or simulations demonstrating the performance of SLEEC-compliant AI systems in dynamic environments.

### Open Question 3
- Question: What are the potential ethical implications of automating decision-making based on SLEEC rules, and how can these be mitigated?
- Basis in paper: [explicit] The paper mentions that ethical considerations are made during the elicitation phase but does not explore the ethical implications of automated decision-making.
- Why unresolved: The paper acknowledges the importance of ethical considerations but does not provide a detailed discussion on the potential ethical implications of automated decision-making based on SLEEC rules.
- What evidence would resolve it: Ethical reviews or frameworks specifically addressing the implications of automated decision-making using SLEEC rules.

## Limitations
- The compilation approach relies on a consistent syntactic pattern for SLEEC rules, which may not hold for real-world rule variations.
- Complexity analysis shows PTIME reasoning under restrictions, but there is limited empirical validation with large rule sets.
- The disambiguation process is manual and error-prone, potentially leading to incorrect mapping of natural language statements to logical variables.

## Confidence
- **High Confidence**: The logical translation of the core SLEEC pattern ("UNLESS... IN WHICH CASE...") into classical logic is well-defined and the mechanism is clearly specified with formal definitions.
- **Medium Confidence**: The implementation using PROLOG and ASP is demonstrated with working examples, but the approach's scalability and robustness with larger, more complex rule sets is not empirically validated.
- **Low Confidence**: The claim about practical feasibility relies on the assumption that real-world SLEEC rules can be structured to fit the PTIME restriction, but this is not substantiated with empirical evidence from actual rule corpora.

## Next Checks
1. Test the compilation scheme with SLEEC rules that include nested UNLESS clauses and disjunctions in conditions to verify the approach handles realistic variations.
2. Measure reasoning time with a large set (100+) of simple SLEEC rules to confirm the PTIME complexity holds in practice and identify performance bottlenecks.
3. Implement an automated disambiguation system and validate its accuracy by comparing automatically generated logical terms against manually verified ground truth for a diverse set of SLEEC rules.