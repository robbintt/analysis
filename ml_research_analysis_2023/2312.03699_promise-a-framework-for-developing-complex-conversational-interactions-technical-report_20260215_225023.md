---
ver: rpa2
title: 'PROMISE: A Framework for Developing Complex Conversational Interactions (Technical
  Report)'
arxiv_id: '2312.03699'
source_url: https://arxiv.org/abs/2312.03699
tags:
- state
- prompt
- interaction
- patient
- promise
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: The paper introduces PROMISE, a framework for developing complex
  conversational interactions with language models. The core idea is to use state
  machine modeling to segment interactions into more specific tasks, improving control
  and predictability.
---

# PROMISE: A Framework for Developing Complex Conversational Interactions (Technical Report)

## Quick Facts
- arXiv ID: 2312.03699
- Source URL: https://arxiv.org/abs/2312.03699
- Reference count: 20
- Primary result: PROMISE is a framework that uses state machine modeling to improve control and predictability of language models in complex conversational interactions, particularly in healthcare applications.

## Executive Summary
PROMISE is a framework for developing complex conversational interactions with language models using state machine modeling concepts. The framework enables hierarchical nesting of states and transitions, allowing for multi-layered conversations that would be difficult to achieve with existing approaches. PROMISE was successfully applied to create interactions in health information systems, including patient coaching and physician training simulations, demonstrating its ability to handle complex, nested interactions through dynamic prompt orchestration.

## Method Summary
PROMISE implements state machine modeling to structure conversational interactions, breaking down complex dialogues into discrete states and transitions with associated prompts. The framework supports hierarchical nesting, allowing outer states to contain inner states for multi-layered conversations. It includes ready-to-use front-ends for testing and management, along with a REST API for integration with other systems. The approach improves language model control by reducing individual prompt complexity while maintaining overall conversation coherence through prompt composition across states.

## Key Results
- Demonstrated successful application of PROMISE in healthcare scenarios including patient coaching and physician training simulations
- Showed ability to handle complex, nested interactions through hierarchical state nesting
- Provided practical implementation examples using both Python and Java versions of the framework

## Why This Works (Mechanism)

### Mechanism 1
- Claim: PROMISE improves control of language models by segmenting complex interactions into more specific tasks.
- Mechanism: State machine modeling breaks down complex conversations into discrete states and transitions, each with its own prompt, reducing complexity and improving predictability.
- Core assumption: Smaller, more focused prompts lead to more reliable and controllable language model outputs.
- Evidence anchors: [abstract] "Its use of state machine modeling concepts enables model-driven, dynamic prompt orchestration across hierarchically nested states and transitions. This improves the control of the behavior of language models and thus enables their effective and efficient use."

### Mechanism 2
- Claim: PROMISE supports multi-layered conversations through hierarchical nesting of states and transitions.
- Mechanism: Outer states contain inner states, allowing different conversation levels to occur simultaneously while maintaining overall coherence through prompt composition.
- Core assumption: Hierarchical state structures can effectively manage complex, nested conversational flows.
- Evidence anchors: [abstract] "Its use of state machine modeling concepts enables model-driven, dynamic prompt orchestration across hierarchically nested states and transitions."

### Mechanism 3
- Claim: PROMISE provides ready-to-use front-ends and a REST API for easy integration and experimentation.
- Mechanism: The framework includes web-based front-ends for testing and management, along with documented REST API endpoints for creating, retrieving, and deleting state machines.
- Core assumption: Providing comprehensive tooling accelerates adoption and reduces development barriers.
- Evidence anchors: [section] "The Java version of PROMISE includes a set of ready-to-use front-ends that support experiments."

## Foundational Learning

- Concept: State Machine Modeling
  - Why needed here: PROMISE is built on state machine concepts to structure complex interactions, making this understanding crucial for designing and implementing interactions within the framework.
  - Quick check question: What are the key components of a state machine, and how do they apply to conversational interactions?

- Concept: Prompt Engineering
  - Why needed here: PROMISE uses prompt engineering techniques to control language model behavior within each state and transition, requiring familiarity with prompt engineering strategies for effective use.
  - Quick check question: How does prompt engineering differ from traditional fine-tuning, and what are the benefits and limitations of each approach?

- Concept: REST API Design
  - Why needed here: PROMISE provides a REST API for integration with other systems, necessitating understanding of REST principles and API design for effective integration and extension.
  - Quick check question: What are the key considerations when designing a REST API for a framework like PROMISE, and how do they impact usability and performance?

## Architecture Onboarding

- Component map: State -> Transition -> Agent -> Storage -> Front-ends -> REST API
- Critical path:
  1. Design state machine model using the framework's concepts
  2. Implement the model using the provided classes and methods
  3. Test the interaction using the front-end interface
  4. Integrate with other systems using the REST API if needed
- Design tradeoffs:
  - Simplicity vs. Flexibility: State machine approach provides structure but may limit free-form conversations
  - Prompt Complexity: Breaking down interactions improves control but requires more orchestration
  - Tooling vs. Customization: Ready-to-use front-ends accelerate development but may not fit all use cases
- Failure signatures:
  - Unresponsive states: Check transitions and their conditions
  - Inconsistent behavior: Review prompts for clarity and specificity
  - Integration issues: Verify request format and endpoint paths
- First 3 experiments:
  1. Create a simple state machine with one state and one transition. Test using the front-end.
  2. Implement a multi-state interaction with nested states. Verify flow using conversation view.
  3. Integrate the state machine with an external service using the REST API. Test end-to-end functionality.

## Open Questions the Paper Calls Out

### Open Question 1
- Question: How does PROMISE's performance compare to frameworks like LangChain when handling complex, nested interactions in real-world applications?
- Basis in paper: [inferred] The paper claims PROMISE can handle complex, nested interactions better than existing frameworks like LangChain, but lacks quantitative performance comparisons or real-world application results.
- Why unresolved: The paper describes capabilities but lacks empirical data comparing performance to other frameworks in actual use cases.
- What evidence would resolve it: Comparative studies measuring PROMISE's performance against LangChain or similar frameworks in terms of accuracy, efficiency, and user satisfaction in real-world applications involving complex, nested interactions.

### Open Question 2
- Question: What are the long-term effects of using PROMISE-based interactions on patient outcomes and physician-patient relationships in healthcare settings?
- Basis in paper: [explicit] The paper mentions potential healthcare applications but does not discuss long-term effects or outcomes.
- Why unresolved: While demonstrating ability to handle complex interactions, the paper doesn't explore impact on patient health outcomes or physician-patient relationship quality over time.
- What evidence would resolve it: Longitudinal studies tracking patient health outcomes and physician-patient relationship quality in healthcare settings using PROMISE-based interactions compared to traditional methods.

### Open Question 3
- Question: How does the complexity of state machine models in PROMISE scale with increasingly complex interactions, and what are the limitations of this approach?
- Basis in paper: [inferred] The paper presents PROMISE as a solution for complex interactions but doesn't discuss scalability of state machine models or potential limitations for extremely complex scenarios.
- Why unresolved: The paper focuses on capabilities but doesn't address how state machine model complexity grows with more intricate interactions or what constraints might exist for very complex situations.
- What evidence would resolve it: Case studies and theoretical analysis examining the relationship between interaction complexity and state machine model complexity, along with identifying practical limitations or bottlenecks in applying PROMISE to extremely complex interactions.

## Limitations

- Lack of quantitative performance metrics or controlled experiments demonstrating effectiveness compared to baseline approaches
- No discussion of debugging challenges or maintenance strategies for complex, multi-layered conversations with deep nesting
- Heavy focus on healthcare applications without validation of effectiveness in other domains

## Confidence

**High Confidence**:
- PROMISE uses state machine modeling concepts to structure conversational interactions
- The framework provides hierarchical nesting of states and transitions
- PROMISE includes ready-to-use front-ends and REST API for integration
- The approach improves control of language model behavior through prompt segmentation

**Medium Confidence**:
- Hierarchical nesting enables multi-layered conversations
- State machine modeling reduces development effort compared to traditional approaches

**Low Confidence**:
- None identified

## Next Checks

1. **Controlled Comparison Study**: Implement the same conversational scenarios using both PROMISE and a baseline prompt engineering approach without state machines. Measure development time, conversation success rates, and language model consistency to quantify the benefits of the state machine structure.

2. **Complexity Stress Test**: Create progressively deeper state nesting scenarios (3+ levels) and document the debugging challenges, performance impacts, and any limitations in state transition management. Identify breaking points where the framework becomes difficult to maintain.

3. **Cross-Domain Application**: Adapt PROMISE to a non-healthcare domain (such as e-commerce customer service or educational tutoring) and document the modifications needed, any domain-specific challenges encountered, and whether the framework's benefits translate to different conversational contexts.