---
ver: rpa2
title: 'XWalk: Random Walk Based Candidate Retrieval for Product Search'
arxiv_id: '2307.12019'
source_url: https://arxiv.org/abs/2307.12019
tags:
- xwalk
- retrieval
- query
- search
- queries
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: XWalk is a random-walk based graph approach to candidate retrieval
  for product search in e-commerce. The method casts search as a query-to-product
  listing recommendation problem, constructing an implicit interaction graph from
  query logs and using random walks to retrieve relevant listings.
---

# XWalk: Random Walk Based Candidate Retrieval for Product Search

## Quick Facts
- arXiv ID: 2307.12019
- Source URL: https://arxiv.org/abs/2307.12019
- Authors: 
- Reference count: 25
- Primary result: XWalk achieves +1.2% conversion rate lift on web and +1.98% on mobile when ensembled with BM25 and neural dense retrieval

## Executive Summary
XWalk is a random-walk based graph approach to candidate retrieval for product search in e-commerce. The method constructs an implicit interaction graph from query logs and uses random walks to retrieve relevant listings. XWalk trains efficiently using only ETL operations and scales to graphs of billions of nodes and tens of billions of edges. When ensembled with BM25 and neural dense retrieval, XWalk substantially improves head query performance and achieves the highest overall retrieval accuracy in both offline and online evaluations.

## Method Summary
XWalk casts search as a query-to-product listing recommendation problem, constructing an undirected, weighted bipartite graph from query logs where nodes represent queries and listings, and edges represent user interactions (clicks, cart adds, purchases). The method uses random walks with Metropolis-Hastings sampling and breadth-first search traversal to retrieve candidate listings for a given query. Edge weights are calculated as a linear combination of interaction counts, with higher coefficients for stronger interactions. The graph inference pipeline is highly efficient, enabling real-time retrieval over massive graphs through optimized data structures (CDFs and Compressed Sparse Row format) and sampling strategies.

## Key Results
- XWalk substantially improves head query performance, which accounts for the majority of sales in e-commerce
- XWalk has the lowest latency retrieval engine with 99th percentile latency at 58% of neural dense retrieval and 22% of Solr inverted index
- Online A/B tests show +1.2% conversion rate increase on web and +1.98% on mobile when XWalk is ensembled with BM25 and neural dense retrieval

## Why This Works (Mechanism)

### Mechanism 1
Random walks on the implicit interaction graph effectively retrieve product listings for head queries because they exploit dense, reliable user feedback signals. The method constructs an undirected, weighted bipartite graph from query logs, where edge weights reflect interaction frequency and strength (clicks, cart adds, purchases). Nodes with higher degrees (popular queries/listings) receive more random walk samples, biasing retrieval toward high-confidence matches. Edge weights accurately reflect listing quality/relevance; high-frequency interactions imply trustworthy relationships.

### Mechanism 2
The graph construction and inference pipeline is highly efficient, enabling real-time retrieval over graphs with billions of nodes and tens of billions of edges. Graph edges are stored as cumulative distribution functions (CDFs) for O(log N) weighted sampling via inverse transform sampling. A breadth-first search traversal reduces cache misses compared to depth-first search. The Metropolis-Hastings algorithm is used for subsequent samples after an initial unbiased sample, reducing computational cost per sample.

### Mechanism 3
XWalk is complementary to traditional retrieval methods (BM25, neural dense retrieval), and their ensemble achieves superior performance across all query frequency bins. XWalk excels in head queries where implicit feedback is abundant, while BM25 handles tail queries with novel or sparse interactions. Neural dense retrieval provides semantic matching for long-tail queries. Reciprocal rank fusion combines results from these methods, leveraging their respective strengths.

## Foundational Learning

- Concept: Graph construction from implicit feedback data
  - Why needed here: XWalk relies on a bipartite graph representing query-listing interactions. Understanding how to construct such a graph from query logs is fundamental to implementing the method.
  - Quick check question: How are edge weights calculated in XWalk's graph construction, and what do they represent?

- Concept: Random walk algorithms and their properties
  - Why needed here: XWalk uses random walks on the constructed graph to retrieve relevant listings. Understanding random walk mechanics, sampling strategies, and traversal algorithms is crucial for efficient implementation.
  - Quick check question: Why does XWalk use breadth-first search instead of depth-first search for random walks, and how does this choice impact performance?

- Concept: Ensemble methods and fusion techniques
  - Why needed here: XWalk's best performance is achieved when combined with other retrieval methods. Understanding ensemble techniques like Reciprocal Rank Fusion and how to effectively combine results from different models is important for realizing the method's full potential.
  - Quick check question: How does Reciprocal Rank Fusion work, and why is it effective for combining results from XWalk, BM25, and neural dense retrieval?

## Architecture Onboarding

- Component map: Data ingestion -> Graph construction (ETL) -> Graph inference (random walks) -> Retrieval ensemble (RRF) -> Evaluation
- Critical path: 1) Construct graph from query logs (ETL) 2) Perform random walks for query to retrieve candidate listings 3) Ensemble XWalk results with BM25 and neural dense retrieval using Reciprocal Rank Fusion 4) Return top-ranked listings to user
- Design tradeoffs: Graph size vs. memory efficiency (CDFs and CSR format); random walk length vs. retrieval quality (latency); ensemble complexity vs. performance
- Failure signatures: Poor recall in tail queries (cold start problem); high latency (cache misses during random walks); inconsistent performance across query bins (suboptimal ensemble weights)
- First 3 experiments: 1) Construct small graph from sample query log and verify edge weights and node degrees 2) Implement basic random walk on small graph and verify retrieval of expected listings 3) Combine XWalk results with BM25 using Reciprocal Rank Fusion on small test set and verify improved recall/MAP

## Open Questions the Paper Calls Out
The paper does not explicitly call out open questions, but raises several implicit research directions including the impact of hyperparameters on performance, scalability limits, and handling of semantically similar but unseen queries.

## Limitations
- Performance sensitivity to edge weight coefficients and Metropolis-Hastings variance parameters
- Difficulty isolating XWalk's individual contribution when ensembled with other methods
- Potential limitations in handling tail and novel queries with insufficient interaction data

## Confidence
- High confidence: Efficiency claims supported by implementation details and offline evaluation
- Medium confidence: Effectiveness for head queries demonstrated through offline metrics and online A/B tests
- Low confidence: Impact of hyperparameters and optimal ensemble configuration not well-established

## Next Checks
1. Conduct hyperparameter sensitivity analysis by varying edge weight coefficients (C1, C2, C3) and Metropolis-Hastings variance (σ²)
2. Perform ensemble ablation study to measure XWalk's individual contribution to overall performance
3. Test XWalk on a different e-commerce dataset to assess generalizability and identify domain-specific requirements