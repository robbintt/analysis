---
ver: rpa2
title: On Grid Graph Reachability and Puzzle Games
arxiv_id: '2310.01378'
source_url: https://arxiv.org/abs/2310.01378
tags:
- reachability
- actions
- encoding
- parallel
- snowball
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: We review existing reachability encodings for graphs and propose
  a new one. Our encoding is well-suited for computing connected components in undirected
  graphs, and we show it performs better than existing encodings when used in parallel
  SAT solving for two hard puzzle games (Sokoban and A Good Snowman is Hard to Build).
---

# On Grid Graph Reachability and Puzzle Games

## Quick Facts
- arXiv ID: 2310.01378
- Source URL: https://arxiv.org/abs/2310.01378
- Reference count: 33
- Key outcome: New spanning tree encoding for undirected graph reachability outperforms existing encodings in parallel SAT solving for Sokoban and A Good Snowman is Hard to Build

## Executive Summary
This paper proposes a new encoding for computing connected components in undirected graphs, specifically designed for use in parallel SAT solving approaches to puzzle games. The key innovation is a spanning tree encoding that computes a tree rooted at the source vertex covering all reachable vertices. This encoding is shown to be more efficient than existing encodings (path and DAG) when used in parallel SAT solving settings for Sokoban and A Good Snowman is Hard to Build, allowing quick upper bound finding on necessary actions followed by sequential refinement to optimal solutions.

## Method Summary
The authors develop three reachability encodings (path, DAG, and spanning tree) for computing connected components in undirected graphs. They implement a planning as SAT approach for Sokoban and Snowman games, incorporating these encodings as constraints. The key contribution is the spanning tree encoding, which forces exactly one path into each reachable vertex except the source, forbids cycles, and propagates unreachability from disconnected components. This encoding is particularly effective in parallel SAT solving settings, where multiple non-interfering actions can be executed simultaneously to quickly find upper bounds on plan length, which are then refined using sequential solving.

## Key Results
- The spanning tree encoding outperforms path and DAG encodings in parallel SAT solving for Sokoban and Snowman games
- Parallel execution with reachability constraints allows finding upper bounds on optimal plan length in fewer timesteps
- The approach successfully solves hard instances of Sokoban and Snowman that are challenging for sequential approaches

## Why This Works (Mechanism)

### Mechanism 1
- Claim: The spanning tree encoding computes a tree rooted at the source vertex that spans all reachable vertices, which is more efficient for undirected graphs.
- Mechanism: The encoding forces exactly one path into each reachable vertex except the source, forbids cycles, and propagates unreachability from disconnected components. This ensures that only the connected component of the source is marked reachable.
- Core assumption: In undirected graphs, the set of vertices reachable from a source is exactly its connected component.
- Evidence anchors:
  - [section] "The encoding is given for undirected graphs without self-loops... Equations (4) and (5) force exactly one path into each reachable vertex, except for s... Equation (6) defines transitivity of paths and forbids cycles. Therefore, Equations (3)-(6) define a tree rooted at s of vertices reachable from s. Moreover, thanks to Equations (1) and (2), that tree will span to all reachable vertices."
  - [abstract] "Our encoding is well-suited for computing connected components in undirected graphs, and we show it performs better than existing encodings when used in parallel SAT solving..."

### Mechanism 2
- Claim: Parallel SAT solving with reachability encodings can quickly find an upper bound on the number of necessary actions.
- Mechanism: By allowing multiple non-interfering actions to execute simultaneously, the solver can find a shorter plan in terms of timesteps. Serializing this parallel plan yields a valid sequential plan whose length is an upper bound on the optimal number of actions.
- Core assumption: Non-interfering actions can be executed in parallel without affecting each other's ability to be serialized into a valid sequential plan.
- Evidence anchors:
  - [section] "Another way to further reduce the search space, as well as to break symmetries, is to consider the execution of several actions in parallel... Thanks to reachability constraints, we are omitting move (walking) actions... avoiding interference between such actions."
  - [abstract] "Using this encoding in a parallel SAT solving approach allows us to quickly find an upper bound on the number of necessary actions, then refine it sequentially to find the optimal solution."

### Mechanism 3
- Claim: The path encoding is compact but cannot be easily adapted for parallel settings unless replicated for every considered path.
- Mechanism: The path encoding builds a single path from source to target, which is efficient for sequential reachability. However, in parallel settings with multiple actions, replicating this encoding for each path leads to a large, symmetric formula.
- Core assumption: The path encoding's simplicity comes from its focus on a single path, which becomes a liability when multiple paths are needed simultaneously.
- Evidence anchors:
  - [section] "The path encoding, although probably being the best-suited for the sequential setting due to its small size, cannot be easily adapted for the parallel case unless it is replicated for every considered path."
  - [section] "We consider the setting with agent movements, and the setting where only snowball movements are considered (where DAG and path denote the used reachability encodings). For Kissat we only report on the path encoding described in Section 2.2, as the other reachability encodings performed very similarly on the same benchmarks."

## Foundational Learning

- Concept: Graph reachability and connected components
  - Why needed here: The encodings rely on correctly determining which vertices are reachable from a source, which is equivalent to finding the connected component in undirected graphs.
  - Quick check question: Given an undirected graph and a source vertex, how would you determine its connected component using a SAT encoding?

- Concept: Planning as SAT and parallel plans
  - Why needed here: The paper uses planning as SAT to encode puzzle game problems, and considers parallel execution of actions to reduce the search space and find upper bounds on optimal plan length.
  - Quick check question: In planning as SAT, how does considering parallel execution of actions help find shorter plans in terms of timesteps?

- Concept: Reachability encodings and their tradeoffs
  - Why needed here: Different encodings (path, DAG, spanning tree) have different strengths and weaknesses in terms of size, adaptability to parallel settings, and ability to compute connected components.
  - Quick check question: What are the key differences between the path, DAG, and spanning tree encodings in terms of their ability to compute connected components in undirected graphs?

## Architecture Onboarding

- Component map:
  - Reachability encodings: path, DAG, spanning tree
  - Puzzle game solvers: SAT-based planning for Snowman and Sokoban
  - Parallel plan serialization: converting parallel plans to sequential plans
  - Search strategy: bottom-up parallel search to find upper bounds, top-down sequential search to refine

- Critical path:
  1. Encode puzzle game problem as SAT formula with reachability constraints
  2. Use parallel SAT solving to find a valid parallel plan with minimal timesteps
  3. Serialize the parallel plan into a sequential plan
  4. Use sequential SAT solving to find shorter plans, until no shorter plan exists

- Design tradeoffs:
  - Sequential vs parallel execution: Parallel execution can find shorter plans in terms of timesteps, but may not directly yield the optimal number of actions. Sequential execution is more direct but can be slower.
  - Reachability encoding choice: The spanning tree encoding is best for undirected graphs and parallel settings, but may be more complex. The path encoding is simpler but not easily adaptable to parallel settings.

- Failure signatures:
  - Parallel plan cannot be serialized: Indicates indirect interference between actions. May need to use a different reachability encoding or restrict parallel execution.
  - Solver times out: May indicate that the problem is too hard for the current encoding or solver. Try a different encoding or parallel setting.

- First 3 experiments:
  1. Implement the spanning tree encoding for a small undirected graph and verify that it correctly computes the connected component of a source vertex.
  2. Encode a simple Sokoban instance using planning as SAT with the path encoding, and solve it using a SAT solver. Compare the solution length with a manual solution.
  3. Modify the Sokoban encoding to allow parallel execution of non-interfering actions, and use a parallel SAT solver to find a parallel plan. Serialize the plan and compare its length with the sequential plan.

## Open Questions the Paper Calls Out

### Open Question 1
- Question: How can the new spanning tree encoding for reachability be optimized further to improve performance on extremely large graphs?
- Basis in paper: [explicit] The paper states the spanning tree encoding is "well-suited for computing connected components in undirected graphs" and performs better than alternatives in parallel SAT solving, but does not explore optimization techniques for large graphs.
- Why unresolved: The paper focuses on demonstrating the encoding's effectiveness on specific puzzle games rather than optimizing it for scalability.
- What evidence would resolve it: Empirical results showing performance comparisons of the spanning tree encoding on graphs of increasing size, along with benchmarks of optimized variants.

### Open Question 2
- Question: Can the path encoding be adapted to maintain its efficiency in the sequential setting while also being suitable for parallel execution without significant overhead?
- Basis in paper: [inferred] The paper notes that the path encoding "cannot be easily adapted for the parallel case unless it is replicated for every considered path," which increases formula size and symmetry.
- Why unresolved: The paper does not propose a solution to this limitation or explore alternative adaptations.
- What evidence would resolve it: A modified path encoding that balances sequential efficiency and parallel suitability, validated through benchmarks on parallel and sequential planning problems.

### Open Question 3
- Question: How does the spanning tree encoding perform in comparison to other reachability encodings on non-grid-based graph problems?
- Basis in paper: [explicit] The paper evaluates the encodings primarily on grid-based puzzle games (Sokoban and Snowman) and mentions the spanning tree encoding is suitable for "undirected graphs," but does not test it on other graph structures.
- Why unresolved: The paper's focus is limited to specific puzzle games, leaving broader applicability unexplored.
- What evidence would resolve it: Experimental results comparing the spanning tree encoding to other encodings on diverse graph problems, such as social networks or transportation networks.

## Limitations

- The spanning tree encoding is specifically designed for undirected graphs without self-loops, and its behavior on directed graphs or graphs with self-loops is not discussed.
- The parallel plan serialization approach relies on the assumption that non-interfering actions can be serialized without affecting each other's reachability, which may not hold in all cases with complex action dependencies.
- The experimental results are based on a specific set of puzzle game benchmarks, and it is unclear how the approach generalizes to other domains or larger problem instances.

## Confidence

- High confidence in the theoretical properties of the spanning tree encoding for undirected graphs.
- Medium confidence in the practical effectiveness of the parallel SAT solving approach, as it is supported by experimental evidence but may have domain-specific limitations.
- Low confidence in the scalability of the approach to larger or more complex domains, as this is not extensively evaluated in the paper.

## Next Checks

1. Implement the spanning tree encoding for a directed graph and analyze its behavior. Identify cases where it fails to correctly compute reachability.
2. Design a set of benchmark problems with complex action dependencies and evaluate the parallel plan serialization approach. Measure the success rate and solution quality.
3. Apply the approach to a larger, real-world planning problem (e.g., robotic manipulation) and assess its scalability and effectiveness compared to state-of-the-art planners.