---
ver: rpa2
title: General Policies, Subgoal Structure, and Planning Width
arxiv_id: '2311.05490'
source_url: https://arxiv.org/abs/2311.05490
tags:
- state
- width
- optimal
- problem
- planning
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: This paper addresses the problem of why many classical planning
  domains with atomic goals have bounded width, which allows them to be solved efficiently
  by algorithms like IW(k). The authors relate bounded width to the existence of general
  optimal policies that can be followed by considering tuples of atoms of bounded
  size.
---

# General Policies, Subgoal Structure, and Planning Width

## Quick Facts
- arXiv ID: 2311.05490
- Source URL: https://arxiv.org/abs/2311.05490
- Reference count: 9
- One-line primary result: Bounded width in planning domains arises from general optimal policies that can be followed by considering tuples of atoms of bounded size

## Executive Summary
This paper investigates why many classical planning domains with atomic goals exhibit bounded width, enabling efficient solution by IW(k) algorithms. The authors establish a theoretical connection between bounded width and the existence of general optimal policies that can be represented by tuples of atoms of bounded size. They introduce the more general notions of serializations and serialized width, and provide a language of sketches to compactly express serializations using rules over features. The paper presents algorithms like IWΦ and SIWR that exploit these structures to solve problems efficiently, and establishes formal connections between width, general policies, and serializations.

## Method Summary
The paper introduces formal definitions of admissibility, width, general policies, envelopes, and serializations. It provides algorithms IW(T), IW(k), and IWΦ that perform width-based search using admissible tuple sets or feature valuations. The methods are based on breadth-first search with pruning, where states are pruned if they don't make progress toward satisfying tuples or features in admissible sets. The paper proves theoretical results connecting these concepts and shows that problems with bounded width can be solved in polynomial time using these approaches.

## Key Results
- Bounded width in planning domains arises from the existence of general optimal policies that can be followed by considering tuples of atoms of bounded size
- Sketches (rule-based serializations) provide a compact way to express problem decompositions into subproblems with bounded width
- IWΦ generalizes IW(T) by tracking feature valuations instead of atom tuples, enabling polynomial-time solutions when feature valuations are exponentially fewer than states
- The paper establishes connections between width, general policies, and serializations, providing a framework for understanding and exploiting the structure of planning problems

## Why This Works (Mechanism)

### Mechanism 1
- Claim: Bounded width in planning domains arises from the existence of general optimal policies that can be followed by considering tuples of atoms of bounded size.
- Mechanism: If a class of planning problems admits a general optimal policy π, and for each problem P in the class there exists a set of atom tuples T such that OP T (T ) forms a closed π-envelope, then the width of P is bounded by size(T ). This allows IW(T ) to find optimal solutions by expanding no more than |T| states.
- Core assumption: The general policy π is optimal and the set T captures enough of the policy's behavior to form a closed envelope without needing to know π explicitly.
- Evidence anchors:
  - [abstract] "The authors relate bounded width with the existence of general optimal policies that in each planning instance are represented by tuples of atoms of bounded size."
  - [section] Theorem 26: "If P is a planning problem in Q, and T is a set of atom tuples in P such that OP T (T ) is a closed π-envelope, then w(P )≤ size(T )."
  - [corpus] Weak: corpus neighbors don't directly discuss bounded width or policy envelopes.
- Break condition: If no set T of bounded size forms a closed envelope for π, then the width is not bounded and IW(T ) may fail to find solutions.

### Mechanism 2
- Claim: Sketches (rule-based serializations) provide a compact way to express problem decompositions into subproblems with bounded width.
- Mechanism: A sketch R defines a serialization ≺ R over states using rules over features. If R is feature-acyclic and the sketch width is bounded, then SIW R can solve problems in polynomial time by greedily solving subproblems. Termination checking via Sieve ensures feature-acyclicity.
- Core assumption: The sketch R correctly captures the subgoal structure of the domain and is feature-acyclic.
- Evidence anchors:
  - [abstract] "The language of general policies and the semantics of serializations are combined to yield a simple, meaningful, and expressive language for specifying serializations in compact form in the form of sketches."
  - [section] Theorem 40: "Let R be a feature-acyclic sketch for a class Q of problems of width bounded by k. SIW R solves any problem P in Q in polynomial time."
  - [corpus] Weak: corpus neighbors don't discuss sketches or serializations.
- Break condition: If R is not feature-acyclic or the sketch width is unbounded, SIW R may fail or run in exponential time.

### Mechanism 3
- Claim: IW Φ generalizes IW(T ) by tracking feature valuations instead of atom tuples, enabling polynomial-time solutions when feature valuations are exponentially fewer than states.
- Mechanism: IW Φ performs a breadth-first search that prunes states whose feature valuation has been seen before. If OP T (F ) is a closed π-envelope for a set F of feature valuations, IW Φ finds an optimal plan. Linear features ensure polynomial complexity.
- Core assumption: The number of distinct feature valuations is polynomially bounded and captures enough information to solve the problem.
- Evidence anchors:
  - [abstract] "The procedure IW(1) is a breadth-first search that prunes all the states that do not make a feature from F true for the first time in the search."
  - [section] Theorem 29: "If OP T (F ) is a cost-envelope, IW Φ finds an optimal plan for P."
  - [corpus] Weak: corpus neighbors don't discuss IW Φ or feature valuations.
- Break condition: If feature valuations repeat too often or don't capture necessary distinctions, IW Φ may prune needed states and fail to find solutions.

## Foundational Learning

- Concept: Admissibility of tuple sets
  - Why needed here: Admissibility is the key property that connects width to solvability. A set T is admissible if it contains a tuple true in the initial state and any optimal plan for a tuple t in T can be extended to an optimal plan for another tuple t' in T by adding one action.
  - Quick check question: What are the two conditions for a set T of tuples to be admissible for a planning problem P?

- Concept: Cost-envelopes and their relation to admissibility
  - Why needed here: Cost-envelopes are sets of states where the optimal cost increases along transitions. They provide a way to characterize admissible sets and connect policies to width bounds.
  - Quick check question: How does Theorem 22 establish the equivalence between admissible sets and cost-envelopes?

- Concept: Rule-based policies and feature valuations
  - Why needed here: Rule-based policies express general policies compactly using features and rules. Understanding how rules define relations on state pairs is crucial for grasping sketches and IW Φ.
  - Quick check question: How does a rule C↦→E define which state transitions are compatible with it?

## Architecture Onboarding

- Component map:
  - IW(T) -> IW(k) -> IWΦ -> SIW R -> Sieve
  - IW(T) uses admissible tuple sets
  - IW(k) uses bounded width
  - IWΦ uses feature valuations
  - SIW R uses sketches (rule-based serializations)
  - Sieve checks termination of rule sets

- Critical path:
  1. Define features and rules for the domain
  2. Check if rules form a terminating sketch using Sieve
  3. Determine sketch width and check if bounded
  4. Apply SIW R to solve problems greedily
  5. Fall back to IW Φ or IW(T) if sketch approach fails

- Design tradeoffs:
  - IW(T) vs IW Φ: IW(T) uses explicit atom tuples but may need exponential memory; IW Φ uses compact feature valuations but may lose information
  - Sketch width vs feature-acyclicity: Tighter width bounds may require less acyclic rules, increasing risk of cycles
  - Rule expressiveness vs termination checking: More expressive rules may be harder to verify for termination

- Failure signatures:
  - IW(T) expands too many nodes: Admissible set T is too large or not truly admissible
  - IW Φ prunes needed states: Feature valuations don't distinguish between states that require different actions
  - SIW R gets stuck in cycles: Sketch is not feature-acyclic or width bound is incorrect
  - Sieve rejects ruleset: Rules create cycles in feature valuation space

- First 3 experiments:
  1. Implement IW(T) for a simple domain (e.g., Grid) with manually constructed admissible tuple sets and verify width bounds
  2. Define features and rules for Delivery domain, check termination with Sieve, and run SIW R
  3. Compare IW Φ vs IW(T) on a domain where feature valuations are exponentially smaller than states (e.g., QClear)

## Open Questions the Paper Calls Out

### Open Question 1
- Question: What is the precise relationship between the width of a problem and the size of the smallest admissible set of atom tuples?
- Basis in paper: [explicit] The paper establishes that the width of a problem P, w(P), is the minimum size of an admissible set of atom tuples T, and that IW( T ) is optimal if T is admissible.
- Why unresolved: The paper does not provide a tight bound on the width of a problem in terms of the size of the smallest admissible set of atom tuples.
- What evidence would resolve it: A formal proof showing that the width of a problem is exactly the size of the smallest admissible set of atom tuples, or a counterexample demonstrating that this is not always the case.

### Open Question 2
- Question: How can we efficiently learn general policies and sketches of bounded width for a given class of problems?
- Basis in paper: [explicit] The paper mentions methods for learning general policies and sketches of bounded width, but does not provide detailed algorithms or complexity analysis.
- Why unresolved: The paper does not provide a concrete algorithm or complexity analysis for learning general policies and sketches of bounded width.
- What evidence would resolve it: An efficient algorithm for learning general policies and sketches of bounded width, along with a proof of its correctness and complexity analysis.

### Open Question 3
- Question: Can the width notion be extended to non-deterministic planning domains while preserving key properties like polynomial-time solvability?
- Basis in paper: [inferred] The paper mentions that the extension of general policies to non-deterministic domains is not yet clear, and that the width notion is for deterministic planning domains.
- Why unresolved: The paper does not provide a formal definition of width for non-deterministic domains or prove that bounded width problems can be solved in polynomial time in such domains.
- What evidence would resolve it: A formal definition of width for non-deterministic domains, a proof that bounded width problems can be solved in polynomial time in such domains, and an algorithm for solving such problems.

## Limitations
- The theoretical framework relies heavily on existence proofs for general optimal policies and admissible tuple sets, but does not provide constructive methods for discovering these structures in novel domains
- The connection between bounded width and policy existence, while formally established, may not hold in domains with complex interaction patterns between subgoals
- The claim that bounded width explains the prevalence of efficiently solvable planning domains requires empirical validation across diverse benchmark suites

## Confidence
- **High confidence**: Theoretical connections between width, general policies, and serializations (Theorems 22, 26, 34, 40) are rigorously proven and internally consistent
- **Medium confidence**: Practical applicability of IWΦ and SIWR algorithms depends on finding appropriate features and sketches, which the paper does not fully address
- **Low confidence**: The claim that bounded width explains the prevalence of efficiently solvable planning domains requires empirical validation across diverse benchmark suites

## Next Checks
1. Implement IWΦ on domains where feature valuations are exponentially fewer than states (like QClear) and verify polynomial-time performance
2. Test Sieve termination checking on various rule sets to establish practical limits of sketch expressiveness
3. Compare SIWR performance against standard IW(k) on benchmark domains to measure practical benefits of the sketch approach