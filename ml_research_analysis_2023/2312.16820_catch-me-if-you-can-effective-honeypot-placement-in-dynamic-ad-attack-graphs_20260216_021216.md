---
ver: rpa2
title: 'Catch Me if You Can: Effective Honeypot Placement in Dynamic AD Attack Graphs'
arxiv_id: '2312.16820'
source_url: https://arxiv.org/abs/2312.16820
tags:
- graph
- graphs
- attacker
- nodes
- node
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: The paper addresses the problem of honeypot placement in large
  and dynamic Active Directory (AD) attack graphs to defend against attackers. The
  core method idea involves formulating the problem as a Stackelberg game and using
  mixed-integer programming (MIP) to solve it.
---

# Catch Me if You Can: Effective Honeypot Placement in Dynamic AD Attack Graphs

## Quick Facts
- arXiv ID: 2312.16820
- Source URL: https://arxiv.org/abs/2312.16820
- Reference count: 40
- Primary result: Proposed algorithms effectively allocate honeypots in large AD graphs, achieving near-optimal results in reducing attacker success rates while scaling to hundreds of thousands of nodes.

## Executive Summary
This paper addresses the critical challenge of placing honeypots in large and dynamic Active Directory (AD) attack graphs to defend against sophisticated attackers. The authors formulate the problem as a Stackelberg game where the defender commits to a blocking plan before the attacker moves, using mixed-integer programming (MIP) to solve for optimal honeypot placement. To handle the dynamic nature of AD graphs with frequently changing HasSession edges, the paper proposes two heuristics - voting-based and clustering-based - that can efficiently find near-optimal solutions without requiring exhaustive enumeration of all possible graph states.

## Method Summary
The core approach involves formulating honeypot placement as a Stackelberg game using MIP, where the defender selects nodes to block (place honeypots) to minimize attacker success probability. For static graphs, a direct MIP formulation handles both simple and competent attacker types through path-counting constraints. For dynamic graphs with changing HasSession edges, the dyMIP(m) approach samples m graph realizations and optimizes a single blocking plan that performs well across all samples. Two heuristics address scalability: voting-based methods use majority voting across batches of graph samples, while clustering-based methods group similar graphs and optimize on representative instances from each cluster.

## Key Results
- The MIP formulation achieves near-optimal blocking strategies with significant reduction in attacker success rates compared to greedy baselines
- Clustering-based heuristic scales to graphs with millions of edges while maintaining solution quality
- dyMIP(m) with appropriate sampling can effectively handle dynamic graphs with up to 137,315 nodes and 1,490,766 edges
- Proposed algorithms outperform existing methods like Zhang et al.'s Double Oracle approach in both solution quality and computational efficiency

## Why This Works (Mechanism)

### Mechanism 1
- Claim: The mixed-integer programming (MIP) formulation can handle both static and dynamic AD graphs by converting the nonlinear path-counting constraints into linear ones via auxiliary variables.
- Mechanism: The nonlinear constraint \( y_B^i = \sum_{j \in n(i)} y_B^j \) is transformed by introducing \( v_i \) and two linear constraints \( y_B^i \leq y_i(1 - B_i) \) and \( y_B^i \geq v_i + y_i \cdot (-B_i) \), allowing Gurobi to solve the problem efficiently.
- Core assumption: The AD graph is acyclic when considering only shortest paths, which allows the path-counting recursion to terminate.
- Evidence anchors:
  - [section]: The path-counting recursion is shown in equations (3a)-(3d) and explained in the context of shortest-path AD graphs.
  - [abstract]: Mentions "mixed-integer programming (MIP) formulation" as the primary method idea.
  - [corpus]: Weak—none of the 8 corpus neighbors discuss the specific MIP transformation or shortest-path recursion.
- Break condition: If the graph contains cycles that affect shortest paths, the linearization may fail and the recursion could be infinite.

### Mechanism 2
- Claim: Dynamic graphs are handled by sampling multiple realizations of HasSession edges and optimizing a single blocking plan that performs well across all samples.
- Mechanism: dyMIP(m) aggregates objective values across m sampled graph instances and solves a single MIP to find a blocking plan that minimizes the average attacker success probability.
- Core assumption: HasSession edges toggle independently and their on/off states can be modeled as random samples without temporal correlation.
- Evidence anchors:
  - [section]: Equation (5) shows the dyMIP(m) formulation that sums over graph instances.
  - [abstract]: States "combining m MIP (dyMIP(m)) instances to produce a near-optimal blocking plan."
  - [corpus]: Weak—no neighbor papers discuss multi-graph optimization or sampling for dynamic AD graphs.
- Break condition: If HasSession edges exhibit strong temporal correlation or bursty patterns, random sampling may not capture the representative behavior.

### Mechanism 3
- Claim: Clustering-based heuristic selects representative graph instances to reduce computational load while maintaining solution quality.
- Mechanism: Each graph is featurized by its attacker success rates under staticMIP, clustered via k-means, and only the closest-to-centroid instance from each cluster is used in dyMIP(m).
- Core assumption: Graphs with similar feature vectors behave similarly under the blocking strategy, so a few representatives suffice.
- Evidence anchors:
  - [section]: Section IV-B2 describes the clustering-based heuristic and its use of k-means.
  - [abstract]: Mentions "clustering algorithm to efficiently find the m-most representative graph instances."
  - [corpus]: Weak—none of the 8 neighbors discuss clustering for graph selection in honeypot placement.
- Break condition: If clusters are highly imbalanced or contain outliers, the representative selection may be biased and degrade performance.

## Foundational Learning

- Concept: Stackelberg game theory
  - Why needed here: The defender commits to a blocking plan first, then the attacker responds; this sequential commitment is the core of the Stackelberg model.
  - Quick check question: In this model, who moves first—the attacker or the defender?

- Concept: Mixed-integer programming (MIP)
  - Why needed here: The problem requires binary decisions (block or not) combined with continuous path-counting, which MIP can handle.
  - Quick check question: What is the key difference between MIP and linear programming in this context?

- Concept: Graph sampling and Monte Carlo simulation
  - Why needed here: Dynamic AD graphs cannot be enumerated exhaustively, so sampling approximates the optimal blocking plan.
  - Quick check question: Why can't we enumerate every possible HasSession configuration for large AD graphs?

## Architecture Onboarding

- Component map: Graph preprocessor -> MIP solver interface -> Sampling engine -> Clustering module -> Evaluation simulator
- Critical path: 1. Load graph → preprocess → staticMIP or dyMIP(m) → blocking plan. 2. For dynamic: sample graphs → (optional) cluster → dyMIP(m) → blocking plan.
- Design tradeoffs: StaticMIP: optimal but only for static graphs. dyMIP(m) with m large: near-optimal but computationally expensive. Clustering heuristic: scalable but potentially less optimal if clusters are poor.
- Failure signatures: Solver timeouts: graph too large or constraints too complex. Suboptimal blocking: sampling bias or insufficient m. Cluster bias: uneven cluster sizes leading to over/under-representation.
- First 3 experiments: 1. Run staticMIP on R2000 with b=10, verify SSR and CSR against GREEDY baselines. 2. Run dyMIP(10) on ADX05 with random sampling, compare SSR to staticMIP baseline. 3. Run clustering-based dyMIP(50) on ADX05, measure speedup vs. full m=50 and solution quality.

## Open Questions the Paper Calls Out

### Open Question 1
- Question: How does the optimal honeypot placement strategy scale with varying budget sizes in dynamic AD attack graphs?
- Basis in paper: [explicit] The paper discusses the computational hardness of the honeypot placement problem and mentions that the problem is NP-hard for static graphs. It also introduces heuristics like voting-based and clustering-based methods to handle large numbers of dynamic graph instances, but does not provide a detailed analysis of how the optimal strategy scales with different budget sizes.
- Why unresolved: The paper does not provide experimental results or theoretical analysis on how the effectiveness of the honeypot placement strategy changes as the budget size varies, especially in dynamic scenarios.
- What evidence would resolve it: Detailed experimental results showing the success rate of attackers under different budget sizes, or theoretical bounds on the effectiveness of the strategy as a function of the budget.

### Open Question 2
- Question: What is the impact of the temporal patterns of HasSession edges on the effectiveness of the honeypot placement strategy?
- Basis in paper: [inferred] The paper mentions that the dynamic nature of AD graphs, particularly due to the on/off HasSession edges, is a significant challenge. It also notes that the temporal patterns of these edges are not assumed in the solutions provided.
- Why unresolved: The paper does not explore how different temporal patterns of HasSession edges (e.g., peak usage times, random vs. correlated patterns) affect the success rate of the honeypot placement strategy.
- What evidence would resolve it: Analysis or simulation results showing the effectiveness of the strategy under various temporal patterns of HasSession edges.

### Open Question 3
- Question: How does the clustering-based heuristic compare to the voting-based heuristic in terms of computational efficiency and effectiveness in large dynamic AD graphs?
- Basis in paper: [explicit] The paper introduces both clustering-based and voting-based heuristics for handling large numbers of dynamic graph instances and claims that the clustering-based heuristic is more scalable.
- Why unresolved: While the paper mentions the scalability of the clustering-based heuristic, it does not provide a direct comparison of the computational efficiency and effectiveness of the two heuristics in large dynamic AD graphs.
- What evidence would resolve it: Comparative experimental results showing the runtime and success rate of both heuristics on large dynamic AD graphs with varying numbers of graph instances.

## Limitations

- The linearization of path-counting constraints depends on the graph being an all-shortest-path DAG, which may not hold for all real-world AD graphs
- The sampling approach for dynamic graphs assumes HasSession edges toggle independently, potentially missing temporal correlations present in real environments
- Critical implementation details for the clustering heuristic (feature extraction method, k-means parameters) are not fully specified

## Confidence

- **High confidence**: The MIP formulation for static graphs and the overall Stackelberg game framework. The evaluation methodology and metric definitions are clearly specified.
- **Medium confidence**: The linearization transformation and the dyMIP(m) formulation. While the mathematical approach is sound, edge cases (cycles, correlated HasSession edges) could affect validity.
- **Low confidence**: The clustering-based heuristic's implementation details and the feature extraction method for graph featurization. These critical steps are not fully specified in the paper.

## Next Checks

1. **Validate the DAG assumption**: Test the linearization approach on graphs with known cycles to confirm the path-counting recursion fails as expected when the all-shortest-path assumption is violated.
2. **Analyze sampling bias**: Run temporal correlation analysis on real HasSession edge data to quantify the independence assumption and measure its impact on dyMIP(m) solution quality.
3. **Cluster quality assessment**: Implement the full clustering pipeline with different k values and distance metrics, then measure how cluster quality correlates with blocking strategy performance.