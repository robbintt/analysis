---
ver: rpa2
title: Towards Ontology-Mediated Planning with OWL DL Ontologies (Extended Version)
arxiv_id: '2308.08200'
source_url: https://arxiv.org/abs/2308.08200
tags:
- planning
- ontology
- which
- stackbot
- specification
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: This work presents a novel framework for ontology-mediated planning
  that integrates OWL ontologies with classical planning specifications while maintaining
  a separation of concerns. The key innovation is a problem-dependent rewriting technique
  that supports full OWL DL expressiveness, unlike existing methods limited to Horn-ALCQI
  or DL-Lite fragments.
---

# Towards Ontology-Mediated Planning with OWL DL Ontologies (Extended Version)

## Quick Facts
- arXiv ID: 2308.08200
- Source URL: https://arxiv.org/abs/2308.08200
- Reference count: 40
- Supports full OWL DL expressiveness through problem-dependent rewriting

## Executive Summary
This work presents a novel framework for ontology-mediated planning that integrates OWL ontologies with classical planning specifications while maintaining a separation of concerns. The key innovation is a problem-dependent rewriting technique that supports full OWL DL expressiveness, unlike existing methods limited to Horn-ALCQI or DL-Lite fragments. The approach uses justifications to generate derivation rules that connect the planning and ontology perspectives through a fluent and query interface. Experimental evaluation on benchmark domains shows that the method can outperform existing techniques on certain planning problems, particularly those with complex ontologies and large state spaces.

## Method Summary
The approach provides a problem-dependent rewriting of ontology-mediated planning problems into classical planning problems. It supports the entire OWL DL fragment and separates the planning and ontology components through fluent and query interfaces. The method computes justifications for OWL axioms relative to the static ontology and generates derivation rules that activate based on planner state atoms. These rules are then combined with the original PDDL specification to create an extended planning problem that can be solved using standard planners like Fast-Downward.

## Key Results
- Solves 21 Pipes domain instances with median compilation time of 10 seconds vs 0.2 seconds for Horn-based methods
- Achieves significantly faster planning times (0.7s vs 5.4s) on successful instances
- Supports full OWL DL expressiveness unlike existing approaches limited to Horn-ALCQI or DL-Lite fragments

## Why This Works (Mechanism)

### Mechanism 1
- Claim: The separation of planning and ontology via fluent/query interfaces allows domain experts to work independently while maintaining formal linkage.
- Mechanism: Fluent interface maps planner predicates to OWL axioms; query interface maps OWL queries to planner predicates through type-restricted variable assignments and justification-based derivation rules.
- Core assumption: OWL perspective can be consistently maintained as an extension of the planner perspective without cyclic dependencies.
- Evidence anchors:
  - [abstract] "Our approach for planning with those ontology-mediated planning problems is optimized for cases with comparatively small domains, and supports the whole OWL DL fragment."
  - [section 3] "The interface itself consists of two parts: the fluent interface, and the query interface."
  - [corpus] Weak - related work focuses on integrated approaches rather than separated interfaces.
- Break condition: If the interface mapping ð¹ becomes non-injective or if type restrictions in query interface allow infinite legal assignments, derivation rule explosion occurs.

### Mechanism 2
- Claim: Data-dependent rewriting using justifications enables full OWL DL support unlike static Horn-ALCQI or DL-Lite approaches.
- Mechanism: For each query predicate, compute all justifications of relevant OWL axioms relative to static ontology; generate derivation rules that activate based on planner state atoms.
- Core assumption: Justification computation terminates in reasonable time and produces finite derivation rules for practical instances.
- Evidence anchors:
  - [abstract] "Different to other approaches, our rewriting is data-dependent."
  - [section 4] "we need to take into account also the planning problem. Specifically, our approach directly iterates over the possible assignments for each query predicate."
  - [corpus] Weak - no direct comparison to justification-based methods in literature.
- Break condition: When ontology contains complex cardinality or disjunction axioms that generate exponentially many justifications relative to domain size.

### Mechanism 3
- Claim: Deriving inconsistent atom allows planner to detect and avoid ontology inconsistencies while still supporting full expressiveness.
- Mechanism: Compute JustâŠ¥ = Just(F âˆª ð’ª, ð’ª, âŠ¥) to identify all fluent combinations that cause inconsistency; add "inconsistent" atom to derivation rules.
- Core assumption: Inconsistent states can be detected before planning actions are executed, preventing invalid state transitions.
- Evidence anchors:
  - [section 5] "We introduce the atom inconsistent, which captures the states in the ontology perspective that are inconsistent."
  - [section 4] "JustâŠ¥ contains all sets of fluents that are inconsistent with the static ontology."
  - [corpus] Weak - inconsistent state handling is not discussed in related approaches.
- Break condition: If reasoning engine cannot compute justifications within time limits, inconsistency detection fails.

## Foundational Learning

- Concept: OWL DL syntax and semantics
  - Why needed here: The entire framework relies on correct translation between planner predicates and OWL axioms
  - Quick check question: Can you explain the difference between OWL class expressions and OWL properties in the context of fluent interface mapping?

- Concept: Description Logic reasoning and justifications
  - Why needed here: Justification computation is the core technique for generating derivation rules
  - Quick check question: What is the difference between classical justifications and relative justifications in this framework?

- Concept: PDDL planning with derived predicates
  - Why needed here: The final planning problem is a standard PDDL problem with generated derivation rules
  - Quick check question: How do derivation rules in PDDL differ from normal actions in terms of when they can be applied?

## Architecture Onboarding

- Component map:
  Input (OWL ontology, PDDL domain/problem, interface specifications) -> Justification computation engine -> Derivation rule generator -> PDDL rewriter -> Extended PDDL -> Fast-Downward planner -> Planning results

- Critical path:
  1. Parse input specifications
  2. Compute justifications for each OWL axiom relative to static ontology
  3. Generate derivation rules for each query predicate
  4. Combine with original PDDL to create extended specification
  5. Execute planning with Fast-Downward
  6. Return plan if found within time/memory limits

- Design tradeoffs:
  - Full OWL DL expressiveness vs. compilation time (justification explosion)
  - Separation of concerns vs. potential interface complexity
  - Data-dependent rewriting vs. domain-independent approaches
  - Support for derived predicates vs. simpler state evaluation

- Failure signatures:
  - Timeout during justification computation (indicates complex ontology axioms)
  - Memory exhaustion during derivation rule generation (indicates large number of justifications)
  - Planner unable to find plan (could indicate incorrect interface specification)
  - Inconsistent planner states (indicates missing inconsistent atom handling)

- First 3 experiments:
  1. Blocksworld domain with simple cardinality constraints - verify basic functionality
  2. Pipes domain with complex pipe/valve relationships - test justification computation scalability
  3. Drones domain from existing literature - compare performance against Horn-based approaches

## Open Questions the Paper Calls Out

### Open Question 1
- Question: Can the compilation time be reduced by optimizing the justification computation process?
- Basis in paper: [inferred] The paper notes that in domains like "Drones," OM had longer compilation times due to many justifications for inconsistencies, leading to a huge increase in compilation time.
- Why unresolved: The paper does not explore optimization techniques for justification computation.
- What evidence would resolve it: Experimental results showing reduced compilation times after implementing optimization techniques for justification computation.

### Open Question 2
- Question: How does the performance of OM compare to eKAB methods on more expressive ontology fragments beyond OWL DL?
- Basis in paper: [inferred] The paper mentions that OM supports the entire OWL DL fragment, but does not compare its performance to eKAB methods on more expressive ontology fragments.
- Why unresolved: The paper does not provide experimental results for ontology fragments more expressive than OWL DL.
- What evidence would resolve it: Experimental results comparing the performance of OM and eKAB methods on ontology fragments more expressive than OWL DL.

### Open Question 3
- Question: Can the separation of concerns between planning and ontology components be maintained while improving the performance on domains where OM is currently not competitive?
- Basis in paper: [explicit] The paper emphasizes the separation of concerns between planning and ontology components, but notes that OM is not competitive on all domains.
- Why unresolved: The paper does not explore techniques to improve performance while maintaining the separation of concerns.
- What evidence would resolve it: Experimental results showing improved performance on domains where OM is currently not competitive, while maintaining the separation of concerns.

## Limitations

- The experimental evaluation uses only three domains with relatively small instance counts
- Performance advantages are demonstrated on specific problem types rather than established as general superiority
- Scalability to larger ontologies and more complex planning problems remains unclear
- The practical limitations of justification explosion are not fully quantified

## Confidence

**High Confidence**: The separation of planning and ontology perspectives through fluent/query interfaces is a sound architectural principle that enables independent domain expert work while maintaining formal linkage.

**Medium Confidence**: The data-dependent rewriting using justifications effectively supports full OWL DL expressiveness, though the practical scalability limits are not fully characterized.

**Medium Confidence**: The performance improvements on complex planning problems (e.g., Pipes domain) are demonstrated but may not generalize to all problem types.

## Next Checks

1. **Scalability Test**: Evaluate the approach on larger ontologies with thousands of axioms and complex cardinality/disjunction constraints to quantify justification explosion and determine practical size limits.

2. **Cross-Domain Performance**: Test the method on additional planning domains beyond the three presented (Blocksworld, Pipes, Drones) to establish whether the performance advantages are domain-specific or generalizable.

3. **Interface Correctness Verification**: Implement formal verification of the fluent and query interface mappings to ensure the separation of concerns doesn't introduce inconsistencies or missing connections between the planning and ontology perspectives.