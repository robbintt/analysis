---
ver: rpa2
title: Causal Laws and Multi-Valued Fluents
arxiv_id: '2307.10227'
source_url: https://arxiv.org/abs/2307.10227
tags:
- action
- causal
- constants
- language
- nite
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: This paper extends the action language C to handle multi-valued
  fluents and action attributes. The extension, called C+, allows fluents to take
  values from arbitrary nonempty sets rather than just Boolean values, and enables
  describing actions via their attributes (e.g., a move action can be represented
  as having attributes like mover, destination, etc.).
---

# Causal Laws and Multi-Valued Fluents

## Quick Facts
- arXiv ID: 2307.10227
- Source URL: https://arxiv.org/abs/2307.10227
- Reference count: 1
- This paper extends the action language C to handle multi-valued fluents and action attributes.

## Executive Summary
This paper introduces an extension of the action language C, called C+, that can handle multi-valued fluents and action attributes. The extension allows constants to have domains from arbitrary nonempty sets rather than just Boolean values, enabling more concise and elaboration-tolerant representations of action domains. The authors show how C+ can be embedded into causal theories with multi-valued constants and demonstrate how to eliminate multi-valued constants in favor of Boolean constants when domains are finite. This work continues the line of research on representing action properties in nonmonotonic formalisms that distinguishes between being true and being caused.

## Method Summary
The paper extends causal logic and the action language C to allow constants with arbitrary nonempty domains. It defines the syntax and semantics of C+ with multi-valued fluents, shows how to embed C+ into causal theories with multi-valued constants, and develops reduction methods to eliminate multi-valued constants in favor of Boolean constants when domains are finite. The method involves defining multi-valued propositional signatures, constructing causal theories, and implementing translation procedures between C+ and other action formalisms like ADL.

## Key Results
- The C+ language enables more concise domain representations by avoiding Boolean decomposition of multi-valued fluents.
- Action descriptions in C+ can be made elaboration tolerant by representing actions via their attributes rather than multi-argument action names.
- Definite causal theories with multi-valued constants can be translated into propositional logic while preserving semantics when domains are finite.

## Why This Works (Mechanism)

### Mechanism 1
- Claim: Multi-valued constants allow more concise domain representations by avoiding Boolean decomposition.
- Mechanism: The paper extends causal logic and language C to allow constants with arbitrary nonempty domains, replacing the need to encode multi-valued fluents as combinations of Boolean ones.
- Core assumption: The domain of each constant is finite, enabling translation to Boolean constants without loss of expressiveness.
- Evidence anchors:
  - [abstract] "This paper continues the line of work on representing properties of actions in nonmonotonic formalisms that stresses the distinction between being ıtrue and being ıcaused..."
  - [section 2] "A (multi-valued propositional) signature is a set of symbols called constants, along with a nonempty set ı Dom(c) of symbols assigned to each constant c."
- Break condition: If the domain is infinite, the elimination method fails and multi-valued representation may not be expressible in Boolean terms.

### Mechanism 2
- Claim: The C+ language enables action descriptions via attributes rather than multi-argument action names.
- Mechanism: Actions are represented as conjunctions of attribute assignments (e.g., M ove(b) ∧ M over(b)=r ∧ Destination(b)=l), making the representation elaboration tolerant.
- Core assumption: Each action attribute maps to a constant whose domain is the set of possible values for that attribute.
- Evidence anchors:
  - [abstract] "Our extension of language C, called C+, also makes it possible to describe actions in terms of their attributes..."
  - [section 4.2] "Take two collections of symbols, ıBoxes and ıLocations. For each b ∈ ıBoxes, ıLoc(b) is a fluent symbol with the domain ıLocations..."
- Break condition: If attribute values are unbounded or change dynamically, the fixed-domain assumption breaks down.

### Mechanism 3
- Claim: Definite causal theories can be translated into propositional logic with multi-valued constants while preserving semantics.
- Mechanism: For each atom A in a definite theory, its completion A ≡ (F1 ∨ ... ∨ Fn) captures all possible causes of A, allowing direct translation to multi-valued propositional logic.
- Core assumption: The theory is definite—no constant has a singleton domain, consequents are atoms or ⊥, and no atom is the consequent of infinitely many laws.
- Evidence anchors:
  - [section 3.3] "A causal theory T is definite if (i) no constant in the signature of T has a singleton domain, (ii) the consequent of every causal law of T is an atom or ⊥ , and (iii) no atom is the consequent of infinitely many causal laws of T."
  - [proposition 1] "The causally explained interpretations according to T are precisely the models of the multi-valued completion of T."
- Break condition: If any of the definiteness conditions fail, the completion may not correctly capture semantics.

## Foundational Learning

- Concept: Causal explanation in nonmonotonic logic
  - Why needed here: The paper builds on causal logic semantics where truth and causation are distinct; understanding this distinction is critical to grasp how multi-valued fluents are handled.
  - Quick check question: In causal logic, what does it mean for an interpretation to be "causally explained" according to a theory?

- Concept: Multi-valued propositional signatures
  - Why needed here: The syntax and semantics of multi-valued constants underpin the entire extension; without this, the mapping to Boolean constants cannot be understood.
  - Quick check question: How does an interpretation of a multi-valued signature differ from a Boolean interpretation?

- Concept: Definite causal theories and completion
  - Why needed here: The preservation of definiteness under translation is central to the correctness of the elimination methods.
  - Quick check question: What conditions must a causal theory satisfy to be considered "definite"?

## Architecture Onboarding

- Component map: Multi-valued signature definitions → syntax for C+ propositions → causal theory embedding → elimination procedures → Boolean translation
- Critical path:
  1. Define signature with multi-valued constants.
  2. Write action description in C+.
  3. Translate to causal theory via embedding.
  4. Apply elimination method if needed.
  5. Verify semantics preserved.
- Design tradeoffs:
  - Multi-valued constants give concise representation but require finite domains for elimination.
  - Boolean decomposition is always possible but less elaboration tolerant.
  - Definite theories simplify translation but may be restrictive for complex domains.
- Failure signatures:
  - Nonfinite domains in elimination steps.
  - Undefined causal explanations (no unique model).
  - Inconsistent action descriptions after translation.
- First 3 experiments:
  1. Encode a simple multi-valued fluent (e.g., box location) in C+ and verify causal explanation.
  2. Translate a definite causal theory with multi-valued constants to Boolean constants and check model correspondence.
  3. Translate an action description with attributes to ADL form and compare semantics.

## Open Questions the Paper Calls Out

### Open Question 1
- Question: Can the multi-valued fluent elimination method be extended to handle infinite domains of constants?
- Basis in paper: [explicit] The paper explicitly states that the elimination methods described assume finite domains, and shows how to eliminate multi-valued constants in favor of Boolean constants when domains are finite.
- Why unresolved: The paper only addresses finite domains and does not explore what happens with infinite domains. The elimination methods rely on being able to create a Boolean constant for each value in the domain.
- What evidence would resolve it: A formal proof showing whether the elimination methods can be extended to infinite domains, or a counterexample demonstrating why it cannot be done.

### Open Question 2
- Question: How does the expressiveness of C+ compare to other action languages like TAL or GOLOG when dealing with multi-valued fluents?
- Basis in paper: [inferred] The paper compares C+ to Pednault's ADL language but doesn't explore comparisons with other action languages that might also handle multi-valued fluents.
- Why unresolved: The paper focuses on the relationship between C+ and ADL but doesn't provide a comprehensive comparison with other action formalisms.
- What evidence would resolve it: A formal expressiveness comparison between C+ and other action languages for multi-valued fluent domains, including translations in both directions.

### Open Question 3
- Question: What is the computational complexity of planning in domains described using C+ with multi-valued fluents?
- Basis in paper: [inferred] The paper introduces the formalism but doesn't analyze the computational properties of reasoning tasks in C+.
- Why unresolved: While the paper provides the theoretical foundation for C+, it doesn't investigate the practical complexity of tasks like planning or projection in this extended framework.
- What evidence would resolve it: Complexity results for various reasoning tasks (planning, projection, consistency checking) in C+ domains, showing whether they remain in the same complexity classes as C or become harder.

## Limitations
- The finite domain requirement for elimination to Boolean constants limits applicability to real-world domains with unbounded or infinite attribute values.
- The connection to Pednault's ADL is only briefly sketched without formal translation procedures or complexity analysis.
- Claims about elaboration tolerance and practical advantages over existing approaches lack sufficient empirical validation.

## Confidence
- **High Confidence**: The theoretical foundations for multi-valued causal logic and the embedding of C+ into causal theories are well-established and mathematically rigorous.
- **Medium Confidence**: The translation procedures from multi-valued to Boolean constants are correct for finite domains, but practical applicability in complex domains remains uncertain.
- **Low Confidence**: Claims about elaboration tolerance and practical advantages over existing approaches lack sufficient empirical support and concrete demonstrations.

## Next Checks
1. Implement a concrete example with a large but finite domain (e.g., 100 locations) and verify the elimination procedure scales reasonably in both representation size and computational complexity.
2. Compare the C+ representation of a moderately complex action domain with its Boolean-decomposed equivalent to measure elaboration tolerance empirically.
3. Develop a small benchmark suite of action domains with multi-valued fluents and evaluate how well C+ captures their semantics compared to traditional approaches.