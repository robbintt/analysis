---
ver: rpa2
title: Anytime Approximate Formal Feature Attribution
arxiv_id: '2312.06973'
source_url: https://arxiv.org/abs/2312.06973
tags:
- marco-a
- time
- marco-c
- marco-s
- marques-silva
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: 'Anytime Approximate Formal Feature Attribution Problem addressed:
  Computing formal feature attribution (FFA) for machine learning classifiers is computationally
  challenging. The paper tackles the problem of efficiently approximating FFA in an
  anytime fashion.'
---

# Anytime Approximate Formal Feature Attribution

## Quick Facts
- arXiv ID: 2312.06973
- Source URL: https://arxiv.org/abs/2312.06973
- Reference count: 40
- Primary result: Adaptive algorithm for anytime approximate formal feature attribution

## Executive Summary
This paper addresses the computational challenge of computing formal feature attribution (FFA) for machine learning classifiers. The authors propose an efficient anytime approximation algorithm that adaptively switches between enumerating contrastive explanations (CXp) and abductive explanations (AXp). By starting with CXp enumeration and transitioning to AXp enumeration based on heuristic criteria, the algorithm achieves better FFA approximation quality faster than pure enumeration methods. Experiments on multiple datasets demonstrate improvements in approximation error, feature ranking, distribution similarity, and explanation diversity.

## Method Summary
The paper introduces MARCO-S, an adaptive algorithm that switches between CXp and AXp enumeration on-the-fly. It starts with CXp enumeration and transitions to AXp enumeration when either CXp sizes stabilize (measured by average size in a sliding window) or AXp sizes consistently exceed CXp sizes by a factor. The algorithm employs SAT-based hitting set enumeration with incremental solvers, representing CXp's and AXp's as sets of negative and positive blocking clauses. This allows seamless phase switching without losing learnt information. The approach is evaluated against pure CXp enumeration (MARCO-C) and pure AXp enumeration (MARCO-A) across five datasets using gradient boosted trees.

## Key Results
- MARCO-S outperforms both MARCO-C and MARCO-A in FFA approximation error, Kendall's Tau, RBO, and KL divergence
- The adaptive switching achieves better feature ranking and distribution similarity metrics faster than exact FFA computation
- MARCO-S generates more diverse AXp's while maintaining high quality FFA approximation
- The anytime property allows users to trade off computation time against approximation accuracy

## Why This Works (Mechanism)

### Mechanism 1
- Claim: Switching from CXp to AXp enumeration on-the-fly improves FFA approximation efficiency.
- Mechanism: The algorithm starts with CXp enumeration, which generates diverse AXp's as a side effect. When the rate of AXp discovery drops (measured by average sizes of recent CXp's vs AXp's), it switches to direct AXp enumeration.
- Core assumption: AXp's are typically larger than CXp's, and diverse AXp's are crucial for good FFA approximation.
- Evidence anchors:
  - [abstract] "proposes an efficient heuristic to switch from CXp enumeration to AXp enumeration on-the-fly resulting in an adaptive explanation enumeration algorithm effectively approximating FFA"
  - [section 3.2] "we propose to set up MARCO in a way that it starts with CXp enumeration and then seamlessly switches to AXp enumeration using two simple heuristic criteria"
  - [corpus] Found 25 related papers. Average neighbor FMR=0.544, average citations=0.0.
- Break condition: If the diversity of AXp's generated by CXp enumeration is insufficient, or if the switching criteria are poorly calibrated, the approach may not outperform pure AXp enumeration.

### Mechanism 2
- Claim: Computing FFA from CXp's is computationally hard (#P-hard), justifying the need for approximation.
- Mechanism: The paper proves that determining FFA from CXp's is #P-hard by reducing it to counting minimal vertex covers in graphs.
- Core assumption: The minimal hitting set duality between AXp's and CXp's holds, allowing the reduction to graph theory problems.
- Evidence anchors:
  - [abstract] "gives compelling evidence that computing FFA is intractable, even if the set of contrastive formal explanations (CXp's) is provided, by proving that the problem is #P-hard"
  - [section 3.1] "Determining ffaκ(i, (v, c)) from C is #P-hard even when all CXp's have size two"
  - [corpus] Found 25 related papers. Average neighbor FMR=0.544, average citations=0.0.
- Break condition: If the duality between AXp's and CXp's does not hold for a particular classifier or dataset, the hardness proof may not apply.

### Mechanism 3
- Claim: Using SAT-based hitting set enumeration with incremental solvers enables efficient switching between CXp and AXp enumeration.
- Mechanism: The algorithm employs pure SAT-based hitting set enumerator, representing CXp's and AXp's as sets of negative and positive blocking clauses, allowing seamless phase switching without losing learnt information.
- Core assumption: SAT-based solvers can efficiently handle the incremental addition and removal of blocking clauses during phase switching.
- Evidence anchors:
  - [section 3.2] "we employ pure SAT-based hitting enumerator, where an incremental SAT solver is called multiple times aiming for minimal or maximal models"
  - [section 3.2] "we can flip from computing hitting sets of E1−ρ subject to Eρ to computing hitting sets of Eρ subject to E1−ρ, and vice versa"
  - [corpus] Found 25 related papers. Average neighbor FMR=0.544, average citations=0.0.
- Break condition: If the SAT solver struggles with the specific constraints of the problem, or if the incremental approach leads to memory issues, the switching mechanism may fail.

## Foundational Learning

- Concept: Minimal Hitting Set Duality
  - Why needed here: Understanding the duality between AXp's and CXp's is crucial for the algorithm's switching mechanism.
  - Quick check question: Can you explain why AXp's and CXp's are minimal hitting sets of each other?

- Concept: #P-hardness
  - Why needed here: Recognizing the computational hardness of exact FFA computation justifies the need for approximation algorithms.
  - Quick check question: What is the difference between NP-hardness and #P-hardness, and why is #P-hardness stronger evidence of intractability?

- Concept: Incremental SAT Solving
  - Why needed here: The algorithm relies on incremental SAT solvers to efficiently switch between enumeration phases.
  - Quick check question: How does incremental SAT solving differ from traditional SAT solving, and why is it beneficial for this application?

## Architecture Onboarding

- Component map: Classifier -> MARCO Algorithm -> SAT Solver -> Switching Criteria -> Evaluation Metrics

- Critical path:
  1. Initialize MARCO with CXp enumeration.
  2. Generate CXp's and extract AXp's as a side effect.
  3. Monitor the switching criteria (average sizes of recent CXp's and AXp's).
  4. When criteria are met, switch to AXp enumeration.
  5. Continue enumeration until resources are exhausted or all explanations are found.
  6. Compute FFA approximation based on the collected AXp's.

- Design tradeoffs:
  - CXp vs. AXp enumeration: CXp enumeration generates diverse AXp's but may be slower in the long run; AXp enumeration is faster for exact computation but may lack diversity initially.
  - Switching criteria: The choice of criteria (e.g., average size ratios, stability thresholds) affects when and how often the algorithm switches phases.
  - SAT solver configuration: The incremental approach allows for efficient phase switching but may require careful management of memory and learnt information.

- Failure signatures:
  - Slow convergence: If the switching criteria are too conservative, the algorithm may spend too much time in CXp enumeration without generating enough diverse AXp's.
  - Premature switching: If the criteria are too aggressive, the algorithm may switch to AXp enumeration too early, missing out on the diversity benefits of CXp enumeration.
  - Memory issues: If the SAT solver struggles with the incremental addition and removal of blocking clauses, the algorithm may run out of memory or slow down significantly.

- First 3 experiments:
  1. Run the algorithm on a small, well-understood dataset (e.g., a simple binary classification problem) to verify that it can correctly compute FFA and switch between phases.
  2. Test the algorithm with different switching criteria (e.g., varying the window size w, stability threshold ε, and size ratio threshold α) to understand their impact on performance.
  3. Compare the algorithm's performance against pure CXp and AXp enumeration on a range of datasets, measuring the quality of FFA approximation and the number of explanations generated.

## Open Questions the Paper Calls Out

### Open Question 1
- Question: How does the choice of window size w and switching parameters α and ε impact the performance of MARCO-S?
- Basis in paper: [explicit] The paper mentions using w = 50, α = 1, and ε = 2, but does not explore the impact of varying these parameters.
- Why unresolved: The paper does not provide an ablation study on the impact of these parameters on the performance of MARCO-S.
- What evidence would resolve it: Experiments varying the values of w, α, and ε and measuring the impact on the performance of MARCO-S in terms of FFA approximation error, feature ranking, distribution similarity, and number of explanations generated.

### Open Question 2
- Question: How does the performance of MARCO-S compare to other anytime FFA approximation approaches?
- Basis in paper: [inferred] The paper only compares MARCO-S to MARCO-A and MARCO-C, but does not compare it to other anytime FFA approximation approaches.
- Why unresolved: The paper does not explore the performance of MARCO-S relative to other anytime FFA approximation methods.
- What evidence would resolve it: Experiments comparing the performance of MARCO-S to other anytime FFA approximation approaches on the same datasets and metrics.

### Open Question 3
- Question: How does the performance of MARCO-S scale with the size of the feature space and the complexity of the classifier?
- Basis in paper: [inferred] The paper only evaluates MARCO-S on datasets with a limited number of features and classifiers with a moderate depth. It is unclear how the approach would perform on larger, more complex problems.
- Why unresolved: The paper does not provide an analysis of the scalability of MARCO-S to larger feature spaces and more complex classifiers.
- What evidence would resolve it: Experiments evaluating the performance of MARCO-S on datasets with varying numbers of features and classifiers with different depths and complexities.

## Limitations
- The switching criteria (window size, stability threshold, size ratio) are presented as heuristics without rigorous justification for their specific values
- The computational complexity claims rely on the assumption that AXp-CXp duality holds perfectly, which may break down for certain classifier architectures
- The anytime property performance claims depend heavily on implementation details and may not generalize to all classifier types

## Confidence
- **High confidence**: The #P-hardness proof and the fundamental mechanism of switching between CXp and AXp enumeration
- **Medium confidence**: The effectiveness of the specific switching criteria and their generalizability across datasets
- **Medium confidence**: The anytime property performance claims, as the normalized time comparisons depend heavily on implementation details

## Next Checks
1. Test the algorithm on non-tree-based classifiers (e.g., neural networks) to verify if the AXp-CXp size relationship holds and the switching criteria remain effective
2. Implement a systematic parameter sweep for the switching thresholds (w, ε, α) to identify optimal values across different dataset characteristics
3. Create controlled synthetic datasets where AXp and CXp size relationships are known to break down to test the algorithm's robustness to assumption violations