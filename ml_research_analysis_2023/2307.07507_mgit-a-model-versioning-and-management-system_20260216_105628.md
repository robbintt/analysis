---
ver: rpa2
title: 'MGit: A Model Versioning and Management System'
arxiv_id: '2307.07507'
source_url: https://arxiv.org/abs/2307.07507
tags:
- mgit
- lineage
- graph
- edge
- parameters
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: MGit is a model versioning and management system designed to handle
  machine learning models that are derived from other models, a common scenario in
  modern ML workflows. It introduces a lineage graph to track provenance and versioning
  information between models, along with optimizations for efficient storage of model
  parameters.
---

# MGit: A Model Versioning and Management System

## Quick Facts
- arXiv ID: 2307.07507
- Source URL: https://arxiv.org/abs/2307.07507
- Reference count: 12
- One-line primary result: MGit reduces storage footprint by up to 7x for machine learning model derivatives

## Executive Summary
MGit is a novel system designed to address the challenges of versioning and managing machine learning models that are derived from other models. It introduces a lineage graph data structure to efficiently track provenance and versioning information between models, along with optimizations for storage using content-based hashing and delta compression. MGit provides abstractions over the lineage graph to facilitate testing, updating, and collaboration on model derivatives, making it particularly useful for scenarios such as model adaptation, federated learning, and edge device specialization.

## Method Summary
MGit implements a lineage graph data structure with nodes representing models and edges tracking provenance (parent-child relationships) and versioning (concurrent modifications). The system uses content-based hashing to store parameters shared across models efficiently, and delta compression to compress differences between non-shared parameters. MGit provides creation functions to specify how models are derived from parents, traversal primitives for graph navigation, and merge primitives for conflict resolution during collaborative development.

## Key Results
- Reduces lineage graph storage footprint by up to 7x through content-based hashing and delta compression
- Enables automatic updating of downstream models when upstream models change
- Provides abstractions that facilitate testing, updating, and collaboration on model derivatives

## Why This Works (Mechanism)

### Mechanism 1
- Claim: MGit uses a lineage graph to efficiently track and manage model dependencies
- Mechanism: The lineage graph data structure records provenance and versioning information between models, enabling efficient storage and tracking of model derivatives
- Core assumption: Models in ML workflows are often derived from other models, sharing structure and parameter values
- Evidence anchors:
  - [abstract] "Models derived from other models are extremely common in machine learning (ML) today... it is hard to manage these model derivatives: the storage overhead of storing all derived models quickly becomes onerous"
  - [section 1] "Across these disparate use cases, it has become increasingly common for models to be created that depend on each other."
  - [corpus] Weak corpus evidence; no direct mention of lineage graphs in related papers
- Break condition: If models are not frequently derived from other models, the lineage graph's benefits would be minimal

### Mechanism 2
- Claim: MGit's storage optimizations reduce the lineage graph's storage footprint by up to 7x
- Mechanism: MGit uses content-based hashing to store parameters shared across models efficiently and delta compression to compress the deltas between non-shared parameters
- Core assumption: Many derived models can share parameters exactly or deviate from "parent" models by a small amount
- Evidence anchors:
  - [abstract] "MGit is able to reduce the lineage graph's storage footprint by up to 7×"
  - [section 4] "We make the observation that many derived models can share parameters... To not redundantly store duplicate copies of these parameters, we use content-based hashing."
  - [corpus] Weak corpus evidence; no direct mention of storage optimizations in related papers
- Break condition: If models in the lineage graph do not share parameters or have large differences, the storage optimizations would be less effective

### Mechanism 3
- Claim: MGit enables efficient testing, updating, and collaboration on model derivatives
- Mechanism: MGit provides abstractions over the lineage graph that facilitate relevant testing, updating, and collaboration functionality, such as traversal primitives, creation functions, and merge primitives
- Core assumption: Managing model derivatives requires efficient ways to test models, update them in response to upstream changes, and support collaborative development
- Evidence anchors:
  - [abstract] "MGit introduces a lineage graph that records provenance and versioning information between models, optimizations to efficiently store model parameters, as well as abstractions over this lineage graph that facilitate relevant testing, updating and collaboration functionality."
  - [section 5] "We now describe higher-level functions that can be performed over the lineage graph... MGit is also able to leverage its lineage graph and creation functions to train models that share state."
  - [corpus] Weak corpus evidence; no direct mention of testing, updating, or collaboration functionality in related papers
- Break condition: If the lineage graph becomes too complex or the abstractions are not well-designed, testing, updating, and collaboration functionality may become difficult to use

## Foundational Learning

- Concept: Lineage graph data structure
  - Why needed here: To track provenance and versioning information between models, enabling efficient management of model derivatives
  - Quick check question: What are the two types of edges in MGit's lineage graph, and what information do they track?

- Concept: Content-based hashing and delta compression
  - Why needed here: To efficiently store model parameters and reduce storage footprint by avoiding redundant storage of shared parameters and compressing differences between models
  - Quick check question: How does MGit use content-based hashing and delta compression to optimize storage of model parameters?

- Concept: Creation functions and traversal primitives
  - Why needed here: To specify how models are created from their parents and enable efficient testing, updating, and collaboration on model derivatives
  - Quick check question: What is the purpose of creation functions in MGit, and how do traversal primitives facilitate testing and updating models?

## Architecture Onboarding

- Component map:
  - Lineage graph: Core data structure tracking provenance and versioning between models
  - Storage optimizations: Content-based hashing and delta compression techniques
  - Abstractions: Testing, updating, and collaboration functionality over the lineage graph
  - API: Lower-level API for accessing and mutating the lineage graph, higher-level API for complex functionality

- Critical path:
  1. Create or import models into the lineage graph
  2. Apply storage optimizations to reduce storage footprint
  3. Use abstractions to test, update, and collaborate on models

- Design tradeoffs:
  - Storage efficiency vs. computational overhead of storage optimizations
  - Flexibility of lineage graph structure vs. complexity of managing dependencies
  - Granularity of abstractions vs. ease of use for different use cases

- Failure signatures:
  - Lineage graph becomes too complex or difficult to manage
  - Storage optimizations do not provide expected space savings
  - Abstractions are not well-designed or do not cover all use cases

- First 3 experiments:
  1. Create a simple lineage graph with a few models and verify that storage optimizations are applied correctly
  2. Test the functionality of creation functions and traversal primitives by creating a model from its parents and running tests
  3. Experiment with the merge primitive to resolve conflicts between concurrent changes made to a model

## Open Questions the Paper Calls Out

### Open Question 1
- Question: How does MGit handle provenance and versioning edges between models that share the same structure but have different parameter values due to retraining on different data?
- Basis in paper: [explicit] The paper mentions that MGit uses content-based hashing and delta compression to efficiently store model parameters, but it doesn't specify how it handles models with the same structure but different parameter values
- Why unresolved: The paper doesn't provide details on how MGit distinguishes between models that are structurally identical but have different parameter values due to retraining
- What evidence would resolve it: The paper could provide more details on how MGit handles models with the same structure but different parameter values, such as whether it creates separate nodes for each version or uses a different approach

### Open Question 2
- Question: How does MGit ensure that the automated graph construction algorithm correctly identifies the parent-child relationships between models when the divergence scores are close?
- Basis in paper: [explicit] The paper mentions that the automated graph construction algorithm uses divergence scores to determine the parent-child relationships between models, but it doesn't specify how it handles cases where the scores are close
- Why unresolved: The paper doesn't provide details on how MGit ensures the correctness of the parent-child relationships when the divergence scores are close
- What evidence would resolve it: The paper could provide more details on how MGit handles cases where the divergence scores are close, such as whether it uses additional criteria or allows users to manually correct the relationships

### Open Question 3
- Question: How does MGit handle conflicts during the merge primitive when multiple users make concurrent changes to the same model?
- Basis in paper: [explicit] The paper mentions that MGit provides a merge primitive to handle conflicts during collaboration, but it doesn't specify how it handles conflicts when multiple users make concurrent changes to the same model
- Why unresolved: The paper doesn't provide details on how MGit handles conflicts during the merge primitive, such as whether it uses a specific algorithm or allows users to manually resolve conflicts
- What evidence would resolve it: The paper could provide more details on how MGit handles conflicts during the merge primitive, such as the specific algorithm used or examples of how users can manually resolve conflicts

## Limitations

- Evaluation focuses on storage optimizations and basic lineage tracking, lacking comprehensive validation of collaboration features
- 7× storage reduction claim demonstrated primarily through synthetic examples rather than production-scale deployments
- Does not address potential scalability concerns with very large lineage graphs or performance implications on GPU-accelerated training workflows

## Confidence

- Lineage graph mechanism: High - The data structure is clearly specified and the provenance tracking approach is well-founded
- Storage optimization claims: Medium - The 7× reduction is demonstrated but limited to controlled examples without broader benchmarking
- Collaboration functionality: Low - While described, the collaboration features lack thorough validation in realistic multi-user scenarios

## Next Checks

1. Benchmark storage savings across diverse model families (CNNs, transformers, recommendation systems) with varying parameter sharing patterns
2. Stress-test concurrent modification scenarios to evaluate merge primitive behavior and conflict resolution performance
3. Measure runtime overhead of lineage graph operations during active training workflows, including GPU memory usage