---
ver: rpa2
title: Exploiting Uncertainty for Querying Inconsistent Description Logics Knowledge
  Bases
arxiv_id: '2306.09138'
source_url: https://arxiv.org/abs/2306.09138
tags:
- justi
- query
- cations
- axioms
- semantics
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: This paper proposes a probabilistic approach for querying inconsistent
  Description Logic knowledge bases using the DISPONTE semantics. It extends existing
  tableau-based reasoners to handle inconsistent KBs by modifying the tracing function
  to distinguish between justifications caused by inconsistency and those due to the
  query itself.
---

# Exploiting Uncertainty for Querying Inconsistent Description Logics Knowledge Bases

## Quick Facts
- arXiv ID: 2306.09138
- Source URL: https://arxiv.org/abs/2306.09138
- Reference count: 14
- One-line primary result: TRILLInc and BUNDLEInc handle inconsistent DL KBs with only 15% overhead for consistent KBs and return query probabilities with justifications.

## Executive Summary
This paper addresses the challenge of querying inconsistent Description Logic (DL) knowledge bases (KBs) by extending existing tableau-based reasoners with probabilistic semantics. The approach, based on DISPONTE semantics, allows for querying inconsistent KBs by treating axiom presence/absence as independent Bernoulli variables and computing query probabilities conditioned on consistency. The method modifies the tracing function to distinguish between justifications caused by inconsistency and those due to the query itself, enabling correct probability computation without changing the tableau algorithm. The extensions are implemented in TRILL and BUNDLE reasoners, showing promising results with modest overhead and the ability to handle large KBs.

## Method Summary
The paper proposes a probabilistic approach for querying inconsistent DL knowledge bases using the DISPONTE semantics. It extends existing tableau-based reasoners by modifying the tracing function to distinguish between justifications caused by inconsistency and those due to the query itself. The approach involves collecting justifications for both the query and inconsistency, compiling them into Binary Decision Diagrams (BDDs), and computing the probability of the query conditioned on consistency. The extensions are implemented in the TRILL and BUNDLE reasoners, named TRILLInc and BUNDLEInc respectively, and are tested on a set of small knowledge bases with varying degrees of inconsistency.

## Key Results
- TRILLInc and BUNDLEInc handle inconsistent DL KBs with only 15% overhead for consistent KBs and up to 2.43 times overhead for inconsistent KBs with many justifications.
- The approach is more general than repair semantics as it allows both ABox and TBox to be inconsistent.
- The method returns query probabilities with justifications, making the results more informative for debugging inconsistent KBs.

## Why This Works (Mechanism)

### Mechanism 1
- Claim: Probabilistic semantics allow querying inconsistent DL KBs by modeling axiom presence/absence as independent Bernoulli variables.
- Mechanism: Each probabilistic axiom pi :: E is treated as an independent choice with probability pi of being included in a world. Worlds are constructed by selecting axiom subsets, and queries are evaluated only on consistent worlds. The final probability is the ratio of consistent-world query probability to overall consistency probability.
- Core assumption: Axiom presence/absence is pairwise independent and that a reasoner can enumerate all justifications for both the query and inconsistency.
- Evidence anchors:
  - [abstract] "We exploit an existing probabilistic semantics called DISPONTE to overcome this problem and allow queries also in case of inconsistent KBs."
  - [section 3] "Defining the probability of the presence of an axiom could be easier for an expert of the domain. Or else, one can associate a probability value to axioms depending on how much they trust the source of the information."
- Break condition: If axioms are not independent or if justification enumeration is infeasible, the method fails.

### Mechanism 2
- Claim: Modified tracing function distinguishes justifications caused by inconsistency vs. query negation.
- Mechanism: The tracing function is initialized with a placeholder Qp for the negated query. During tableau expansion, justifications containing Qp are flagged as query-caused, while those without are inconsistency-caused. This separation enables correct probability computation without changing the tableau algorithm.
- Core assumption: The placeholder axiom Qp can be treated as a normal axiom in the tableau rules and that the tracing function remains correct under this modification.
- Evidence anchors:
  - [section 3.1] "A simple way to solve this problem is to change the tracing function so that it adds a placeholder to the justifications for the negation of the query to keep the justifications that contain this placeholder separated from those without it, which are justifications caused by an inconsistency."
  - [section 3.1] "An important aspect of this implementation is that all the results about completeness and correctness of the tableau (see [HKS06]) still apply, since the tableau algorithm is not modified."
- Break condition: If tableau expansion rules incorrectly propagate the placeholder or if the reasoning engine cannot handle the extra axiom, the separation fails.

### Mechanism 3
- Claim: Binary Decision Diagrams (BDDs) enable efficient probability computation from justifications.
- Mechanism: The set of all justifications for a query and for inconsistency are compiled into BDDs. These BDDs are then combined to compute the probability of the query conditioned on consistency. BDDs allow compact representation and efficient manipulation of large Boolean formulas.
- Core assumption: The number of justifications is tractable and that BDD packages can handle the resulting formula sizes.
- Evidence anchors:
  - [section 2.2] "An effective way of computing the probability of a query from a covering set of justifications consists in compiling it into a Binary Decision Diagram (BDD)."
  - [section 3.1] "algorithms based on BDDs were able to solve problems with hundreds of thousands of variables (see e.g. the works on inference on probabilistic logic programs [DKT07, Rig07, Rig09, RS10, KDD +11, RS11])."
- Break condition: If justification sets explode combinatorially or if BDD compilation fails due to formula size, the approach becomes infeasible.

## Foundational Learning

- Concept: Description Logic (DL) tableau algorithm
  - Why needed here: The approach extends existing tableau-based reasoners to handle inconsistency by modifying tracing.
  - Quick check question: What is a tableau and how does it prove entailment by contradiction?

- Concept: Justifications in DL
  - Why needed here: Justifications are the minimal axiom subsets causing entailment or inconsistency; they are the core data structure used for probability computation.
  - Quick check question: What is the difference between a justification for a query and a justification for inconsistency?

- Concept: Binary Decision Diagrams (BDDs)
  - Why needed here: BDDs compactly encode Boolean formulas representing sets of justifications, enabling efficient probability calculation.
  - Quick check question: How does a BDD represent a Boolean function and what operations are supported?

## Architecture Onboarding

- Component map:
  KB Parser -> Probabilistic Annotation Layer -> Tableau Engine (with extended tracing) -> Justification Collector -> BDD Compiler -> Probability Calculator

- Critical path:
  1. Parse KB and attach probability annotations.
  2. Initialize tableau with modified tracing (add Qp for negated query).
  3. Expand tableau, collect justifications for both query and inconsistency.
  4. Compile justifications into BDDs.
  5. Combine BDDs and compute PC(Q).

- Design tradeoffs:
  - Extending tracing vs. adding fresh concepts: tracing extension preserves tableau correctness guarantees; fresh-concept approach avoids modifying reasoners but may complicate axiom management.
  - Using BDDs vs. other knowledge compilation tools: BDDs are mature and efficient but may struggle with very large justification sets; SDDs or d-DNNFs could be alternatives.

- Failure signatures:
  - Tableau fails to terminate or explodes in size → justification enumeration bottleneck.
  - BDD compilation fails or produces huge BDDs → combinatorial justification explosion.
  - Incorrect probability values → tracing function bug or independence assumption violation.

- First 3 experiments:
  1. Run TRILLInc on a small consistent KB (no disjoint axioms) and verify that PC(Q) matches standard DISPONTE probability.
  2. Run TRILLInc on an inconsistent KB with disjoint axioms (j=0,k=1) and verify that only two minimal justifications for inconsistency are found.
  3. Run TRILLInc on an inconsistent KB with disjoint axioms (j=n,k=n-1) and measure overhead vs. TRILL on consistent KB of same size.

## Open Questions the Paper Calls Out

### Open Question 1
- Question: How does the overhead of the extended TRILLInc and BUNDLEInc reasoners scale with increasing KB sizes beyond those tested?
- Basis in paper: [explicit] The paper tested KBs with sizes up to 10 axioms and observed an overhead of around 15% for consistent KBs and up to 2.43 times for inconsistent KBs with many justifications. However, the authors note that they plan to study the generalization to FOL of the presented extensions, suggesting that the current implementation may not be optimal for larger KBs.
- Why unresolved: The paper only tested KBs with a limited number of axioms and justifications. The scalability of the approach for larger KBs is unknown.
- What evidence would resolve it: Further empirical testing with larger KBs, measuring the overhead and runtime as the KB size increases.

### Open Question 2
- Question: How does the proposed approach compare to other inconsistency-tolerant reasoning approaches, such as those based on argumentation or paraconsistent logics, in terms of expressiveness and performance?
- Basis in paper: [inferred] The paper discusses related work on inconsistency-tolerant reasoning, including approaches based on argumentation and paraconsistent logics. However, it does not provide a direct comparison with these approaches in terms of expressiveness and performance.
- Why unresolved: The paper focuses on comparing the proposed approach with repair semantics and does not provide a comprehensive comparison with other approaches.
- What evidence would resolve it: A systematic comparison of the proposed approach with other inconsistency-tolerant reasoning approaches, considering factors such as expressiveness, performance, and ease of use.

### Open Question 3
- Question: How can the proposed approach be extended to handle more expressive DLs, such as those with nominals or datatypes?
- Basis in paper: [inferred] The paper mentions that the proposed approach can be applied to any DL language equipped with a suitable set of tableau expansion rules. However, it does not discuss the challenges and potential solutions for extending the approach to more expressive DLs.
- Why unresolved: The paper focuses on the ALC DL and does not explore the extension to more expressive DLs.
- What evidence would resolve it: A theoretical analysis of the challenges and potential solutions for extending the approach to more expressive DLs, along with empirical testing to evaluate the performance and correctness of the extended approach.

## Limitations
- The approach assumes pairwise independence between probabilistic axioms, which may not hold in all scenarios.
- Justification enumeration can become intractable for large KBs with many justifications, leading to BDD compilation failure.
- The current implementation only handles probabilistic ABoxes, leaving TBox inconsistencies unaddressed.

## Confidence
- High: The core mechanism of separating query vs. inconsistency justifications is well-established in the tableau literature.
- Medium: The BDD-based probability computation is promising but depends heavily on justification set size and structure.
- Low: The general scalability claim is uncertain, as the evaluation uses relatively small KBs compared to industrial-scale ontologies.

## Next Checks
1. Test on TBox-inconsistent KBs to verify if the method can be extended beyond ABox inconsistencies.
2. Measure justification enumeration time and BDD compilation time separately to identify bottlenecks in large KBs.
3. Evaluate the independence assumption by testing KBs with correlated probabilistic axioms to check if results remain valid.