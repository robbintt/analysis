---
ver: rpa2
title: A Simple and Scalable Representation for Graph Generation
arxiv_id: '2312.02230'
source_url: https://arxiv.org/abs/2312.02230
tags:
- graph
- geel
- graphs
- generation
- size
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: This paper proposes a new graph representation for graph generation
  called Gap Encoded Edge List (GEEL). GEEL has a compact representation size aligned
  with the number of edges and significantly reduces the vocabulary size by incorporating
  gap encoding and bandwidth restriction.
---

# A Simple and Scalable Representation for Graph Generation

## Quick Facts
- arXiv ID: 2312.02230
- Source URL: https://arxiv.org/abs/2312.02230
- Authors: 
- Reference count: 40
- Key outcome: Proposes Gap Encoded Edge List (GEEL) representation that reduces vocabulary size from N² to B² while improving scalability and achieving state-of-the-art results on 12 graph generation tasks.

## Executive Summary
This paper introduces GEEL, a novel graph representation for autoregressive generation that combines edge list representation with gap encoding and bandwidth restriction. By encoding edges as tuples of node index differences rather than absolute indices, GEEL significantly reduces the vocabulary size from O(N²) to O(B²) where B is the graph bandwidth. The approach is validated on ten non-attributed and two molecular graph generation tasks, demonstrating improved scalability and state-of-the-art performance.

## Method Summary
The GEEL representation encodes graphs as edge lists with gap encoding, where each edge tuple (am, bm) represents the difference between consecutive source nodes and between source and target nodes. Bandwidth is restricted using Cuthill-McKee node ordering to minimize the maximum gap values. The method uses an LSTM backbone for autoregressive generation with node positional encoding. For attributed graphs, a grammar extension specifies positions for node and edge types within the GEEL representation. The approach reduces representation size from O(N²) to O(M) and vocabulary size from O(N²) to O(B²).

## Key Results
- Achieves state-of-the-art results on ten non-attributed graph generation tasks (Planar, Lobster, Enzymes, SBM, Ego, Grid, Proteins, 3D point cloud)
- Matches or outperforms existing methods on two molecular graph generation tasks (QM9, ZINC250k)
- Reduces vocabulary size from N² to B² through gap encoding and bandwidth restriction
- Improves scalability with O(M) representation size versus O(N²) for adjacency matrices

## Why This Works (Mechanism)

### Mechanism 1
- Claim: Gap encoding reduces vocabulary size from N² to B² by replacing node indices with differences.
- Mechanism: Each edge tuple (am, bm) encodes the difference between consecutive source nodes (am) and between source and target nodes (bm). This compression exploits the fact that real-world graphs have small bandwidth B.
- Core assumption: Graph bandwidth B is much smaller than N, making B² << N².
- Evidence anchors:
  - [abstract]: "GEEL significantly reduces the vocabulary size by incorporating the gap encoding and bandwidth restriction schemes."
  - [section]: "The vocabulary size of our GEEL representation is bounded by maxm am · maxm bm ≤ B2."
- Break condition: If bandwidth B grows to O(N), the vocabulary size reduction advantage disappears.

### Mechanism 2
- Claim: Bandwidth restriction via Cuthill-McKee ordering further reduces vocabulary size.
- Mechanism: C-M ordering renumbers nodes to minimize bandwidth, directly reducing the maximum intra-edge gap bm and inter-edge gap am.
- Core assumption: The bandwidth of real-world graphs can be effectively reduced through node reordering without losing structural information.
- Evidence anchors:
  - [abstract]: "We further reduce the graph bandwidth B by the C-M ordering following Diamant et al. (2023)."
  - [section]: "We follow Diamant et al. (2023) to restrict the bandwidth via the Cuthill-McKee (C-M) node ordering (Cuthill & McKee, 1969)."
- Break condition: If reordering disrupts important structural patterns or if the graph topology inherently requires large bandwidth.

### Mechanism 3
- Claim: Edge list representation reduces representation size from N² to M, improving scalability.
- Mechanism: By generating edges directly rather than full adjacency matrices, the model only needs to predict M edges instead of N² entries.
- Core assumption: Real-world graphs are sparse (M << N²), making edge list representation more compact.
- Evidence anchors:
  - [abstract]: "GEEL enjoys a compact representation size that aligns with the number of edges."
  - [section]: "the list contains M edges that are fewer than N 2 elements in the adjacency matrix."
- Break condition: If graphs become dense (M ≈ N²), the size advantage diminishes.

## Foundational Learning

- Concept: Graph bandwidth and its definition
  - Why needed here: Understanding bandwidth is crucial for grasping why gap encoding reduces vocabulary size
  - Quick check question: What is the maximum difference between adjacent nodes in a graph with bandwidth B?

- Concept: Cuthill-McKee node ordering algorithm
  - Why needed here: The paper uses C-M ordering to minimize bandwidth, which is key to the approach
  - Quick check question: How does C-M ordering rearrange nodes to minimize bandwidth?

- Concept: Edge list vs adjacency matrix representations
  - Why needed here: The paper's core innovation is moving from adjacency matrix to edge list with gap encoding
  - Quick check question: For a graph with M edges and N nodes, what are the space complexities of edge list vs adjacency matrix representations?

## Architecture Onboarding

- Component map: Edge list generation → Gap encoding → LSTM prediction → Bandwidth restriction → Output graph
- Critical path: Edge list generation → Gap encoding → LSTM prediction → Bandwidth restriction → Output graph
- Design tradeoffs: Vocabulary size vs generation quality, computational complexity vs representation compactness
- Failure signatures: OOM errors on large graphs indicate bandwidth too large; poor generation quality suggests gap encoding not capturing dependencies well
- First 3 experiments:
  1. Verify vocabulary size reduction by comparing N² vs B² for sample graphs
  2. Test generation quality with and without gap encoding on a small dataset
  3. Measure inference time scaling with graph size to confirm O(M) complexity

## Open Questions the Paper Calls Out

### Open Question 1
- Question: How does the proposed Gap Encoded Edge List (GEEL) representation compare to other graph representations, such as adjacency matrices and edge lists, in terms of scalability and performance?
- Basis in paper: [explicit] The paper discusses the advantages of GEEL, including its compact representation size and reduced vocabulary size, which improve scalability and performance.
- Why unresolved: While the paper demonstrates the effectiveness of GEEL through experiments, a more comprehensive comparison with other graph representations would provide a clearer understanding of its strengths and weaknesses.
- What evidence would resolve it: A detailed comparison of GEEL with other graph representations, including quantitative metrics and qualitative analysis, would help determine its relative advantages and limitations.

### Open Question 2
- Question: How does the choice of node ordering, such as Cuthill-McKee (C-M) ordering, affect the performance of GEEL?
- Basis in paper: [explicit] The paper mentions that C-M ordering is used to reduce the graph bandwidth, which in turn reduces the vocabulary size of GEEL.
- Why unresolved: The paper provides limited discussion on the impact of different node orderings on GEEL's performance. Exploring alternative node orderings and their effects on the model's quality and efficiency would be valuable.
- What evidence would resolve it: A thorough investigation of various node orderings and their influence on GEEL's performance, including quantitative metrics and qualitative analysis, would shed light on the optimal ordering strategy.

### Open Question 3
- Question: How does GEEL handle attributed graphs, and what are the limitations of the proposed grammar for extending GEEL to attributed graphs?
- Basis in paper: [explicit] The paper introduces a new grammar for attributed graphs, specifying the position of node- and edge-types in the GEEL representation.
- Why unresolved: While the paper presents a method for extending GEEL to attributed graphs, it does not discuss the potential limitations or challenges associated with this extension. Further exploration of the grammar's expressiveness and its ability to capture complex graph structures would be beneficial.
- What evidence would resolve it: A comprehensive evaluation of GEEL's performance on attributed graphs, including a comparison with other methods for attributed graph generation, would provide insights into the strengths and weaknesses of the proposed grammar.

## Limitations
- Effectiveness critically depends on small graph bandwidth B; performance degrades when B approaches N
- Extension to attributed graphs is mentioned but not thoroughly evaluated beyond two molecular datasets
- Bandwidth reduction effectiveness through Cuthill-McKee ordering lacks empirical validation with reported bandwidth values

## Confidence
- High Confidence: Gap encoding vocabulary reduction (Mechanism 1) is well-supported by theoretical analysis and experimental results
- Medium Confidence: Scalability improvements claimed are theoretically justified but not empirically validated across full range of graph sizes
- Medium Confidence: Cuthill-McKee ordering effectiveness lacks direct empirical validation in this paper

## Next Checks
1. Measure bandwidth B before and after Cuthill-McKee ordering across all datasets to quantify actual vocabulary reduction achieved
2. Test GEEL on progressively larger graphs to identify the point where bandwidth B becomes large enough to negate the vocabulary size advantage
3. Implement systematic evaluation of attributed graph generation quality with varying grammar constraint strengths to understand the tradeoff between constraint strictness and generation diversity