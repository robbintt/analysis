---
ver: rpa2
title: Compositional Policy Learning in Stochastic Control Systems with Formal Guarantees
arxiv_id: '2312.01456'
source_url: https://arxiv.org/abs/2312.01456
tags:
- probability
- policy
- which
- each
- specification
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: CLAPS is a compositional algorithm for learning neural network
  policies that provide formal guarantees on the probability of satisfying SPECT RL
  specifications. It decomposes a SPECT RL specification into a directed acyclic graph
  of reach-avoid tasks, learns policies with reach-avoid supermartingales for each
  edge, and composes them into a global policy.
---

# Compositional Policy Learning in Stochastic Control Systems with Formal Guarantees

## Quick Facts
- **arXiv ID**: 2312.01456
- **Source URL**: https://arxiv.org/abs/2312.01456
- **Reference count**: 40
- **Primary result**: CLAPS decomposes SPECT RL specifications into DAG of reach-avoid tasks, learns policies with multiplicative RASMs for formal probabilistic guarantees, and composes them into global policy with exponentially tighter bounds than previous additive RASM methods.

## Executive Summary
CLAPS is a compositional algorithm for learning neural network policies that provide formal guarantees on the probability of satisfying SPECT RL specifications. It decomposes a SPECT RL specification into a directed acyclic graph of reach-avoid tasks, learns policies with reach-avoid supermartingales for each edge, and composes them into a global policy. The key novelty is an exponentially tighter lower bound on reach-avoidance probability via multiplicative RASMs, improving the previous additive RASM bound by a factor of γ^N. Experiments on the Stochastic Nine Rooms environment demonstrate its ability to decompose complex tasks into verifiable subtasks and learn a compositional policy with formal reach-avoidance guarantees, whereas end-to-end methods fail verification.

## Method Summary
CLAPS implements a compositional reinforcement learning approach that translates SPECT RL specifications into abstract graphs where vertices represent states and edges represent reach-avoid tasks. The algorithm performs a forward pass in topological order, using binary search with POLICY+RASM to learn edge policies with maximum probability bounds. Multiplicative RASMs provide exponentially tighter probabilistic guarantees compared to additive RASMs, crucial for complex specifications with many edges. The learned edge policies are composed into a global policy that guarantees the original specification with formal reach-avoidance probabilities.

## Key Results
- CLAPS decomposes SPECT RL specifications into DAG of reach-avoid tasks with formal probabilistic guarantees
- Multiplicative RASMs provide exponentially tighter bounds (1 - 1/λ · γ^N) compared to additive RASMs (1 - 1/λ)
- Experiments on Stochastic Nine Rooms demonstrate ability to learn compositional policies with verified reach-avoidance guarantees
- CLAPS succeeds where end-to-end methods like PPO cannot provide formal verification

## Why This Works (Mechanism)

### Mechanism 1
- Claim: CLAPS decomposes SPECT RL specifications into a directed acyclic graph (DAG) of reach-avoid tasks, enabling compositional learning with formal guarantees.
- Mechanism: The SPECT RL specification is translated into an abstract graph where each edge represents a reach-avoid task. Edge policies are learned independently with reach-avoid supermartingales (RASMs) that provide formal certificates of probabilistic satisfaction. These edge policies are then composed into a global policy that guarantees the original specification.
- Core assumption: The DAG structure allows probabilistic guarantees from edge policies to be composed multiplicatively to ensure global satisfaction.
- Evidence anchors:
  - [abstract]: "CLAPS is a compositional algorithm for learning neural network policies that provide formal guarantees on the probability of satisfying SPECT RL specifications. It decomposes a SPECT RL specification into a directed acyclic graph of reach-avoid tasks..."
  - [section]: "Our method learns a policy along with a formal certificate which guarantees that a specification is satisfied with the desired probability. It consists of three key ingredients – (1) high-level planning on a directed acyclic graph (DAG) that decomposes the complex logical specification task into sequentially or disjunctively composed low-level reach-avoid tasks..."
  - [corpus]: Found 25 related papers; no direct evidence for DAG decomposition mechanism, but compositional learning is a common theme in 2 of 8 neighbors.
- Break condition: If the DAG contains cycles or if edge policies cannot be verified independently, the compositional guarantee fails.

### Mechanism 2
- Claim: Multiplicative RASMs provide exponentially tighter bounds on reach-avoidance probability compared to additive RASMs, crucial for complex specifications with many edges.
- Mechanism: The paper introduces multiplicative RASMs that require expected decrease by a multiplicative factor γ instead of an additive term. This leads to a bound of 1 - 1/λ · γ^N, which decays exponentially in N (number of steps), compared to the additive bound 1 - 1/λ.
- Core assumption: The Lipschitz continuity of the system dynamics and the RASM function allows bounding the number of steps N before reaching unsafe states.
- Evidence anchors:
  - [abstract]: "We also derive a tighter lower bound compared to previous work on the probability of reach-avoidance implied by a RASM, which is required to find a compositional policy with an acceptable probabilistic threshold for complex tasks with multiple edge policies."
  - [section]: "Our novel bound multiplies the bound of [68] by an exponential asymptotic decay term. This is particularly important when composing a large number of edge policies for complex objectives."
  - [corpus]: Weak evidence; no neighbor papers directly discuss RASM bounds, but stochastic control with safety guarantees is mentioned in 1 of 8 neighbors.
- Break condition: If the system dynamics are not Lipschitz continuous or if the bounded step property doesn't hold, the exponential bound may not apply.

### Mechanism 3
- Claim: The forward pass on the abstract graph with on-demand learning identifies necessary edge policies and accumulates probabilistic guarantees efficiently.
- Mechanism: Vertices are processed in topological order. For each vertex, only edges from predecessors with sufficient probability (Prob[v] ≥ p) are considered. Binary search finds the maximum probability for which POLICY+RASM can learn a valid policy. The accumulated probability Prob[vi] is updated as the maximum over incoming edges.
- Core assumption: SPECT RL's disjunctive structure means not all edges need to be learned if some paths already guarantee satisfaction with probability ≥ p.
- Evidence anchors:
  - [abstract]: "The formal guarantees are provided by learning neural network policies together with reach-avoid supermartingales (RASM) for the graph's sub-tasks and then composing them into a global policy."
  - [section]: "Algorithm 1 now initializes an empty dictionary Prob and sets Prob[s] = 1 for the source vertex s (line 5) and performs a forward pass to process the remaining vertices in the abstract graph according to the topological ordering (lines 6-13)."
  - [corpus]: No direct evidence; compositional learning is mentioned but not the specific forward pass mechanism in neighbor papers.
- Break condition: If the topological ordering is incorrect or if binary search precision is too low, necessary edge policies might be missed or unnecessary ones might be learned.

## Foundational Learning

- Concept: SPECT RL specification language
  - Why needed here: CLAPS specifically targets SPECT RL specifications, which allow sequential and disjunctive composition of reach-avoid tasks. Understanding this language is essential for grasping how specifications are decomposed.
  - Quick check question: What is the difference between "ϕ1; ϕ2" and "ϕ1 or ϕ2" in SPECT RL syntax?

- Concept: Reach-avoid supermartingales (RASMs)
  - Why needed here: RASMs are the core mathematical object that provides formal probabilistic guarantees for individual reach-avoid tasks. Both additive and multiplicative forms are discussed.
  - Quick check question: How does a multiplicative RASM differ from an additive RASM in terms of the expected decrease condition?

- Concept: Abstract graph construction from SPECT RL
  - Why needed here: The abstract graph is the bridge between high-level specifications and low-level control tasks. Understanding its construction is key to understanding the compositional approach.
  - Quick check question: In the abstract graph, what do vertices and edges represent in relation to the original SPECT RL specification?

## Architecture Onboarding

- Component map:
  - SPECT RL Parser -> Abstract Graph Builder -> Topological Sorter -> Forward Pass Engine -> POLICY+RASM Learner -> Verifier -> Policy Composer -> Binary Search Module

- Critical path:
  1. Parse SPECT RL → Abstract graph
  2. Topological sort vertices
  3. For each vertex in order:
     - Identify incoming edges from predecessors with Prob[v] ≥ p
     - For each such edge, use binary search with POLICY+RASM to find max probability
     - Update Prob[vi] = max over incoming edges of (edge_prob * predecessor_prob)
  4. If Prob[t] ≥ p, compose policies; else fail

- Design tradeoffs:
  - Precision vs. computation in binary search for edge probabilities
  - Mesh size in discretization for RASM verification (finer mesh = more accurate but slower)
  - Choice of λ initialization (1/(1-p')) vs. adaptive adjustment
  - Neural network architecture for policies and RASMs (capacity vs. verification tractability)

- Failure signatures:
  - Forward pass gets stuck (no predecessors with Prob[v] ≥ p for some vertex)
  - Binary search fails to find any valid probability for an edge
  - Verifier times out or rejects all learned RASMs for an edge
  - Composed policy violates safety during execution (shouldn't happen if guarantees hold)

- First 3 experiments:
  1. Single reach-avoid task: Verify CLAPS can learn a policy with RASM for a simple specification like "achieve p" where p is a predicate.
  2. Sequential composition: Test "ϕ1; ϕ2" where both ϕ1 and ϕ2 are simple reach-avoid tasks. Verify compositional guarantee holds.
  3. Disjunctive specification: Test "ϕ1 or ϕ2" where only one branch needs to be satisfied. Verify CLAPS learns only necessary policies and achieves p.

## Open Questions the Paper Calls Out

### Open Question 1
- Question: How does the performance of CLAPS scale with the size and complexity of the abstract graph generated from SPECT RL specifications?
- Basis in paper: [explicit] The paper mentions that CLAPS decomposes tasks into simpler reach-avoid tasks and composes policies, but does not provide a detailed analysis of how computational cost scales with graph size.
- Why unresolved: The paper focuses on demonstrating the effectiveness of CLAPS on a specific example but does not analyze the computational complexity or scalability of the approach.
- What evidence would resolve it: A detailed analysis of the computational cost of CLAPS as a function of the size and complexity of the abstract graph, including both theoretical analysis and empirical results on larger and more complex tasks.

### Open Question 2
- Question: Can CLAPS be extended to handle more expressive temporal logic specifications beyond SPECT RL, such as full LTL or other fragments of temporal logic?
- Basis in paper: [explicit] The paper acknowledges that CLAPS is only applicable to SPECT RL logical specifications and not to the whole of LTL, and mentions this as a limitation.
- Why unresolved: The paper does not provide a method or theoretical framework for extending CLAPS to handle more expressive temporal logic specifications.
- What evidence would resolve it: A demonstration of CLAPS being applied to tasks specified in full LTL or other temporal logic fragments, along with a theoretical analysis of the extension.

### Open Question 3
- Question: What are the practical limitations of the binary search procedure used in Algorithm 1 to find the maximal probability for which POLICY +RASM can learn a policy?
- Basis in paper: [explicit] The paper mentions that binary search is used to find the maximal probability for which POLICY +RASM can learn a policy, but does not discuss the practical limitations or convergence properties of this procedure.
- Why unresolved: The paper does not provide a detailed analysis of the binary search procedure, including its convergence properties or practical limitations in terms of computational cost or precision.
- What evidence would resolve it: An analysis of the convergence properties of the binary search procedure, including theoretical bounds on the number of iterations required and empirical results on the computational cost and precision achieved in practice.

## Limitations

- The approach is limited to SPECT RL specifications and cannot handle full LTL or more expressive temporal logics
- The exponential improvement in RASM bounds relies on Lipschitz continuity assumptions that may not hold in all real-world systems
- The compositional approach requires the specification to have a DAG structure, limiting applicability to specifications with cycles or complex dependencies

## Confidence

- High confidence: The compositional decomposition mechanism and forward pass algorithm are well-specified and theoretically sound. The abstract graph construction from SPECT RL is clearly defined.
- Medium confidence: The multiplicative RASM bound improvement and its exponential decay properties, while theoretically justified, require careful verification in practice.
- Medium confidence: The experimental results in Stochastic Nine Rooms demonstrate the approach's viability, but the simplified environment may not capture all real-world challenges.

## Next Checks

1. Verify the exponential decay of the multiplicative RASM bound experimentally by testing policies with varying numbers of edges and comparing against the additive bound.

2. Test CLAPS on specifications that require disjunctive composition to confirm that the forward pass correctly identifies and learns only necessary edge policies.

3. Implement a variant of CLAPS without the DAG constraint (allowing cycles) to empirically assess the importance of the acyclic structure assumption.