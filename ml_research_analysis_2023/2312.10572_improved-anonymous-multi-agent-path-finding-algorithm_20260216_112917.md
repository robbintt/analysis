---
ver: rpa2
title: Improved Anonymous Multi-Agent Path Finding Algorithm
arxiv_id: '2312.10572'
source_url: https://arxiv.org/abs/2312.10572
tags:
- search
- problem
- flow
- amapf
- network
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: This paper addresses the Anonymous Multi-Agent Path Finding (AMAPF)
  problem, where the goal is to find collision-free paths for a set of agents to reach
  specified goal locations with optimal makespan. The authors propose an improved
  solver that leverages a novel search algorithm called Bulk Search (BS).
---

# Improved Anonymous Multi-Agent Path Finding Algorithm

## Quick Facts
- arXiv ID: 2312.10572
- Source URL: https://arxiv.org/abs/2312.10572
- Reference count: 6
- One-line primary result: Proposes Bulk Search algorithm that solves all publicly available MAPF instances from MovingAI benchmark in less than 30 seconds

## Executive Summary
This paper addresses the Anonymous Multi-Agent Path Finding (AMAPF) problem by proposing an improved solver that leverages a novel search algorithm called Bulk Search (BS). The key innovation is to implicitly compress, store, and expand bulks of search states as single states, exploiting the special structure of the auxiliary graph used in the reduction to a maximum flow problem. This approach significantly reduces runtime and memory compared to expanding states individually, enabling the solver to outperform state-of-the-art competitors on publicly available benchmark instances.

## Method Summary
The proposed solver reduces AMAPF to a maximum flow problem on an auxiliary graph, then applies the Bulk Search algorithm to find collision-free paths efficiently. Bulk Search works by grouping nodes in connected-sequences and expanding them implicitly, ordering states by height to ensure lower-height states are expanded first. This exploits the periodic structure of the auxiliary graph to avoid redundant expansions, significantly reducing the search space. The number of connected-sequences is much smaller than the number of individual nodes, leading to substantial efficiency gains.

## Key Results
- Bulk Search (BS) algorithm reduces runtime and memory usage by implicitly expanding connected-sequences of states
- The solver outperforms state-of-the-art competitors, solving all publicly available MAPF instances from MovingAI benchmark in under 30 seconds
- The number of connected-sequences is much smaller than the size of the auxiliary graph, enabling efficient search

## Why This Works (Mechanism)

### Mechanism 1
- Claim: Bulk Search (BS) reduces the number of expanded states by grouping nodes in connected-sequences and expanding them implicitly.
- Mechanism: Instead of expanding individual nodes `(v, h)` in the auxiliary graph, BS expands a bulk `(v, [hmin, hmax])` that represents all nodes reachable via wait and restriction edges within the same connected-sequence. This exploits the periodic structure of the auxiliary graph to avoid redundant expansions.
- Core assumption: The auxiliary graph for AMAPF has a layered structure where nodes with the same vertex and consecutive heights form connected-sequences that can be traversed via wait and restriction edges without leaving the sequence.
- Evidence anchors:
  - [abstract] "we implicitly compress, store and expand bulks of the search states as single states"
  - [section] "The crux of this search method is the concept of bulk states and implicit expansions"
- Break condition: If the auxiliary graph structure changes such that connected-sequences no longer exist or are no longer traversable via wait/restriction edges, the bulk expansion optimization would fail.

### Mechanism 2
- Claim: BS orders states by height, ensuring that lower-height states are expanded first, which implicitly expands higher-height states in the same connected-sequence.
- Mechanism: By always expanding the state with minimum height first, BS ensures that when a state `(v, h)` is expanded, all states `(v, x)` with `x > h` in the same connected-sequence are implicitly considered expanded, avoiding their explicit expansion.
- Core assumption: The order of expansion matters for correctness and efficiency in the auxiliary graph search, and expanding lower-height states first covers all higher-height states in the same connected-sequence.
- Evidence anchors:
  - [section] "the order of the search states in the search set (OPEN) is determined by their heights, i.e. the states with the lower heights are expanded first"
- Break condition: If the search order is changed or if edge reversals introduce states with lower heights that bypass the connected-sequence, the implicit expansion guarantee may break.

### Mechanism 3
- Claim: The number of connected-sequences is much smaller than the number of individual nodes, leading to significant reduction in search space.
- Mechanism: Initially, there is one connected-sequence per vertex in the original graph. After each path is found, new connected-sequences appear, but their total number is still much less than the total number of nodes in the auxiliary graph. This reduces the number of expansions needed.
- Core assumption: The number of connected-sequences grows linearly with the number of agents and is much smaller than the quadratic growth of the auxiliary graph size.
- Evidence anchors:
  - [section] "the number of connected-sequences is much smaller than the size of the network"
  - [section] "Initially, we have a number of connected-sequences equals to the number of original graph vertices |V|"
- Break condition: If the auxiliary graph structure changes such that the number of connected-sequences becomes comparable to or larger than the number of nodes, the efficiency gain would diminish.

## Foundational Learning

- Concept: Network Flow and Maximum Flow Problem
  - Why needed here: AMAPF is reduced to a maximum flow problem on an auxiliary graph, and solving this flow problem efficiently is key to solving AMAPF.
  - Quick check question: What is the difference between a feasible flow and a maximum flow in a network?

- Concept: Graph Reduction and Auxiliary Graphs
  - Why needed here: Understanding how AMAPF is reduced to a maximum flow problem on an auxiliary graph is crucial for grasping the problem structure and the Bulk Search optimization.
  - Quick check question: How is the auxiliary graph constructed from the original AMAPF graph, and what do the nodes and edges represent?

- Concept: Connected-Sequences and Implicit State Expansion
  - Why needed here: The core optimization in Bulk Search relies on grouping nodes into connected-sequences and expanding them implicitly, which requires understanding this concept.
  - Quick check question: What is a connected-sequence in the context of the auxiliary graph, and how does Bulk Search use it to reduce expansions?

## Architecture Onboarding

- Component map:
  - AMAPF Solver -> Network Builder -> Bulk Search Algorithm -> Flow Solver -> Result Processor

- Critical path:
  1. Parse input AMAPF instance.
  2. Build auxiliary graph.
  3. Use Bulk Search to find maximum flow in the auxiliary graph.
  4. Extract paths from the flow solution.
  5. Output AMAPF plans.

- Design tradeoffs:
  - Space vs. Time: Bulk Search trades space for time by storing connected-sequences instead of individual nodes.
  - Completeness vs. Efficiency: Bulk Search maintains completeness while significantly improving efficiency over standard search.
  - Simplicity vs. Optimization: The Bulk Search algorithm is more complex than standard search but offers significant performance gains.

- Failure signatures:
  - Incorrect auxiliary graph construction: AMAPF plans may not be collision-free or may not reach all goals.
  - Bugs in Bulk Search implementation: The algorithm may not find the maximum flow or may produce incorrect results.
  - Memory issues: Storing large auxiliary graphs or connected-sequences may lead to out-of-memory errors.

- First 3 experiments:
  1. Test on small, known AMAPF instances with optimal solutions to verify correctness of the solver.
  2. Compare the number of expanded nodes and runtime of Bulk Search vs. standard search on larger instances to validate the efficiency gain.
  3. Test on instances with different graph topologies and numbers of agents to ensure the solver scales well.

## Open Questions the Paper Calls Out
None explicitly stated in the paper.

## Limitations
- The empirical validation is limited to a single benchmark dataset (MovingAI), which may not represent all possible graph structures and densities.
- The claim that "the number of connected-sequences is much smaller than the size of the network" is stated but not rigorously proven for all possible graph structures.
- The paper does not address how Bulk Search performs on graphs with different topologies or densities, which could significantly impact the efficiency gains.

## Confidence
- **High Confidence:** The correctness of the AMAPF problem reduction to maximum flow and the basic concept of Bulk Search are well-established in the literature. The claim that BS can solve all MovingAI instances in under 30 seconds is supported by experimental results.
- **Medium Confidence:** The efficiency claims regarding the reduction in expanded states and memory usage are plausible given the auxiliary graph structure, but require further validation across diverse graph types and sizes.
- **Low Confidence:** The claim that BS "always outperforms the state-of-the-art" is too strong without broader benchmarking across different AMAPF variants and solvers.

## Next Checks
1. **Cross-Benchmark Testing:** Evaluate BS on additional AMAPF benchmarks beyond MovingAI, including instances with varying graph densities and agent counts, to assess generalizability.

2. **Ablation Study on Connected-Sequences:** Systematically disable the connected-sequence optimization in BS and measure the impact on runtime and memory usage to quantify the contribution of this specific mechanism.

3. **Complexity Analysis:** Conduct a formal analysis of the time and space complexity of BS in terms of the number of vertices, edges, and agents, comparing it to the complexity of standard search algorithms in the auxiliary graph.