---
ver: rpa2
title: Online Learning under Adversarial Nonlinear Constraints
arxiv_id: '2306.03655'
source_url: https://arxiv.org/abs/2306.03655
tags:
- constraints
- online
- algorithm
- feasible
- regret
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: The paper proposes an online learning algorithm called CVV-Pro
  for adversarial time-varying nonlinear constraints. It achieves $\sqrt{T}$ regret
  and converges to the feasible set at a rate of $1/\sqrt{T}$, despite the fact that
  the feasible set is slowly time-varying and a priori unknown to the learner.
---

# Online Learning under Adversarial Nonlinear Constraints

## Quick Facts
- arXiv ID: 2306.03655
- Source URL: https://arxiv.org/abs/2306.03655
- Reference count: 40
- Primary result: Achieves $\sqrt{T}$ regret and converges to the feasible set at rate $1/\sqrt{T}$ under adversarial time-varying nonlinear constraints

## Executive Summary
This paper introduces CVV-Pro, an online learning algorithm for adversarial time-varying nonlinear constraints that achieves optimal regret while converging to feasibility. The algorithm constructs local sparse linear approximations of the feasible set using a velocity polytope and only requires a constraint violation oracle, avoiding expensive full-set projections. By allowing controlled constraint violations that decrease over time, CVV-Pro achieves $\sqrt{T}$ regret and $1/\sqrt{T}$ feasibility rates, with theoretical guarantees that hold for all $T \geq 1$.

## Method Summary
CVV-Pro maintains iterates within a bounded region by constructing velocity polytopes from locally sparse linear approximations of the feasible set. The algorithm queries a constraint violation oracle for currently violated constraints, builds a polytope containing all directions that preserve violation margins, and projects the cost gradient onto this polytope. Step sizes decay as $1/(\alpha\sqrt{t} + 15)$ to balance exploration and convergence, while an optional hypersphere constraint attracts iterates back when they drift too far.

## Key Results
- Achieves $\sqrt{T}$ regret and $1/\sqrt{T}$ feasibility convergence rate under adversarial time-varying nonlinear constraints
- Theoretical guarantees hold for all $T \geq 1$ without requiring prior knowledge of the feasible set
- Only requires a constraint violation oracle that returns partial information on currently violated constraints
- Evaluated on two-player games with shared constraints, showing empirical support for theoretical findings

## Why This Works (Mechanism)

### Mechanism 1
- Claim: The algorithm avoids optimizing over the entire feasible set by maintaining only a local sparse linear approximation via a velocity polytope.
- Mechanism: At each iteration, the algorithm queries a constraint violation oracle for only the currently violated constraints. It then constructs a velocity polytope containing all directions that preserve the violation margins. The cost gradient is projected onto this polytope, ensuring progress while avoiding full set projections.
- Core assumption: The feasible set changes slowly enough that local sparse approximations remain informative and guide the iterates toward feasibility over time.
- Evidence anchors:
  - [abstract] "CVV-Pro only relies on local sparse linear approximations of the feasible set and therefore avoids optimizing over the entire set at each iteration"
  - [section] "The indices of all violated constraints at xt will be captured by the index set I(xt) := {i ∈ { 1, . . . , m} | gt,i(xt) ≤ 0}"
- Break condition: If the feasible set changes too rapidly or if many constraints are active simultaneously, the local approximation may become too coarse to ensure convergence.

### Mechanism 2
- Claim: The algorithm achieves optimal regret by trading off feasibility for efficiency, allowing constraint violations that decrease over time.
- Mechanism: Instead of enforcing strict feasibility at every step, the algorithm permits bounded constraint violations. The step sizes are chosen to decrease over time, ensuring that cumulative constraint violations are controlled while still enabling fast regret minimization.
- Core assumption: The problem structure allows for temporary infeasibility as long as the average behavior converges to the feasible set.
- Evidence anchors:
  - [abstract] "achieves √T regret and converges to the feasible set at a rate of 1/√T"
  - [section] "our algorithm satisfies gt(xt) ≥ −c/√t for all iterations t ∈ {1, . . . , T}"
- Break condition: If the environment is adversarial and changes the constraints too aggressively, the controlled violation strategy may fail to ensure long-term feasibility.

### Mechanism 3
- Claim: The algorithm maintains iterates within a bounded region by introducing an attractive hypersphere constraint when needed.
- Mechanism: If the iterates drift outside a reference radius, an additional constraint gm+1(xt) = 1/2[R2 − ∥xt∥2] is added to the velocity polytope. This acts as a soft barrier, pulling iterates back toward the feasible region without requiring hard projections.
- Core assumption: The feasible set is contained within a known bounded region, and the algorithm can enforce this bound through the auxiliary constraint.
- Evidence anchors:
  - [section] "we introduce an additional hypersphere constraint gm+1(xt) = 1/2[R2 − ∥xt∥2] that attracts the decision sequence {xt}t≥1 to a hypersphere BR"
  - [section] "guarantees that it always stays inside a hypersphere B4R with a slightly larger radius"
- Break condition: If the feasible set extends beyond the assumed bounded region, the hypersphere constraint could become overly restrictive and degrade performance.

## Foundational Learning

- Concept: Online Convex Optimization (OCO) with adversarial constraints
  - Why needed here: The paper extends classical OCO by allowing the environment to choose both the cost functions and the constraints adversarially, which requires a more robust algorithmic framework.
  - Quick check question: In OCO, what is the difference between static and time-varying constraints, and why does time variation complicate regret analysis?

- Concept: Constraint Violation Oracles and Sparse Linear Approximations
  - Why needed here: Since the feasible set is unknown and revealed incrementally, the algorithm must rely on local information. Understanding how to construct and use sparse approximations is key to avoiding expensive full-set projections.
  - Quick check question: How does the velocity polytope Vα(xt) relate to the gradients of violated constraints, and why is this sufficient to guide progress toward feasibility?

- Concept: Analysis of Convergence Rates with Slowly Varying Constraints
  - Why needed here: The paper's regret and feasibility bounds depend on controlling how fast the constraints can change. Knowing how to quantify and bound this variation is essential for the theoretical guarantees.
  - Quick check question: What is the role of the decay rate ∥gt+1 − gt∥∞ = O(1/t) in ensuring that the algorithm can still achieve O(√T) regret despite adversarial changes?

## Architecture Onboarding

- Component map:
  - Constraint Violation Oracle -> Velocity Polytope Constructor -> Projection Solver -> Step Size Scheduler -> Update Rule

- Critical path:
  1. Query oracle for violated constraints at xt.
  2. Construct velocity polytope Vα(xt).
  3. Project −∇ft(xt) onto Vα(xt) to get vt.
  4. Update xt+1 = xt + ηtvt.
  5. Check feasibility; if needed, activate hypersphere attractor.

- Design tradeoffs:
  - Local vs. global feasibility: Allowing temporary infeasibility trades off strict feasibility for faster regret minimization.
  - Oracle frequency: Querying only violated constraints reduces overhead but may miss subtle constraint changes.
  - Step size decay: Slower decay improves regret but may slow convergence to feasibility.

- Failure signatures:
  - Persistent high constraint violation rates (>20%) indicate the local approximation is insufficient.
  - Iterates drifting outside the assumed bounded region suggest the hypersphere attractor is not strong enough.
  - Regret growing faster than O(√T) may signal overly aggressive constraint changes or poor projection quality.

- First 3 experiments:
  1. Run CVV-Pro on a simple 2D convex feasible set with known constraints; verify that it achieves O(√T) regret and converges to feasibility.
  2. Introduce time-varying constraints that change slowly (satisfying the decay rate) and check that the algorithm still performs as predicted.
  3. Test with a higher-dimensional problem where only a few constraints are active per iteration; measure runtime improvement over standard Online Gradient Descent.

## Open Questions the Paper Calls Out

### Open Question 1
- Question: How does the algorithm perform under constraints that are not only time-varying but also adversarial in nature, i.e., when the environment can choose both the objective functions and the constraints in a worst-case manner?
- Basis in paper: [explicit] The paper mentions that the algorithm achieves O(sqrt(T)) regret and O(1/sqrt(T)) feasibility rate under time-varying and adversarial constraints, but the experimental section only evaluates on a two-player game with shared constraints.
- Why unresolved: The paper does not provide experimental results for scenarios where the environment is fully adversarial in choosing both the objective functions and the constraints.
- What evidence would resolve it: Experimental results on problems with fully adversarial time-varying constraints would provide empirical support for the theoretical findings.

### Open Question 2
- Question: What is the impact of the choice of the parameter alpha on the algorithm's performance, especially in terms of regret and feasibility?
- Basis in paper: [inferred] The paper mentions that the algorithm's performance is affected by the choice of alpha, but it does not provide a detailed analysis of how different values of alpha impact the regret and feasibility bounds.
- Why unresolved: The paper only provides a theoretical analysis of the algorithm's performance for a specific choice of alpha, without exploring the sensitivity of the results to different values of this parameter.
- What evidence would resolve it: A sensitivity analysis of the algorithm's performance with respect to different values of alpha would help understand the trade-offs involved in choosing this parameter.

### Open Question 3
- Question: How does the algorithm scale with the number of constraints and the dimension of the decision variable?
- Basis in paper: [inferred] The paper mentions that the algorithm is computationally efficient and avoids optimizing over the entire feasible set, but it does not provide a detailed analysis of its computational complexity or how it scales with problem size.
- Why unresolved: The paper does not provide experimental results or theoretical bounds on the algorithm's computational complexity or how it scales with the number of constraints and the dimension of the decision variable.
- What evidence would resolve it: Experimental results on problems with varying numbers of constraints and dimensions would provide insights into the algorithm's scalability. Additionally, a theoretical analysis of the algorithm's computational complexity would help understand its limitations.

## Limitations
- The theoretical guarantees depend critically on the assumption that constraint changes are slow (∥gt+1 − gt∥∞ = O(1/t)), with no analysis of performance under faster-changing constraints
- The velocity polytope construction relies on local sparse approximations that may miss global structure in the feasible set, particularly for highly non-convex problems
- No detailed analysis of computational complexity or scaling with problem size (number of constraints and decision variable dimension)

## Confidence
- **Theoretical guarantees**: Medium - The analysis assumes slow constraint variation, which may not hold in practice
- **Algorithm design**: High - The local approximation approach is well-justified and avoids expensive full-set projections
- **Empirical validation**: Low - The paper only evaluates on two-player games with shared constraints, not fully adversarial scenarios

## Next Checks
1. Stress test CVV-Pro on scenarios where constraint changes exceed O(1/t) decay rates to identify failure modes.
2. Evaluate performance when the feasible set undergoes sharp structural changes rather than smooth variations.
3. Compare constraint violation patterns when using full vs. sparse oracle information to quantify the impact of local approximation quality.