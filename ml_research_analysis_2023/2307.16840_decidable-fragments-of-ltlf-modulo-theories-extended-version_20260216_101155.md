---
ver: rpa2
title: Decidable Fragments of LTLf Modulo Theories (Extended Version)
arxiv_id: '2307.16840'
source_url: https://arxiv.org/abs/2307.16840
tags:
- satis
- formula
- formulas
- ltlmt
- tableau
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: This paper studies Linear Temporal Logic Modulo Theories over Finite
  Traces (LTLfMT), an extension of LTL over finite traces where propositions are replaced
  by first-order formulas and variables referring to different time points can be
  compared. While LTLfMT is generally semi-decidable, the authors present a new pruning
  rule for the tableau-based semi-decision procedure that is sound and complete.
---

# Decidable Fragments of LTLf Modulo Theories (Extended Version)

## Quick Facts
- **arXiv ID**: 2307.16840
- **Source URL**: https://arxiv.org/abs/2307.16840
- **Reference count**: 40
- **Key outcome**: The authors present a pruning rule for tableau-based semi-decision procedures for LTLfMT that ensures termination for formulas with finite memory, enabling decidability results for several syntactic fragments.

## Executive Summary
This paper addresses the satisfiability problem for Linear Temporal Logic Modulo Theories over Finite Traces (LTLfMT), an extension of LTL over finite traces where propositions are replaced by first-order formulas. While LTLfMT is generally semi-decidable, the authors introduce a new pruning rule for the tableau-based semi-decision procedure that is sound and complete. They show that for formulas satisfying the semantic condition of "finite memory," the tableau with the pruning rule is guaranteed to terminate. This allows them to establish novel decidability results for several fragments of LTLfMT, such as formulas without cross-state comparisons, formulas using only certain temporal operators, bounded lookback formulas, and formulas over arithmetic theories with restricted first-order subformulas.

## Method Summary
The authors extend the tableau-based semi-decision procedure for LTLfMT by introducing a new pruning rule. This rule rejects branches where the history constraint of the current node is entailed by a previous node with the same label, ensuring no infinite expansion of equivalent branches. They define the semantic property of "finite memory" and prove that the tableau construction terminates whenever the LTLfMT formula satisfies this property. The authors then identify several syntactic fragments that have finite memory, such as formulas without cross-state comparisons, bounded lookback formulas, and quasi-MC/IPC formulas over arithmetic theories. They establish decidability results for these fragments by showing that they satisfy the finite memory condition.

## Key Results
- The tableau-based semi-decision procedure for LTLfMT can be made terminating for formulas with finite memory by using a new pruning rule.
- Several syntactic fragments of LTLfMT have finite memory and are therefore decidable, including formulas without cross-state comparisons, bounded lookback formulas, and quasi-MC/IPC formulas over arithmetic theories.
- The pruning rule is general and always applicable, which will ease implementation.

## Why This Works (Mechanism)

### Mechanism 1
- Claim: The tableau-based semi-decision procedure for LTLfMT can be made terminating for formulas with finite memory.
- Mechanism: The new pruning rule rejects branches where the history constraint of the current node is entailed by a previous node with the same label, ensuring no infinite expansion of equivalent branches.
- Core assumption: The tableau expansion rules are sound and complete, and entailment checking in the underlying theory T is decidable.
- Evidence anchors:
  - [abstract] "a sound and complete pruning rule for the LTLfMT tableau"
  - [section 3] "the tableau for an LTLf formulaφ is a rooted tree... If any is applicable, one of the expansion rules... is applied."
  - [corpus] Weak - related work focuses on synthesis and model checking, not tableau termination.
- Break condition: If entailment checking in T is undecidable, the pruning rule cannot be applied.

### Mechanism 2
- Claim: Several syntactic fragments of LTLfMT have finite memory and are therefore decidable.
- Mechanism: The bounded lookback condition ensures that dependency graphs of pre-models have limited path lengths, which bounds the number of distinct history constraints up to T-equivalence.
- Core assumption: The theory T has quantifier elimination, allowing history constraints to be reduced to equivalent formulas with bounded quantifier complexity.
- Evidence anchors:
  - [section 4] "bounded lookback formulas... generalize the above two by requiring that constraint interaction via V ⃝ and V ⃝ ∼ is restricted to finitely many configurations"
  - [section 4] "The tableau construction terminates whenever the LTLfMT formula satisfies the semantic property of finite memory"
  - [corpus] Weak - neighbors focus on synthesis and planning, not bounded lookback decidability.
- Break condition: If the bounded lookback condition is violated, the history set may become infinite.

### Mechanism 3
- Claim: The quasi-MC and quasi-IPC fragments are decidable due to quantifier elimination properties of arithmetic theories.
- Mechanism: For quasi-MC/IPC formulas, the history constraint can be expressed using only a bounded number of quantifiers after eliminating quantified variables from non-iteration conditions.
- Core assumption: The underlying arithmetic theory (LRA or LIA) has quantifier elimination that preserves the restriction to monotonicity or periodicity constraints.
- Evidence anchors:
  - [section 4] "MC formulas are important in BPM, as they can model decision tables" and "quasi-MC formulas... where all iteration conditions are MCs"
  - [section 4] "IPC formulas are known to be decidable [15, Thm. 3]" and "quasi-IPC formulas if all iteration conditions are IPCs"
  - [corpus] Weak - neighbors don't discuss quasi-MC or quasi-IPC decidability.
- Break condition: If iteration conditions contain non-monotonic or non-periodic constraints, the history set may become infinite.

## Foundational Learning

- Concept: Tableau-based semi-decision procedures for temporal logics
  - Why needed here: Understanding the basic tableau construction and expansion rules is crucial for implementing the pruning rule
  - Quick check question: What is the difference between the STEP rule and the termination rules in the LTLfMT tableau?

- Concept: Quantifier elimination in first-order theories
  - Why needed here: Quantifier elimination is used to show that certain fragments have finite memory by bounding the complexity of history constraints
  - Quick check question: How does quantifier elimination in LRA preserve the monotonicity constraint property?

- Concept: Dependency graphs and bounded lookback
  - Why needed here: Bounded lookback is a key syntactic condition that ensures finite memory by limiting the interaction between variables across time points
  - Quick check question: What is the relationship between the length of acyclic paths in the dependency graph and the bounded lookback parameter k?

## Architecture Onboarding

- Component map:
  - Tableau constructor: Builds the tree-shaped tableau by applying expansion rules
  - History constraint calculator: Computes the formula summarizing constraints along a branch
  - Entailment checker: Tests whether one history constraint entails another in theory T
  - Pruning rule applicator: Rejects branches where the pruning condition is satisfied

- Critical path:
  1. Expand a node using the expansion rules
  2. Check if the branch is poised (no more applicable expansion rules)
  3. Compute the history constraint for the poised node
  4. Check if the pruning rule applies by testing entailment
  5. If pruning applies, reject the branch; otherwise, apply the STEP rule
  6. Check termination rules (EMPTY or CONTRADICTION)

- Design tradeoffs:
  - Breadth-first vs depth-first tableau construction: Breadth-first ensures finding accepted branches if they exist, but may be memory-intensive
  - Eager vs lazy entailment checking: Eager checking may prune branches earlier but requires more computation per node
  - Theory-specific vs generic pruning: A generic pruning rule is always applicable but may be less effective than theory-specific optimizations

- Failure signatures:
  - Tableau construction doesn't terminate: The input formula likely doesn't have finite memory
  - Pruning rule incorrectly accepts a branch: The entailment check is buggy or the theory T is undecidable
  - Pruning rule incorrectly rejects a branch: The history constraint computation is incorrect or the tableau expansion rules are buggy

- First 3 experiments:
  1. Implement the tableau constructor with expansion rules and test on simple LTLfMT formulas without V ⃝ or V ⃝ ∼ (e.g., (x>y Ux+y = 2z) ∧ G(x+y>0))
  2. Add history constraint computation and pruning rule application, test on formulas with cross-state comparisons but bounded lookback (e.g., p(x, ⃝y) U (⃝x = x +y))
  3. Implement entailment checking for LRA and test on quasi-MC formulas (e.g., (⃝x>x ∧ ⃝ y>y ) U (x+y> 10))

## Open Questions the Paper Calls Out

- Can the PRUNE rule be efficiently implemented in SMT-based encodings for LTLfMT?
- Can the termination results for LTLfMT be extended to logics with time-varying relations?
- What is the computational complexity of the tableau-based decision procedures for the decidable fragments of LTLfMT?

## Limitations

- The pruning rule's applicability depends on the decidability of entailment checking in the underlying theory T.
- The finite memory condition, while theoretically sound, may be difficult to verify syntactically for complex formulas.
- The claim that the pruning rule is "always applicable" depends on the decidability of entailment in arbitrary theories T.

## Confidence

- **High**: The tableau construction rules and pruning mechanism are correctly specified for the general case.
- **Medium**: The termination proofs for bounded lookback and quasi-MC/IPC fragments, assuming quantifier elimination properties hold as stated.
- **Low**: The claim that the pruning rule is "always applicable" - this depends on the decidability of entailment in arbitrary theories T.

## Next Checks

1. Implement the tableau constructor and verify termination on a simple LTLfMT formula without cross-state comparisons, such as (x>y Ux+y = 2z) ∧ G(x+y>0).
2. Test the pruning rule on a formula with bounded lookback, e.g., p(x, ⃝y) U (⃝x = x +y), and verify that the tableau terminates.
3. Validate the quasi-MC fragment decidability by implementing entailment checking for LRA and testing on a formula like (⃝x>x ∧ ⃝ y>y ) U (x+y> 10).