---
ver: rpa2
title: 'MinePlanner: A Benchmark for Long-Horizon Planning in Large Minecraft Worlds'
arxiv_id: '2312.12891'
source_url: https://arxiv.org/abs/2312.12891
tags:
- agent
- planning
- medium
- hard
- easy
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: This paper introduces MinePlanner, a benchmark for long-horizon
  planning tasks in large Minecraft worlds. The framework automatically generates
  PDDL representations for Minecraft tasks, supporting both propositional and numeric
  planners.
---

# MinePlanner: A Benchmark for Long-Horizon Planning in Large Minecraft Worlds

## Quick Facts
- arXiv ID: 2312.12891
- Source URL: https://arxiv.org/abs/2312.12891
- Reference count: 33
- Tasks: 45 Minecraft planning tasks with thousands of objects

## Executive Summary
MinePlanner is a new benchmark for evaluating long-horizon planning algorithms in large, complex environments. The framework automatically generates PDDL representations of Minecraft tasks, allowing planners to operate without manual encoding. The benchmark includes 45 tasks of varying difficulty in worlds containing thousands of objects, stressing planner scalability and search capabilities. Experiments with state-of-the-art planners (Fast Downward and ENHSP-20) show that current approaches struggle with these complex domains, often failing to translate or ground problems within a 2-hour timeout.

## Method Summary
MinePlanner automatically generates PDDL representations for Minecraft tasks by parsing task specifications and constructing domain/problem files. The framework supports both propositional and numeric planners, representing world state using predicates or fluents. Tasks are specified in YAML format and include blocks, items, goals, and world configurations. The benchmark provides 45 tasks ranging from simple object manipulation to complex construction projects, with worlds containing thousands of objects to test planner scalability. Plan verification is performed by executing generated plans in actual Minecraft worlds using the MineDojo framework.

## Key Results
- Fast Downward and ENHSP-20 planners fail to translate or ground most problems within 2-hour timeout
- No planner successfully solved any of the hardest tasks involving complex construction
- Current planners struggle with object-dense environments containing thousands of irrelevant objects
- Plan verification in Minecraft confirms that generated plans achieve intended goals when successful

## Why This Works (Mechanism)

### Mechanism 1
- Claim: MinePlanner automatically generates PDDL representations for Minecraft tasks, allowing planners to operate without manual encoding.
- Mechanism: The framework parses task specifications (blocks, items, goals) and constructs PDDL domains using predicates and numeric fluents to represent world state, agent inventory, and goals.
- Core assumption: Minecraft worlds can be accurately abstracted into discrete, propositional states suitable for PDDL planners.
- Evidence anchors:
  - [abstract] "automatically generates PDDL representations for Minecraft tasks"
  - [section] "We define a task as a set of blocks and items... automatically generate a PDDL representation"
- Break condition: If Minecraft mechanics involve continuous or probabilistic effects not representable in PDDL, the abstraction will fail.

### Mechanism 2
- Claim: The benchmark's large, object-dense environments expose planner scalability limits.
- Mechanism: Tasks include thousands of objects with many irrelevant to the goal, stressing grounding and search procedures.
- Core assumption: Current planners' memory and time complexity scales poorly with object count.
- Evidence anchors:
  - [abstract] "scaling to instances with thousands of objects"
  - [section] "Current approaches struggle with these complex domains, often failing to translate or ground problems within a 2-hour timeout"
- Break condition: If planners adopt lifted representations or better grounding algorithms, they may overcome the bottleneck.

### Mechanism 3
- Claim: Supporting both propositional and numeric PDDL variants allows comparison of planning paradigms on the same tasks.
- Mechanism: Two state representations are provided—predicates for propositional planners, fluents for numeric planners—enabling fair benchmarking.
- Core assumption: Task complexity is invariant across representation styles; differences reflect planner capability, not problem structure.
- Evidence anchors:
  - [section] "supports both propositional and numeric planners"
  - [section] "The difference between the two is primarily how locations are represented"
- Break condition: If numeric features (e.g., quantities) are essential to task solvability, propositional encoding may artificially simplify problems.

## Foundational Learning

- Concept: PDDL (Planning Domain Definition Language)
  - Why needed here: PDDL is the input language for classical planners; understanding its syntax is essential to interpret MinePlanner outputs.
  - Quick check question: What is the difference between predicates and fluents in PDDL 2.1?

- Concept: Classical planning vs. reinforcement learning
  - Why needed here: MinePlanner abstracts away low-level control to focus on high-level planning; knowing this distinction clarifies the benchmark's purpose.
  - Quick check question: Why does MinePlanner remove tools and drop mechanics from vanilla Minecraft?

- Concept: Grounding and translation in planning
  - Why needed here: Failures in these steps dominate runtime in MinePlanner experiments; understanding them helps diagnose planner bottlenecks.
  - Quick check question: What causes a planner to time out during grounding versus search?

## Architecture Onboarding

- Component map: YAML task spec → Minecraft world generation → Object extraction → PDDL domain/problem generation → Planner execution → Plan verification in Minecraft
- Critical path: Task spec → PDDL generation → Planner input → Plan output → Verification
- Design tradeoffs: Object-dense worlds stress planners but may be unrealistic; simplified mechanics ease PDDL encoding but reduce fidelity
- Failure signatures: Memory exhaustion during grounding → object count too high; timeout during translation → SAS conversion complexity; plan failure → goal unreachable under abstraction
- First 3 experiments:
  1. Run Fast Downward on the easy "move" task; observe translation time and check SAS file size
  2. Run ENHSP-20 on the easy "pickup diamond" task; record grounding time and memory usage
  3. Execute a verified plan in Minecraft using the visualization tool; confirm goal state

## Open Questions the Paper Calls Out

### Open Question 1
- Question: What is the computational complexity of grounding and translating PDDL representations for object-dense domains like those in MinePlanner?
- Basis in paper: [explicit] The paper shows that state-of-the-art planners struggle with large Minecraft worlds containing thousands of objects, with Fast Downward failing to translate most problems due to memory constraints.
- Why unresolved: The paper demonstrates the problem but doesn't analyze the theoretical complexity or identify specific bottlenecks in the grounding/translating process.
- What evidence would resolve it: Detailed analysis of the computational complexity of grounding/translating algorithms, identification of specific operations that cause exponential growth, and comparison with complexity bounds for object-dense domains.

### Open Question 2
- Question: Can hierarchical planning approaches effectively decompose large Minecraft construction tasks into manageable subtasks?
- Basis in paper: [explicit] The paper mentions that Minecraft has an inherent hierarchy in building large structures, which may be of interest to hierarchical planners, but doesn't evaluate such approaches.
- Why unresolved: The benchmark focuses on flat planning representations and doesn't test hierarchical planning algorithms or evaluate how well they handle the decomposition of complex construction tasks.
- What evidence would resolve it: Experiments comparing hierarchical planners with flat planners on MinePlanner tasks, analysis of decomposition quality, and evaluation of whether hierarchical approaches can solve tasks that flat planners cannot.

### Open Question 3
- Question: How does the presence of irrelevant objects in Minecraft worlds affect planner performance, and can planners be made robust to such noise?
- Basis in paper: [explicit] The paper identifies that current planners struggle with domains containing many objects that may or may not be relevant to the task, and mentions that learned PDDL representations often contain irrelevant symbols.
- Why unresolved: While the benchmark includes tasks with irrelevant objects, the paper doesn't analyze how planner performance degrades with increasing irrelevant objects or test approaches specifically designed to handle such noise.
- What evidence would resolve it: Systematic experiments varying the ratio of relevant to irrelevant objects, comparison of planners with and without noise-robust mechanisms, and analysis of performance degradation as irrelevant object count increases.

## Limitations

- The benchmark uses simplified Minecraft mechanics, removing tools and drop mechanics present in vanilla Minecraft
- Only evaluates two specific planners (Fast Downward and ENHSP-20), limiting generalizability of results
- Does not analyze whether failure modes are due to representation inefficiency or fundamental planner limitations

## Confidence

- **High confidence**: MinePlanner successfully generates PDDL representations for Minecraft tasks and provides a challenging benchmark suite
- **Medium confidence**: Current state-of-the-art planners struggle with large object-dense environments as claimed
- **Low confidence**: The claim that differences between propositional and numeric planner performance reflect algorithmic capability rather than representation artifacts

## Next Checks

1. **Error analysis**: For each failed task, categorize failures (translation timeout, grounding timeout, search timeout, plan verification failure) to identify the bottleneck type
2. **Representation fidelity test**: Solve the same tasks using both PDDL variants and measure whether the distribution of solvable instances differs significantly
3. **Scalability analysis**: Generate tasks with controlled object counts (100, 500, 1000, 2000 objects) to empirically determine the scaling relationship between world size and planner performance