---
ver: rpa2
title: 'CaMeLs Can Use Computers Too: System-level Security for Computer Use Agents'
arxiv_id: '2601.09923'
source_url: https://arxiv.org/abs/2601.09923
tags:
- search
- attack
- plan
- security
- tasks
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: This paper introduces Single-Shot Planning for Computer Use Agents
  (CUAs), a secure architecture that resolves the tension between strict control flow
  isolation and the dynamic requirements of GUI automation. By generating complete
  execution graphs with conditional branches before observing untrusted content, it
  provides formal Control Flow Integrity guarantees against arbitrary instruction
  injections while retaining up to 57% performance of frontier models on OSWorld.
---

# CaMeLs Can Use Computers Too: System-level Security for Computer Use Agents

## Quick Facts
- arXiv ID: 2601.09923
- Source URL: https://arxiv.org/abs/2601.09923
- Reference count: 40
- Key outcome: Single-Shot Planning for CUAs provides CFI guarantees against instruction injections while retaining up to 57% performance, addressing Branch Steering attacks through redundancy-based defenses.

## Executive Summary
This paper addresses critical security vulnerabilities in Computer Use Agents (CUAs) by introducing Single-Shot Planning, a system-level architecture that resolves the tension between strict control flow isolation and dynamic GUI automation requirements. The approach generates complete execution graphs with conditional branches before observing untrusted visual content, providing formal Control Flow Integrity guarantees against arbitrary instruction injections. By identifying and mitigating Branch Steering attacks—where adversaries manipulate visual cues to trigger unintended valid paths—the architecture enables secure local deployment of open-source models while maintaining significant utility improvements, particularly for smaller models (up to 19% performance gains).

## Method Summary
The authors propose Single-Shot Planning as a secure architecture for CUAs that fundamentally changes how these agents interact with untrusted GUI environments. Instead of the traditional iterative approach where agents observe content and then decide actions, Single-Shot Planning requires the model to generate a complete execution graph—including all conditional branches—before receiving any untrusted visual input. This pre-generation ensures that the control flow remains isolated from potentially malicious content. The execution graph is then validated against a whitelist of allowed instruction types before any untrusted content is observed, providing formal Control Flow Integrity guarantees. To address the identified Branch Steering vulnerability, where attackers can manipulate visual cues to trigger unintended but valid paths, the authors implement redundancy-based defenses that cross-validate observations across multiple contexts.

## Key Results
- Single-Shot Planning achieves up to 57% of frontier model performance on OSWorld benchmarks while providing CFI guarantees
- Smaller models show up to 19% utility improvements when using Single-Shot Planning compared to baseline approaches
- The redundancy-based defenses reduce Branch Steering attack success while maintaining usability with minimal false positives
- Local deployment of open-source models becomes feasible with only minimal performance degradation compared to larger models

## Why This Works (Mechanism)
The approach works by fundamentally restructuring the interaction pattern between CUAs and untrusted environments. By requiring complete plan generation before observation, it breaks the causal link between malicious content and control flow decisions. The execution graph acts as a secure template that constrains all subsequent interactions, while the pre-validation against whitelisted instruction types ensures only safe operations are permitted. The redundancy mechanism works by requiring consistent observations across multiple contexts before executing conditional branches, making it significantly harder for attackers to manipulate visual cues without detection.

## Foundational Learning
- **Control Flow Integrity (CFI)**: Why needed - prevents arbitrary code execution by ensuring only legitimate control transfers occur; Quick check - verify that all branch targets are pre-approved and whitelisted before execution.
- **GUI Automation Security**: Why needed - traditional CUAs are vulnerable to instruction injection through manipulated visual content; Quick check - confirm that no decision-making occurs after observing untrusted content.
- **Branch Steering Attacks**: Why needed - adversaries can exploit visual ambiguity to trigger unintended but valid execution paths; Quick check - test whether redundant observations across contexts can detect inconsistent visual cues.
- **Execution Graph Generation**: Why needed - provides a complete, validated plan before any untrusted interaction occurs; Quick check - ensure all conditional branches are generated and validated before observation begins.
- **Whitelist Validation**: Why needed - constrains the agent to only perform approved operations regardless of visual input; Quick check - verify that the whitelist comprehensively covers all safe operations while excluding dangerous ones.

## Architecture Onboarding

**Component Map**: Model -> Execution Graph Generator -> Whitelist Validator -> GUI Executor -> Visual Observer

**Critical Path**: The security-critical path runs through Execution Graph Generator -> Whitelist Validator -> GUI Executor, with Visual Observer positioned only after validation is complete. This ensures that no untrusted content can influence control flow decisions.

**Design Tradeoffs**: The architecture trades off some performance (57% of frontier models) for security guarantees. The pre-generation requirement adds computational overhead but eliminates the need for iterative observation-action cycles. The whitelist approach may reject some legitimate complex operations that aren't pre-approved.

**Failure Signatures**: Failures typically manifest as either false positives (legitimate operations rejected by whitelist) or false negatives (attackers finding ways to manipulate visual cues that pass redundancy checks). The 4% false positive rate mentioned suggests some operational friction, though the paper doesn't extensively characterize this impact.

**3 First Experiments**: 1) Test Single-Shot Planning on a simple GUI task to verify basic functionality without security features. 2) Evaluate the redundancy mechanism by introducing controlled visual ambiguities to measure detection rates. 3) Compare performance between different model sizes (1B, 8B, 70B) to understand the scalability of security guarantees.

## Open Questions the Paper Calls Out
The paper acknowledges that Branch Steering attacks remain possible even with redundancy-based defenses, though it doesn't provide comprehensive quantification of the residual attack surface. The authors suggest that more sophisticated visual manipulation techniques could potentially bypass current defenses, indicating the need for ongoing research into more robust visual validation mechanisms. Additionally, the performance trade-offs across different model architectures and sizes warrant further systematic exploration to optimize the security-utility balance.

## Limitations
- Evaluation primarily focused on OSWorld benchmarks, limiting generalizability to diverse real-world GUI environments
- Branch Steering attacks remain possible despite redundancy defenses, with unclear quantification of residual vulnerabilities
- Performance claims about "minimal loss" for local deployment are somewhat misleading given 2-3x advantage retained by larger models
- Limited analysis of false positive rates and their impact on usability, with only brief mention of 4% false positive rate

## Confidence

**High Confidence**: The core technical contribution of generating complete execution graphs before observing untrusted content is sound and well-explained. The demonstration that Single-Shot Planning can provide CFI guarantees is convincing.

**Medium Confidence**: The security guarantees against arbitrary instruction injections appear robust, but the analysis of residual vulnerabilities from Branch Steering attacks lacks quantitative depth. The performance metrics are well-measured but may not generalize beyond the tested scenarios.

**Low Confidence**: Claims about the practical effectiveness of the redundancy-based defenses against Branch Steering require more rigorous validation across diverse attack scenarios.

## Next Checks
1. **Cross-platform generalization**: Test Single-Shot Planning across diverse GUI frameworks (web applications, desktop software, mobile interfaces) to assess robustness beyond OSWorld's controlled environment.

2. **Branch Steering resilience quantification**: Systematically measure the success rate of various Branch Steering attacks against the redundancy-based defenses across different levels of visual ambiguity.

3. **Scalability analysis**: Evaluate the approach's performance and security guarantees across a broader range of model sizes (from 1B to 70B parameters) and architectures to understand the full trade-off space.