---
ver: rpa2
title: 'BPMN to PDDL: Translating Business Workflows for AI Planning'
arxiv_id: '2511.18171'
source_url: https://arxiv.org/abs/2511.18171
tags:
- bpmn
- flows
- planning
- process
- pddl
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: This project develops a functional pipeline that translates BPMN
  2.0 diagrams into PDDL representations for automated planning. The system parses
  BPMN XML files to extract tasks, events, gateways, sequence flows, and message flows,
  then constructs a control-flow graph and generates corresponding PDDL domains and
  problems.
---

# BPMN to PDDL: Translating Business Workflows for AI Planning

## Quick Facts
- **arXiv ID**: 2511.18171
- **Source URL**: https://arxiv.org/abs/2511.18171
- **Reference count**: 4
- **Primary result**: Functional pipeline translating BPMN 2.0 diagrams into PDDL for automated planning

## Executive Summary
This work presents a complete pipeline for converting BPMN 2.0 business process diagrams into PDDL representations that can be executed by automated planners. The system parses BPMN XML files to extract control flow elements, builds a dependency graph, and generates corresponding PDDL domains and problems. By leveraging FOND planning with non-deterministic constructs, it can handle branching logic in BPMN gateways while preserving process semantics. The approach successfully generates valid execution traces across multiple test cases, bridging the gap between descriptive business models and executable AI planning systems.

## Method Summary
The translation pipeline operates by first parsing BPMN 2.0 XML files using Python's xml.etree.ElementTree to extract tasks, events, gateways, sequence flows, and message flows. It constructs a control-flow graph from these elements, handling synthetic sequence flows for message interactions between pools. BPMN elements are then mapped to PDDL constructs: tasks become actions with preconditions and effects, events become predicates, and gateways are encoded using conditional logic or non-deterministic `oneof` constructs. Parallel gateways activate all branches simultaneously with join synchronization, inclusive gateways use branch counters, and exclusive gateways employ mutually exclusive effects. The generated PDDL domains and problems are executed by a FOND planner (PR2) to produce valid execution traces that preserve BPMN semantics.

## Key Results
- Translation completes in under one second for all test cases
- Generated PDDL models are syntactically correct and accepted by standard FOND planners
- Valid execution traces reflect original BPMN workflow semantics
- Successfully handles parallel and inclusive gateway behaviors through specialized PDDL encodings

## Why This Works (Mechanism)

### Mechanism 1
- **Claim:** Transforming static BPMN visual flows into state-predicate models allows automated reasoners to simulate process execution dynamically.
- **Mechanism:** The system parses BPMN XML into a Control-Flow Graph (CFG), mapping tasks and events to boolean predicates representing "active" states. Sequence flows become causal links through action preconditions and effects, creating a traversable state space for planners.
- **Core assumption:** BPMN diagrams can be faithfully represented using STRIPS-like predicates without complex external data state or resource modeling.
- **Evidence anchors:** Abstract mentions constructing CFG and generating PDDL domains with PR2 planner producing valid traces; section 3.1 explains tasks as executable units with sequence flows as causal dependencies.
- **Break condition:** If processes rely on data objects or resource constraints (currently unimplemented), generated plans will be syntactically valid but semantically insufficient.

### Mechanism 2
- **Claim:** FOND planning encodings capture branching semantics of inclusive and event-based gateways better than deterministic planning.
- **Mechanism:** Exclusive and event-based gateways translate to non-deterministic `oneof` effects, encoding uncertainty about runtime events. PR2 generates policies that work regardless of which branch is taken, verifying process resilience.
- **Core assumption:** Planners can handle `oneof` constructs efficiently and soundness equates to existence of strong cyclic plans.
- **Evidence anchors:** Section 3.2 describes inclusive gateway PDDL using markers for active branches; section 4.2 abstracts timeout handling as non-deterministic event arrival.
- **Break condition:** Complex active branch counting may cause state explosion, preventing planner convergence.

### Mechanism 3
- **Claim:** Synthesizing sequence flows from message flows coordinates separate process pools within single planning domain.
- **Mechanism:** Message flows between pools convert to synthetic sequence flows or explicit synchronization actions, forcing planners to respect causal ordering while treating multi-participant diagrams as integrated transition systems.
- **Core assumption:** Message flows imply strict causal dependencies modelable like control flows without requiring message content modeling.
- **Evidence anchors:** Section 4.2 explains cross-participant message flows converted to synthetic sequence flows; section 6.1 notes current treatment of message flows between tasks as exclusive gateways.
- **Break condition:** Current approach forces sequential execution where concurrent behavior might be intended, as noted in "Message Flow Problem."

## Foundational Learning

- **Concept:** **FOND Planning (Fully Observable Non-Deterministic)**
  - **Why needed here:** Classical planners assume deterministic outcomes, but BPMN gateways depend on external factors. FOND planning models these as `oneof` outcomes, creating robust policies rather than brittle linear plans.
  - **Quick check question:** If an action has two possible outcomes, does the generated plan account for *both* eventualities, or does it commit to just one?

- **Concept:** **BPMN 2.0 Semantics (specifically Gateways)**
  - **Why needed here:** Translation accuracy depends on mapping XOR, OR, and AND gateway logic to PDDL. Understanding that Inclusive Gateways require "synchronization" (waiting for all *active* branches) is critical for implementing the counter mechanism.
  - **Quick check question:** How does a Parallel Gateway (AND) differ from an Inclusive Gateway (OR) in terms of how many incoming branches must complete before the process continues?

- **Concept:** **State-Space Search vs. Control Flow**
  - **Why needed here:** Business analysts think in "flow charts" while planners think in "states." A "Sequence Flow" becomes a logical implication: "If Task A is active, execute Task A to make Task B active."
  - **Quick check question:** In generated PDDL, does a "Sequence Flow" arrow become a specific action, or define preconditions/effects of existing actions?

## Architecture Onboarding

- **Component map:** BPMN XML file -> Python Parser -> Dependency Builder -> PDDL Generator -> PDDL domain/problem files -> FOND Planner (PR2) -> Execution trace

- **Critical path:** Gateway Translation Logic (Section 3.2) where complexity lies. Parallel gateways must activate all branches and wait for all at join; inclusive gateways must track active branch counts. Errors here cause deadlocks or race conditions.

- **Design tradeoffs:**
  - Message Flow Fidelity: Treats Task-to-Task messages as exclusive choices, forcing sequential behavior rather than preserving real-world parallelism
  - Event Abstraction: Complex timer/signal events abstracted into non-deterministic choices, ignoring specific temporal constraints in favor of logical possibilities

- **Failure signatures:**
  - "Deadlock" Trace: Plan reaches state where no actions possible but goal `(done)` not reached, often from incorrect Inclusive Gateway counters
  - Syntax Errors: Planner rejects domain file, usually from parsing obscure BPMN elements like Subprocesses
  - Sequentialization of Parallel Tasks: Processes that should run concurrently execute strictly sequentially, indicating "Message Flow Problem"

- **First 3 experiments:**
  1. **Sanity Check (Linear Flow):** Create BPMN with Start -> Task A -> Task B -> End. Verify PDDL domain contains exactly one action with preconditions linking Start to B.
  2. **Branching Stress Test:** Run "Credit Scoring" example. Inspect generated policy to ensure separate paths for "Loan Approved" vs. "Loan Rejected," verifying `oneof` mechanism.
  3. **Break the Sync:** Modify diagram with Inclusive Gateway where only 1 of 3 branches taken. Verify converging gateway logic doesn't wait indefinitely for inactive branches.

## Open Questions the Paper Calls Out

### Open Question 1
- **Question:** How can message flows between tasks be represented in PDDL to preserve parallel execution semantics without relying on artificial convergence nodes?
- **Basis in paper:** Section 6.1 identifies "The Message Flow Problem," stating that treating message flows as exclusive gateways "does not fully preserve their intended semantics."
- **Why unresolved:** Current workaround forces branching via non-determinism, but message flows lack explicit converging gateways needed to synchronize parallel paths correctly.
- **Evidence:** A translation scheme where distinct pools execute concurrently with proper synchronization upon message reception, verified by FOND planner generating valid parallel traces.

### Open Question 2
- **Question:** How can complex BPMN constructs such as subprocesses, data objects, and compensation mechanisms be effectively mapped to PDDL?
- **Basis in paper:** Section 6.2 lists these elements as "unimplemented," noting they require specialized handling to preserve BPMN semantics.
- **Why unresolved:** These constructs introduce asynchronous behaviors and contextual dependencies that control-flow-centric pipeline cannot process.
- **Evidence:** Successful translation of BPMN diagram containing nested subprocesses or data associations into syntactically correct and executable PDDL domain.

### Open Question 3
- **Question:** How can the translation pipeline be extended to model data flow and resource allocation in addition to control flow?
- **Basis in paper:** Section 6.2 states parser currently focuses on control-flow semantics, leaving aspects like message correlation and resource allocation "simplified or omitted."
- **Why unresolved:** Current implementation relies on boolean predicates for task activation but lacks state variables to track data values or resource constraints.
- **Evidence:** Generated PDDL domains including typed objects and numerical fluents representing data states or resource availability that actively constrain planner's action selection.

## Limitations
- Cannot handle subprocesses, data objects, or compensation mechanisms (explicitly unimplemented)
- Message flows between tasks forced into sequential execution rather than preserving parallel semantics
- Lacks modeling of data states, timing constraints, or resource availability beyond control flow

## Confidence
- **High:** Basic BPMN 2.0 control flow with parallel and exclusive gateways (successful test cases within one-second threshold)
- **Medium:** Inclusive gateway handling and message flow coordination (issues with "Message Flow Problem")
- **Low:** General applicability for complex BPMN diagrams with subprocesses, data objects, or resource constraints (explicitly unimplemented limitations)

## Next Checks
1. **Deadlock Detection Test:** Create BPMN with inclusive gateway where only one of three parallel branches is taken; verify generated PDDL correctly decrements active branch counter so join doesn't wait indefinitely for inactive branches.

2. **Message Flow Parallelism Test:** Construct two separate pools with task-to-task message flow that should execute concurrently; compare planner's execution trace against expected parallel behavior to quantify sequentialization error.

3. **FOND Policy Robustness Test:** Run credit_scoring.bpmn example through planner multiple times, capturing generated policy to verify it contains distinct execution paths for both loan approval and rejection outcomes, confirming `oneof` construct creates valid non-deterministic policy.