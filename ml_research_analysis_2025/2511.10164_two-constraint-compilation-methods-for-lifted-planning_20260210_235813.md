---
ver: rpa2
title: Two Constraint Compilation Methods for Lifted Planning
arxiv_id: '2511.10164'
source_url: https://arxiv.org/abs/2511.10164
tags:
- constraints
- problem
- planning
- liftedtcore
- which
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: "This paper addresses the scalability challenge of compiling PDDL\
  \ constraints by proposing two lifted compilation methods\u2014LiftedTCORE and LCC\u2014\
  that avoid grounding the problem. LiftedTCORE uses a lifted regression operator,\
  \ while LCC monitors constraints with a 1-step delay without regression."
---

# Two Constraint Compilation Methods for Lifted Planning

## Quick Facts
- arXiv ID: 2511.10164
- Source URL: https://arxiv.org/abs/2511.10164
- Reference count: 24
- Primary result: LiftedTCORE and LCC compilers avoid grounding, producing orders-of-magnitude more succinct compiled specifications and solving 246/280 instances on challenging IPC domains.

## Executive Summary
This paper addresses the scalability challenge of compiling PDDL constraints by proposing two lifted compilation methods—LiftedTCORE and LCC—that avoid grounding the problem. LiftedTCORE uses a lifted regression operator, while LCC monitors constraints with a 1-step delay without regression. Both compilers produce significantly more succinct compiled specifications (orders of magnitude fewer actions/effects) compared to ground-based TCORE. Empirical evaluation on challenging IPC domains shows LCC achieves best coverage (246/280 instances), with LiftedTCORE competitive despite slower planning on quantified constraints. The methods are correct, run in polynomial time, and demonstrate that lifted compilation is viable for large-scale planning with constraints.

## Method Summary
The paper introduces two methods for compiling PDDL qualitative state-trajectory constraints into classical planning problems without grounding. LiftedTCORE computes a lifted regression operator to determine weakest preconditions at the unground level, adding constraint-monitoring preconditions/effects only to actions that can affect each constraint. LCC adds universal constraint-monitoring preconditions and effects to all actions with a 1-step delay, plus a terminal "fin" action to check goal-state constraints. Both methods avoid the exponential blowup of grounding-based compilation, producing more compact specifications while maintaining correctness guarantees.

## Key Results
- LCC solves 246/280 instances, achieving best coverage among evaluated methods
- LiftedTCORE produces more compact compiled problems (7 actions/58 effects avg) than LCC (8 actions/63 effects avg)
- Both lifted compilers generate orders-of-magnitude fewer actions/effects compared to ground-based TCORE (21K/95K avg)
- LiftedTCORE is slower on quantified constraints but handles them correctly where LCC cannot

## Why This Works (Mechanism)

### Mechanism 1: Lifted Regression Avoids Instantiation Explosion
Computing regression at the lifted (unground) level produces equivalent constraint monitoring without enumerating all action-object combinations. The lifted regression operator R^L(φ,a) computes the weakest precondition for φ to hold after action a by unifying literals with effects via most general unifiers (MGU), introducing equality constraints rather than grounding. Core assumption: The planning domain has bounded quantifier nesting depth in constraints; otherwise, initial-state model checking becomes PSPACE-complete.

### Mechanism 2: Delayed Monitoring with Universal Preconditions (LCC)
Adding the same constraint-monitoring preconditions/effects to all actions, plus a terminal "fin" action, correctly captures constraint semantics with linear compilation time. LCC adds monitoring atoms and universal preconditions P and effects E to every action. Constraint violations are detected post-hoc: if action a in state s leads to violation, subsequent actions are blocked. The fin action verifies goal-state constraints before termination.

### Mechanism 3: Succinctness via Action-Specific vs. Action-Agnostic Compilation
LiftedTCORE produces more compact compiled problems by adding preconditions/effects only to actions that can affect each constraint; LCC trades succinctness for simpler compilation. LiftedTCORE checks if R^L(φ,a) differs from φ before adding monitoring; if R^L(φ,a)=φ, the action cannot affect constraint satisfaction and is skipped. LCC adds P and E to all actions indiscriminately.

## Foundational Learning

- **Concept: Regression in Planning**
  - Why needed here: Both LiftedTCORE and ground TCORE rely on computing weakest preconditions—understanding regression is prerequisite to understanding why lifted regression avoids grounding.
  - Quick check question: Given action `putdown(b)` with effect `onTable(b)`, what is the regression of formula `onTable(b1)` through this action?

- **Concept: Most General Unifier (MGU) and Substitution**
  - Why needed here: Lifted regression uses MGU to unify literals with effects without grounding; z-substitution handles universally quantified effect variables.
  - Quick check question: What is the MGU of `clear(b5)` and `clear(topb)`? What substitution does it induce?

- **Concept: PDDL State-Trajectory Constraints (A, ST, AO, SB, SA)**
  - Why needed here: The entire compilation targets these five constraint types; each requires different monitoring atom patterns.
  - Quick check question: For constraint `SometimeBefore(φ, ψ)`, what monitoring atom must be true before φ can hold?

## Architecture Onboarding

- Component map:
Input PDDL (domain + problem with constraints C)
         │
         ├─► LiftedTCORE path:
         │   ├─ Lifted Regression R^L(φ,a) for each (constraint formula φ, action a)
         │   ├─ Action-specific precondition/effect augmentation
         │   └─ Output: Compiled PDDL (no C, new monitoring atoms)
         │
         └─► LCC path:
             ├─ Universal precondition set P and effect set E
             ├─ Add P∧¬end, E to all actions; add fin action
             └─ Output: Compiled PDDL (no C, new monitoring atoms, fin action)

- Critical path:
  1. Parse PDDL domain/problem; extract constraints C.
  2. For each constraint type, determine monitoring atoms needed.
  3. (LiftedTCORE) For each action a and constraint formula φ: compute R^L(φ,a), add to Pre(a) or Eff(a) per Algorithm 1.
  4. (LCC) Compute universal P and E per Algorithm 2; augment all actions; add fin.
  5. Update initial state and goal with monitoring atoms.
  6. Output constraint-free PDDL; invoke standard planner (e.g., LAMA).

- Design tradeoffs:
  - **LiftedTCORE**: Tighter constraint monitoring (no delay), fewer node expansions, but O(n_c·n_a·n_f²·n_k) complexity and complex preconditions hinder some planners.
  - **LCC**: O(n_a + n_c) linear complexity, simpler implementation, but 1-step delay and larger preconditions may increase search nodes.
  - Both avoid grounding explosion; choice depends on constraint density and planner capability with complex formulas.

- Failure signatures:
  - **LiftedTCORE slow on non-ground constraints**: Large regression formulas (avg 26 atoms vs. LCC's 18) cause planner preprocessing slowdown.
  - **LCC expands more nodes**: Delayed monitoring allows exploration of states that will be pruned later.
  - **Both fail on many-constraint problems**: Lifted methods update all lifted actions affecting a constraint, producing dense preconditions; TCORE's sparse ground updates may work better.

- First 3 experiments:
  1. **Reproduction on single IPC domain**: Take one domain (e.g., Folding), apply both compilers to 5 instances, measure compilation time, output size (actions/effects), and planner solve time. Verify orders-of-magnitude succinctness vs. TCORE.
  2. **Ablation on constraint types**: Run LiftedTCORE and LCC on problems with only Always vs. only SometimeAfter constraints. Compare node expansions to quantify regression benefit per constraint type.
  3. **Scalability stress test**: Generate problems with increasing object counts (10, 50, 100, 500) in a high-arity domain (e.g., Rubik's). Plot compilation time and planner coverage; confirm grounding-based TCORE fails while lifted methods remain stable.

## Open Questions the Paper Calls Out

### Open Question 1
- Question: Can the LiftedTCORE and LCC methods be extended to support numeric and metric time PDDL constraints?
- Basis: The conclusion explicitly states, "In the future, we would like to design lifted compilation methods for numeric and metric time PDDL constraints."
- Why unresolved: The current work is restricted to qualitative state-trajectory constraints, and the algorithms do not account for numeric fluents or metric time.
- What evidence would resolve it: An extension of the compilers that successfully handles numeric and metric constraints while maintaining polynomial time complexity and correctness.

### Open Question 2
- Question: How can the performance of lifted compilers be improved for problems with a large number of constraints?
- Basis: The authors note that lifted methods update all lifted actions affecting a constraint, leading to dense preconditions that degrade planner performance compared to the sparse updates of ground-based TCORE.
- Why unresolved: The "one-size-fits-all" update mechanism in the lifted representation creates a bottleneck in the grounding/preprocessing phase of the solver (LAMA) for high-constraint problems.
- What evidence would resolve it: A heuristic or compilation optimization that selectively updates actions to mimic the sparsity of ground compilation, improving coverage on the ICAPS21 benchmark.

### Open Question 3
- Question: Do the succinctness benefits of lifted compilation translate to improved efficiency when paired with native lifted planners?
- Basis: The paper evaluates using LAMA (a grounding planner), but notes that "benefits... will become more prominent as more expressive heuristics for lifted planning are developed."
- Why unresolved: The evaluation could not demonstrate efficiency gains from succinctness because the downstream planner (LAMA) grounds the compiled output anyway.
- What evidence would resolve it: Empirical results showing that LiftedTCORE or LCC, when used with a lifted planner (e.g., based on GNNs), outperforms grounding-based compilation on high-arity domains.

## Limitations

- Both compilers struggle with many-constraint problems where lifting leads to dense preconditions, suggesting that for constraint-rich domains, ground-based sparse updates (TCORE) may be more effective despite scalability issues.
- LCC's 1-step delay may significantly affect planner performance on domains where early constraint detection is crucial, though empirical results show this tradeoff is acceptable for the tested benchmark.
- The regression-based correctness of LiftedTCORE depends critically on bounded quantifier nesting in constraints; the paper does not explore domains with deeply nested quantifiers or constraints requiring reasoning about unbounded object counts.

## Confidence

- **High confidence**: The empirical claim that LiftedTCORE and LCC produce significantly more succinct compiled specifications (orders of magnitude fewer actions/effects) compared to ground-based TCORE is well-supported by the experimental data.
- **Medium confidence**: The claim that LCC achieves best coverage (246/280 instances) while LiftedTCORE is competitive despite slower planning on quantified constraints is supported, but the slower performance on quantified constraints suggests potential scalability limits not fully characterized.
- **Low confidence**: The polynomial-time guarantees and correctness proofs for lifted regression are not fully validated against edge cases involving complex quantifier interactions or infinite object counts.

## Next Checks

1. **Regression Correctness Verification**: Implement a formal checker to verify that R^L(φ,a) computed by LiftedTCORE correctly captures weakest preconditions for a variety of constraint types and action schemas, including edge cases with complex quantifiers.
2. **Delayed Monitoring Impact Analysis**: Design a controlled experiment comparing LCC's 1-step delay performance against a hypothetical "instant" monitoring variant on domains where early constraint detection is critical, quantifying the search space expansion.
3. **Constraint Density Stress Test**: Generate synthetic domains with increasing constraint density (from sparse to highly interconnected) and measure compilation time and planner performance for both LiftedTCORE and LCC, identifying the tipping point where lifting becomes detrimental.