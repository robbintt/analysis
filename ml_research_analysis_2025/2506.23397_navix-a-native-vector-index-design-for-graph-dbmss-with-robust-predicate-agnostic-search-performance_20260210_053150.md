---
ver: rpa2
title: 'NaviX: A Native Vector Index Design for Graph DBMSs With Robust Predicate-Agnostic
  Search Performance'
arxiv_id: '2506.23397'
source_url: https://arxiv.org/abs/2506.23397
tags:
- search
- vector
- index
- vectors
- navix
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: "NaviX is a native vector index for graph DBMSs that supports predicate-agnostic\
  \ filtered vector search. It leverages the underlying GDBMS\u2019s storage and query\
  \ processing capabilities, storing the HNSW graph as a relationship table and using\
  \ node semimasks to pass selection results."
---

# NaviX: A Native Vector Index Design for Graph DBMSs With Robust Predicate-Agnostic Search Performance

## Quick Facts
- arXiv ID: 2506.23397
- Source URL: https://arxiv.org/abs/2506.23397
- Authors: Gaurav Sehgal; Semih Salihoglu
- Reference count: 40
- Primary result: NaviX outperforms specialized vector databases and is competitive with in-memory implementations while leveraging GDBMS storage

## Executive Summary
NaviX introduces a native vector index design for graph DBMSs that enables predicate-agnostic filtered vector search. The system stores HNSW graphs as relationship tables within the existing GDBMS storage layer and uses node semimasks to pass selection results, avoiding specialized indexing for filtered searches. The key innovation is an adaptive-local search algorithm that dynamically chooses between one-hop, blind, and directed heuristics based on local selectivity at each search iteration. Experimental results demonstrate that NaviX outperforms specialized systems like Weaviate and Milvus while remaining competitive with in-memory implementations like ACORN and iRangeGraph.

## Method Summary
NaviX integrates vector indexing directly into graph DBMSs by storing HNSW graphs as relationship tables and leveraging the GDBMS's existing storage and query processing capabilities. The system introduces an adaptive-local search algorithm that makes heuristic decisions at each search iteration based on local selectivity metrics. Node semimasks are used to efficiently pass selection results through the GDBMS query processing pipeline. This approach eliminates the need for separate specialized vector databases while maintaining high performance for filtered vector searches. The design specifically addresses the challenge of predicate-agnostic search where the correlation between predicates and vector similarity is unknown.

## Key Results
- NaviX outperforms specialized vector database systems like Weaviate and Milvus in filtered vector search performance
- The system achieves competitive performance with in-memory implementations such as ACORN and iRangeGraph
- Adaptive-local search algorithm demonstrates robustness across varying selectivities and predicate correlations

## Why This Works (Mechanism)
NaviX works by deeply integrating vector indexing into the graph DBMS architecture rather than treating it as a separate system. By storing HNSW graphs as relationship tables, the system leverages the GDBMS's optimized storage layer and query processing capabilities. The adaptive-local search algorithm's effectiveness stems from its ability to dynamically adjust search strategies based on local selectivity information, allowing it to handle varying predicate correlations without requiring prior knowledge of the data distribution. Node semimasks provide an efficient mechanism for propagating selection results through the query pipeline without expensive data movement or transformation operations.

## Foundational Learning

1. **HNSW Graph Structure**
   - Why needed: Forms the basis for efficient approximate nearest neighbor search in high-dimensional spaces
   - Quick check: Understand multi-layer hierarchical structure with exponentially decreasing node density

2. **Predicate-Agnostic Search**
   - Why needed: Enables vector search without requiring prior knowledge of predicate-vector correlation
   - Quick check: Verify system works when filter predicates are uncorrelated with vector similarity

3. **Local Selectivity Metrics**
   - Why needed: Drives adaptive heuristic selection during search iterations
   - Quick check: Confirm metrics accurately reflect actual predicate selectivity in local neighborhoods

4. **Node Semimasks**
   - Why needed: Efficiently propagate selection results through GDBMS query processing
   - Quick check: Verify semimasks correctly identify qualifying nodes without false positives/negatives

5. **Relationship Table Storage**
   - Why needed: Enables HNSW graph integration with GDBMS storage layer
   - Quick check: Confirm table structure supports efficient neighbor traversal operations

## Architecture Onboarding

**Component Map:**
GDBMS Storage Layer -> Relationship Table (HNSW Graph) -> Query Processor -> Adaptive-Local Search Algorithm -> Node Semimasks

**Critical Path:**
Query reception → Predicate evaluation → Semimask propagation → Adaptive-local search initialization → Iterative search with heuristic selection → Result refinement and return

**Design Tradeoffs:**
NaviX trades specialized vector database optimizations for integration simplicity and reduced system complexity. The choice to use GDBMS storage avoids data duplication but may limit some vector-specific optimizations available in dedicated systems. The adaptive-local search introduces runtime overhead for selectivity estimation but provides robustness across diverse workloads.

**Failure Signatures:**
Performance degradation under extreme selectivity values, incorrect semimask propagation leading to missing results, adaptive algorithm making poor heuristic choices in pathological cases, storage layer bottlenecks when handling large HNSW graphs.

**First Experiments:**
1. Benchmark filtered vector search performance across varying selectivity ranges (0.1% to 50%)
2. Compare query execution times with and without predicate filtering enabled
3. Stress test with highly correlated predicate-vector pairs to validate adaptive algorithm behavior

## Open Questions the Paper Calls Out
None

## Limitations
- Limited exploration of edge cases and pathological workloads with extreme selectivity or highly correlated predicates
- Empirical rather than theoretical guarantees for adaptive-local search algorithm robustness
- Evaluation primarily on synthetic and specific real-world datasets without extensive analysis across diverse data distributions

## Confidence

**High Confidence:**
- NaviX's core design of leveraging GDBMS storage and query processing is well-supported
- Experimental results showing NaviX outperforming Weaviate and Milvus are convincing

**Medium Confidence:**
- Competitive performance with in-memory implementations ACORN and iRangeGraph needs broader benchmarking
- Adaptive-local search effectiveness lacks theoretical worst-case performance analysis

## Next Checks
1. Conduct stress testing with highly correlated predicates and extreme selectivity values to validate robustness claims under worst-case scenarios
2. Perform comparative analysis with state-of-the-art vector databases on datasets with different dimensionalities and distribution characteristics
3. Implement theoretical analysis of the adaptive-local search algorithm to establish performance bounds and identify potential pathological cases