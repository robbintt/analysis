---
ver: rpa2
title: 'Herb.jl: A Unifying Program Synthesis Library'
arxiv_id: '2510.09726'
source_url: https://arxiv.org/abs/2510.09726
tags:
- program
- synthesis
- search
- programs
- grammar
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: This paper introduces Herb.jl, a unifying program synthesis library
  in Julia designed to address the problem of reusability and extensibility in existing
  program synthesis tools. Herb.jl breaks down underlying algorithms into extendable,
  reusable subcomponents, allowing for straightforward reapplication or recombination
  of existing methods.
---

# Herb.jl: A Unifying Program Synthesis Library

## Quick Facts
- **arXiv ID:** 2510.09726
- **Source URL:** https://arxiv.org/abs/2510.09726
- **Reference count:** 20
- **Primary result:** Herb.jl is a modular Julia library that breaks down program synthesis algorithms into reusable subcomponents for easier customization and benchmarking.

## Executive Summary
Herb.jl addresses the challenge of reusability and extensibility in program synthesis by providing a modular framework that separates grammar, specification, search, and constraint solving. The library allows researchers to implement and customize synthesizers with just a few lines of code, enabling fairer and easier benchmarking across different approaches. Through its uniform tree data structure and separation of syntax and semantics, Herb.jl supports both novices and experts in the field.

## Method Summary
Herb.jl uses a context-free grammar-based approach where programs are represented as Abstract Syntax Trees (ASTs) with "holes" that search iterators fill according to grammar rules. The library separates the search process (operating on ASTs) from program execution (handled by an interpreter). Users define problems through input-output examples, specify grammars using the `@csgrammar` macro, and run search using iterators like BFS or DFS. A constraint solver prunes the program space by filtering invalid or symmetric programs, while the modular design allows components to be easily customized or recombined.

## Key Results
- Modular framework enables synthesizers to be implemented in just a few lines of code
- Three use cases demonstrated: simple problem implementation, synthesizer customization, and benchmark execution
- Library includes standardized benchmarks (SyGuS, ARC) for fair comparison
- Separation of syntax (grammar) and semantics (interpreter) enables interchangeable search strategies

## Why This Works (Mechanism)
Herb.jl works by decomposing the program synthesis pipeline into independent, composable modules. The core insight is that by representing programs as uniform trees with holes, search can be decoupled from execution - different search strategies can be swapped in without changing the underlying grammar or specification. The constraint solver acts as a filter that prunes invalid programs early, while the grammar definition provides a clear interface for specifying the program space. This modular separation allows researchers to focus on individual components (like search strategy or constraints) without rebuilding the entire synthesis pipeline.

## Foundational Learning

- **Concept: Context-Free Grammars (CFGs) for Program Spaces**
  - **Why needed here:** Herb.jl uses CFGs as the primary way to define the space of all possible programs to be synthesized. Understanding how derivation rules generate Abstract Syntax Trees (ASTs) is fundamental to defining a problem and understanding the search.
  - **Quick check question:** Can you write a simple CFG that generates strings of balanced parentheses?

- **Concept: Syntax-Guided Synthesis (SyGuS)**
  - **Why needed here:** Herb.jl follows the SyGuS paradigm where the search operates on the program's syntax (its AST) while a separate interpreter handles its semantics. This separation is critical for understanding how search iterators work independently of program execution.
  - **Quick check question:** What is the core difference between the specification and the grammar in a SyGuS problem?

- **Concept: Abstract Syntax Trees (ASTs) and "Holes"**
  - **Why needed here:** Herb.jl represents programs as ASTs. A key concept is the "partial program," which contains non-terminal symbols called "holes." The search process is fundamentally about filling these holes according to the grammar's rules.
  - **Quick check question:** In the partial program `(x + Int) + Int`, what does `Int` represent, and how does a top-down search process it?

## Architecture Onboarding

- **Component map:**
  - **HerbCore.jl** defines fundamental interfaces and data structures, most importantly `RuleNode` for representing ASTs
  - **HerbGrammar.jl** provides the `@csgrammar` macro for defining grammars and functions for manipulating them
  - **HerbSpecification.jl** contains tools for defining the problem, primarily through `IOExample`s
  - **HerbConstraints.jl** implements the constraint solver and constraint types to prune the program space
  - **HerbSearch.jl** contains core search iterators (BFSIterator, DFSIterator) and tools for defining custom search orders
  - **HerbInterpret.jl** provides `execute_on_input` function to run synthesized programs on data
  - **Garden.jl** repository contains reference implementations of synthesizers built using Herb.jl
  - **HerbBenchmarks.jl** collection of standardized synthesis problems for benchmarking

- **Critical path:**
  1. Define Problem: Create a `Problem` with `IOExample`s via HerbSpecification
  2. Define Grammar: Use `@csgrammar` in HerbGrammar to specify target language and `addconstraint!` from HerbConstraints to refine search space
  3. Run Search: Initialize search iterator (e.g., `BFSIterator`) from HerbSearch with grammar and starting symbol
  4. Synthesize: Call `synth(problem, iterator)` to find solution program
  5. Interpret: Convert result to Julia expression with `rulenode2expr` and run with `execute_on_input` from HerbInterpret

- **Design tradeoffs:**
  - **Uniform Trees vs. Immutability:** Herb.jl uses stateful "uniform trees" for search efficiency, reusing data structures. **Tradeoff:** This hurts ergonomics for developers, as they must explicitly copy a program if they want to save it during iteration.
  - **Julia-Centric vs. Interoperability:** The library leverages Julia's dispatch for customization. **Tradeoff:** Full benefit requires developing in Julia, potentially isolating it from Python/C++ ecosystems.
  - **Modularity vs. Performance:** Clean separation of components may introduce abstraction overhead. **Tradeoff:** System prioritizes developer experience and composability, which may come at the cost of raw, low-level performance.

- **Failure signatures:**
  - **Infinite Loop/No Solution:** Search never terminates or returns nothing. **Likely cause:** Grammar too permissive, search space vast. **Fix:** Add more specific `IOExample`s or use `HerbConstraints.jl` to prune invalid/symmetric programs.
  - **Type/Dispatch Errors:** Code crashes with method errors. **Likely cause:** Custom iterator or heuristic function not defined for specific types. **Fix:** Check that custom functions are correctly typed and extend right abstract types/functions from HerbCore.
  - **Incorrect Solution:** Synthesized program passes given examples but fails on unseen inputs. **Likely cause:** Specification (examples) insufficient to uniquely identify target program. **Fix:** Add more representative `IOExample`s to `Problem` definition.

- **First 3 experiments:**
  1. **Reproduce a Simple Paper Example:** Implement the "Getting Started" integer arithmetic example from Section 4.1 exactly as shown. This validates installation and confirms basic workflow from problem definition to synthesis.
  2. **Modify Search Strategy:** Replace `BFSIterator` with `DFSIterator` (or depth-limited variant) and compare results. This confirms understanding of how search iterators are modular and interchangeable components.
  3. **Add a Custom Constraint:** Take integer arithmetic grammar and add custom constraint (e.g., forbid constant `2`). Run search again and verify no solution contains number `2`. This tests extensibility of constraint solver module.

## Open Questions the Paper Calls Out

### Open Question 1
- **Question:** Which specific synthesis paradigms or building blocks are currently missing from Herb.jl that prevent it from covering the full diversity of the field?
- **Basis in paper:** [explicit] The conclusion states, "Many challenges still remain. Program synthesis is a diverse field... we continuously add new ones to express more ideas."
- **Why unresolved:** The library is presented as a work in progress, and the authors acknowledge that the current set of modular blocks does not yet capture every approach used in the broader research community.
- **Evidence to resolve:** A comprehensive feature analysis mapping state-of-the-art synthesizers (e.g., those based on type theory or large language models) to Herb.jl's existing capabilities, identifying specific gaps in abstraction.

### Open Question 2
- **Question:** Does the high level of abstraction and the use of the Julia language in Herb.jl introduce computational overhead that limits scalability compared to native, low-level implementations?
- **Basis in paper:** [inferred] The paper identifies "Problem 3" as the difficulty of comparing synthesizers due to engineering choices like programming language. While Herb solves this by standardizing on Julia, it does not verify if this choice degrades performance relative to C++ based tools.
- **Why unresolved:** The paper demonstrates ease of use and code brevity but provides no empirical data comparing the raw throughput or memory footprint of Herb.jl against highly optimized, lower-level baselines.
- **Evidence to resolve:** Controlled experiments measuring the iteration speed and resource consumption of a standard search algorithm (e.g., BFS) implemented in Herb.jl versus an equivalent implementation in C++ or Rust.

### Open Question 3
- **Question:** Can Herb.jl's context-free grammar and AST-based constraints effectively model imperative, stateful domains like the hardware firmware example used to motivate the work?
- **Basis in paper:** [inferred] Example 3 motivates the library using low-level hardware synthesis, but the implementation details focus on functional grammars and standard SyGuS benchmarks, which are typically declarative and stateless.
- **Why unresolved:** The paper does not demonstrate an implementation of the firmware example, leaving it unclear if the current constraint solver and interpreter model can handle mutable state or complex side effects.
- **Evidence to resolve:** A case study using Herb.jl to synthesize a non-trivial imperative program with loops and variable mutation, showing that the constraint solver can prune invalid states effectively.

## Limitations
- **No quantitative benchmarks:** Paper provides no solve rates, timing data, or memory usage comparisons against existing tools
- **Julia ecosystem dependency:** Library's benefits are tied to Julia's multiple dispatch, potentially limiting adoption among Python/C++ researchers
- **Missing advanced paradigms:** Current modular blocks don't cover all synthesis approaches used in state-of-the-art research

## Confidence
- **Technical implementation:** High - modular architecture follows established patterns in the field
- **Claimed benefits:** Medium - ease of use demonstrated but lack of empirical validation on research productivity
- **Performance claims:** Low - no quantitative data provided to support performance characteristics

## Next Checks
1. **Performance Benchmarking:** Implement a simple synthesizer using Herb.jl and a comparable monolithic implementation in another language, then measure execution time and memory usage on identical problems.

2. **Usability Study:** Have researchers unfamiliar with Herb.jl implement a basic synthesizer, then assess whether the modular design actually reduces development time compared to traditional approaches.

3. **Cross-Language Integration:** Test whether Herb.jl's search iterators and grammars can be exposed to Python via PyCall or similar interfaces, validating the claim about interoperability despite the Julia-centric design.