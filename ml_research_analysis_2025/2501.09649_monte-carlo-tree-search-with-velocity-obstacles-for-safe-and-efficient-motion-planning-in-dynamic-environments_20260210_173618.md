---
ver: rpa2
title: Monte Carlo Tree Search with Velocity Obstacles for safe and efficient motion
  planning in dynamic environments
arxiv_id: '2501.09649'
source_url: https://arxiv.org/abs/2501.09649
tags:
- mcts
- planning
- obstacles
- robot
- tree
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: This paper presents a novel online motion planning approach for
  mobile robots in dynamic environments with dense obstacles, such as crowds. The
  method combines Monte Carlo Tree Search (MCTS) with Velocity Obstacles (VO) to achieve
  optimal and safe navigation while requiring minimal information about obstacle trajectories.
---

# Monte Carlo Tree Search with Velocity Obstacles for safe and efficient motion planning in dynamic environments

## Quick Facts
- arXiv ID: 2501.09649
- Source URL: https://arxiv.org/abs/2501.09649
- Reference count: 40
- Primary result: MCTS with VO pruning achieves 80% success rate in dense dynamic environments with minimal computation

## Executive Summary
This paper presents a novel online motion planning approach for mobile robots in dynamic environments with dense obstacles, such as crowds. The method combines Monte Carlo Tree Search (MCTS) with Velocity Obstacles (VO) to achieve optimal and safe navigation while requiring minimal information about obstacle trajectories. The approach only needs current obstacle positions and their maximum speeds, making it suitable for real-world scenarios where precise trajectory information is unavailable.

The key innovation is the integration of VO constraints within MCTS to prune unsafe actions from the search space, significantly improving computational efficiency. This allows the algorithm to scale to large action spaces (up to 60 velocity actions) while maintaining safety guarantees. The method guarantees collision-free actions when planning time per step is less than the simulation time step, assuming known maximum obstacle velocities and positions.

## Method Summary
The method formulates motion planning as a Markov Decision Process and uses MCTS with UCT selection to find optimal actions. VO constraints are integrated during tree expansion to prune unsafe velocity commands based on collision cones computed from obstacle positions and maximum speeds. The approach discretizes the action space into 60 velocity commands (5 velocity modules Ã— 12 heading angles) and uses an Îµ-greedy heuristic for rollouts. The algorithm requires only current obstacle positions and maximum speeds as input, making it practical for real-world deployment.

## Key Results
- MCTS_VO_TREE achieves approximately 80% success rate in reaching goals without collisions in environments with up to 40 dynamic obstacles
- The method outperforms state-of-the-art planners including NMPC and DWA in both success rate and planning time
- Maintains high performance with fewer than 50 MCTS simulations per step, enabling real-time operation on resource-constrained platforms
- Guarantees collision-free actions when planning time per step is less than the simulation time step

## Why This Works (Mechanism)

### Mechanism 1
- Claim: Integrating Velocity Obstacles into MCTS tree expansion prunes unsafe actions, enabling efficient search over large action spaces (up to 60 velocity commands) while maintaining collision-free guarantees.
- Mechanism: During UCT selection, Algorithm 2 computes collision cones (Eq. 1) for each obstacle using worst-case velocities, restricting action selection to the feasible set $V_c = V \setminus \bigcup_{i=1}^{N} CC_i$. This reduces the effective branching factor by eliminating colliding velocities before tree expansion.
- Core assumption: Planning time per step $t_{plan} < t_s$ (simulation timestep), and obstacle positions plus maximum speeds are known.
- Evidence anchors:
  - [abstract] "key innovation is the integration of VO constraints within MCTS to prune unsafe actions... allows the algorithm to scale to large action spaces (up to 60 velocity actions)"
  - [section 4.2.1] Algorithm 2 shows VO constraint computation during Expand()
  - [corpus] Limited direct evidence; corpus focuses on MCTS variants but not VO integration specifically
- Break condition: When $\mathbf{p}_R \in B(\mathbf{p}_i, r_2)$ (robot inside extended obstacle ball), Algorithm 1 returns $V_c = \emptyset$, forcing zero velocityâ€”system stalls if obstacles approach too closely.

### Mechanism 2
- Claim: Conservative velocity assumptions (using maximum obstacle speeds rather than actual velocities) enable safety guarantees without requiring trajectory prediction models.
- Mechanism: Algorithm 1 (lines 5-6) computes extended collision radii $r_1 = v_{max} t_s$ and $r_2 = r_i + r_R + v_{max,i} t_s$, treating all obstacles as potentially moving at maximum speed toward the robot. This over-approximates collision risk.
- Core assumption: Maximum obstacle velocities $V_{max,o}$ are known or overestimated; obstacles do not deliberately pursue collision.
- Evidence anchors:
  - [section 4.3.1] "we can enlarge $r_1, r_2$ with safety bounds, in order to incorporate the level of confidence of sensors"
  - [section 3.1] Formal definition of collision cone $CC_i$ for velocity-based collision prediction
  - [corpus] No corpus papers address this specific conservative assumption pattern
- Break condition: If actual obstacle velocities exceed assumed maximums, or if obstacles exhibit adversarial behavior (section 6 notes this as future work), collision avoidance guarantees void.

### Mechanism 3
- Claim: Applying VO only during tree expansion (not rollout) achieves optimal tradeoff between safety and computational efficiency.
- Mechanism: MCTS_VO_TREE applies VO pruning in UCT phase (near-term decisions) but uses heuristic-guided rollout (Algorithm 3) without VO constraints, avoiding expensive collision computations deep in simulations while ensuring selected actions are safe.
- Core assumption: Near-term collision avoidance is more critical than long-horizon optimality in rollout.
- Evidence anchors:
  - [section 5.5] Ablation study: MCTS_VO_TREE achieves ~80% success rate with lowest variance; MCTS_VO_2 (VO in both phases) shows higher variance and lower success (<70%)
  - [Figure 5c] Computational time: MCTS_VO_TREE adds minimal overhead vs. MCTS; MCTS_VO_2 becomes prohibitive beyond 50 simulations
  - [corpus] Indirect support: corpus papers discuss MCTS efficiency challenges in continuous action spaces but don't evaluate phased VO integration
- Break condition: If rollout trajectories frequently encounter dense obstacle regions, the heuristic policy (Algorithm 3, lines 7-13) may select poor velocities, reducing return estimates' accuracy for guiding UCT.

## Foundational Learning

- **Velocity Obstacles (VO)**
  - Why needed here: Core geometric framework for computing collision-free velocity sets from obstacle positions and speeds.
  - Quick check question: Given a robot at (0,0) with $v_{max}=1$ m/s and obstacle at (2,0) with $r=0.5$m, $v_{max,o}=0.3$m/s, sketch the collision cone in velocity space.

- **Monte Carlo Tree Search with UCT**
  - Why needed here: Provides the online planning backbone; understanding UCT's exploration-exploitation balance is essential for grasping why VO pruning improves efficiency.
  - Quick check question: Explain why MCTS struggles to scale to 60+ discrete actions without action pruning, referencing the UCT exploration term $\sqrt{\ln(t-1)/T_a(t-1)}$.

- **Markov Decision Process Formulation**
  - Why needed here: The reward function (Eq. 2) and transition model define what MCTS optimizes; mis-specifying these breaks the method.
  - Quick check question: Why does the reward function include a normalized distance penalty (last line of Eq. 2) rather than only sparse goal reward?

## Architecture Onboarding

- **Component map:**
  [Sensor Input: P_o, V_max,o] â†’ [Algorithm 1: Compute V_c] â†’ [Algorithm 2: UCT Expand with VO]
                                      â†“                                    â†“
  [Reward Function Eq. 2] â† [State Transition T] â† [MCTS Tree] â† [Algorithm 3: Rollout Heuristic]
                                      â†“
                          [Action Selection: max Q(s,a)] â†’ [Execute velocity command]

- **Critical path:** Algorithm 1 must complete within $t_s - t_{overhead}$ to guarantee safety. If collision cone computation exceeds available time, $t_{plan} > t_s$ violates the core assumption.

- **Design tradeoffs:**
  - **Action space granularity:** More velocity discretizations (beyond 60) improve trajectory smoothness but increase MCTS branching factor
  - **Conservatism vs. progress:** Larger safety margins (inflating $r_1, r_2$) reduce collisions but may cause freezing in dense crowds
  - **Simulation count $m$:** Fewer simulations (<50) enable real-time operation but increase variance in action value estimates

- **Failure signatures:**
  - **Robot freezes** (zero velocity repeatedly): Indicates $A_c = \emptyset$ in Algorithm 1; obstacle density too high or safety margins too conservative
  - **High collision rate despite VO:** Likely $t_{plan} > t_s$ or obstacle velocities exceed assumed $V_{max,o}$
  - **Erratic trajectories:** Rollout heuristic parameter $\delta$ (angle range toward goal) too narrow or $\epsilon_0$ (exploration rate) too low

- **First 3 experiments:**
  1. **Baseline validation:** Implement Algorithm 1 standalone as reactive VO_PLANNER; verify collision-free navigation with stationary obstacles before integrating MCTS
  2. **Action space sweep:** Test MCTS_VO_TREE with $m=50$ simulations across action sets of 12, 30, 60 velocities; measure success rate degradation and planning time to establish scaling limits on target hardware
  3. **Density threshold test:** Incrementally increase obstacles from 10 to 40 in 10Ã—10m environment; identify density at which $A_c = \emptyset$ occurs >10% of timesteps, marking operational boundary

## Open Questions the Paper Calls Out

### Open Question 1
- Question: Can the methodology be extended to continuous action spaces while maintaining computational efficiency and safety guarantees?
- Basis in paper: [explicit] "In future works, we will investigate the extension of our methodology to continuous action spaces and partially observable MDPs, that present additional computational and modeling challenges but are of more practical interest in robotic domains."
- Why unresolved: The current approach relies on discrete action spaces (60 velocity actions) with VO-based pruning; continuous spaces would require different sampling or optimization strategies.
- What evidence would resolve it: Demonstration of safe collision avoidance and comparable discounted return in the same environment using a continuous action representation.

### Open Question 2
- Question: How does the algorithm perform in adversarial scenarios where obstacles deliberately attempt to collide with the robot?
- Basis in paper: [explicit] "We will consider adversarial situations in which malicious obstacles deliberately try to collide with the robot in future works."
- Why unresolved: The current assumption is that obstacles preserve minimum distance (social models); adversarial obstacles could exploit cases where pR âˆˆ B(pi, r2), forcing the robot to remain stationary.
- What evidence would resolve it: Experiments with adversarial obstacle behaviors showing collision rates and success rates under such conditions.

### Open Question 3
- Question: Does the approach transfer to real robotic platforms with sensor noise, actuation delays, and perception uncertainty?
- Basis in paper: [inferred] The paper validates only in simulation and assumes perfect obstacle position estimates. Real-world deployment would introduce uncertainties in Pâ‚€ estimation and delays violating the tplam < ts requirement.
- What evidence would resolve it: Hardware experiments on a physical robot (e.g., TurtleBot 4) demonstrating comparable collision rates and success rates with real sensor input.

### Open Question 4
- Question: How does the method handle deadlock situations where no safe angles exist (Að’¸ = âˆ…) for extended periods in dense crowds?
- Basis in paper: [inferred] Algorithm 1 commands null velocity when Að’¸ = âˆ…. In dense scenarios, this could cause indefinite waiting without progress toward the goal.
- What evidence would resolve it: Analysis of goal-reaching times and deadlock frequency in environments with obstacle densities beyond 40 obstacles in 10Ã—10m.

## Limitations
- Safety guarantees rely on conservative assumptions about maximum obstacle velocities and perfect position estimates, which may not hold in real-world scenarios
- Computational efficiency depends on maintaining planning time below simulation timestep, which may be challenging for higher-dimensional problems or resource-constrained platforms
- The method cannot handle adversarial obstacles that deliberately attempt to collide with the robot, as this would violate the collision avoidance assumptions

## Confidence
- **High Confidence**: The VO integration mechanism for pruning unsafe actions during UCT expansion - supported by clear algorithmic description and ablation study results showing MCTS_VO_TREE outperforms variants
- **Medium Confidence**: The conservative velocity assumption safety guarantees - theoretical framework is sound but lacks empirical validation against adversarial or faster-than-assumed obstacles
- **Medium Confidence**: The phased VO application (only in tree expansion, not rollout) tradeoff - ablation study supports this but doesn't explore the full design space of VO placement strategies

## Next Checks
1. **Adversarial Obstacle Test**: Implement obstacles that deliberately approach the robot at speeds exceeding the assumed maximum. Measure at what percentage violation the collision rate exceeds acceptable thresholds, quantifying the robustness margin of the conservative assumption
2. **Real-Time Constraint Verification**: Profile the complete system on the target robotic platform to measure actual planning time per step across varying simulation counts (10-400). Identify the maximum m that maintains t_plan < t_s consistently under different obstacle densities
3. **Trajectory Smoothness Analysis**: Record and analyze the robot's velocity profiles over successful runs. Compute jerk (derivative of acceleration) to quantify smoothness degradation as action space granularity increases from 12 to 60 velocities, validating the practical benefit of finer discretization