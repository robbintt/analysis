---
ver: rpa2
title: Verifiable Safety Q-Filters via Hamilton-Jacobi Reachability and Multiplicative
  Q-Networks
arxiv_id: '2506.15693'
source_url: https://arxiv.org/abs/2506.15693
tags:
- safe
- safety
- control
- function
- value
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: This paper introduces a formally verifiable model-free safety filter
  based on Hamilton-Jacobi reachability analysis. The key innovation is a multiplicative
  Q-network architecture that captures bilinear interactions between state and control
  while enabling efficient verification.
---

# Verifiable Safety Q-Filters via Hamilton-Jacobi Reachability and Multiplicative Q-Networks

## Quick Facts
- **arXiv ID**: 2506.15693
- **Source URL**: https://arxiv.org/abs/2506.15693
- **Reference count**: 24
- **Primary result**: Formally verifiable model-free safety filter using multiplicative Q-networks achieves verified safe set sizes of 0.529-0.6900 across four benchmarks while avoiding zero-sublevel-set collapse.

## Executive Summary
This paper introduces a model-free safety filter based on Hamilton-Jacobi reachability analysis that combines theoretical safety guarantees with practical verification. The key innovation is a multiplicative Q-network architecture that captures bilinear state-control interactions while enabling efficient mixed-integer quadratic programming (MIQCP) verification. The method establishes sufficient conditions for safety certification through constraint satisfaction and forward invariance properties, then implements an iterative verification-finetuning pipeline that produces verifiable Q-networks without the safe set collapse observed in baseline approaches. Experimental results on four standard safe-control benchmarks demonstrate successful synthesis of formally verified, model-free safety certificates.

## Method Summary
The method constructs a safety filter by learning a Q-function that satisfies two verifiable properties: constraint satisfaction (Q(x,u) ≤ 0 implies safety) and forward invariance (Q(x,u) ≤ 0 implies existence of safe continuation). A multiplicative Q-network architecture captures bilinear state-control interactions inherent in Q-functions, enabling efficient MIQCP verification. The pipeline iteratively pre-trains with discounted HJB loss, finds counterexamples via interval arithmetic, fine-tunes with adversarial losses, trains a policy to approximate the safe control selector, and verifies with tight bounds using the policy. Sound relaxation ensures no false positives in verification.

## Key Results
- Verified safe set sizes: 0.529 (2D double integrator), 0.5985 (double integrator), 0.6900 (unicycle), 0.47 (robot arm)
- Avoids zero-sublevel-set collapse observed in baseline fully-connected networks
- Maintains formal verification certificates while achieving nontrivial safe set volumes
- Successfully handles linear dynamics (double integrator), nonlinear dynamics (unicycle), and 6D state spaces (robot arm)

## Why This Works (Mechanism)

### Mechanism 1: Sufficient Conditions for Safety Certification
The Q-function serves as a valid safety filter if it satisfies two conditions: (1) Q(x,u) ≤ 0 implies h(x) ≤ 0 (constraint satisfaction), and (2) Q(x,u) ≤ 0 implies ∃u' s.t. Q(f(x,u), u') ≤ 0 (forward invariance). These conditions ensure the zero-sublevel set forms a control-dependent safe set that is both valid and forward invariant. Counterexamples are found by solving feasibility problems that violate these conditions.

### Mechanism 2: Multiplicative Q-Network Architecture
The architecture uses two branches: X-branch processes state → Z₁(x), U-branch processes (x,u) → Z₂(x,u), with Q(x,u) = Z₁(x)·Z₂(x,u). This captures the bilinear term LgV(x)·Δt·u inherent in Q-functions while confining nonlinearity to a single quadratic constraint, making MIQCP verification tractable. The design preserves bilinear state-control interactions that fully-connected networks approximate poorly.

### Mechanism 3: Iterative Verification-Finetuning Pipeline
The pipeline stages: (1) Pre-train with discounted HJB loss; (2) Find counterexamples via interval-arithmetic relaxation; (3) Fine-tune with L_con (push Q>0 for constraint violations) and L_inv (enforce safe continuation); (4) Train policy πϕ to approximate min_u'Q; (5) Verify with tight bounds using πϕ. Sound relaxation ensures no false positives, and adversarial fine-tuning prevents safe set collapse.

## Foundational Learning

- **Hamilton-Jacobi-Bellman variational inequality**: Characterizes the maximum safe invariant set via V(x) = max{h(x), min_u V(f(x,u))}. Understanding this is essential for interpreting Q-values as safety certificates.
  - Quick check: Why does the HJB equation use "max" for h(x) but "min" for control?

- **Zero-sublevel sets and forward invariance**: Safety is defined by {x | V(x) ≤ 0}; forward invariance guarantees trajectories remain in this set under safe controls.
  - Quick check: If V(x₀) = -0.1, what does this imply about safety from state x₀?

- **Mixed-Integer Programming for ReLU network verification**: ReLU activations are encoded with binary variables; the multiplicative layer adds a quadratic constraint, requiring MIQCP rather than MILP.
  - Quick check: How many binary variables are needed to verify a ReLU network with N total neurons?

## Architecture Onboarding

- **Component map**: 
  State x → X-branch (2×32 ReLU) → 8-dim embedding Z₁(x)
  State x, Control u → U-branch (2×32 ReLU) → 8-dim embedding Z₂(x,u)
  Z₁(x) · Z₂(x,u) → scalar Q-value
  Q(x,u) → Policy network πϕ → min_u'Q(x',u')

- **Critical path**:
  1. Pre-train Q-network on discounted HJB loss with pretrained policy
  2. Run MIQCP verification → collect counterexamples violating Y_con or Y_inv
  3. Fine-tune with L_con = -ΣQ(x_ce, u_ce) and L_inv losses
  4. Train πϕ to approximate min_u'Q(x', u')
  5. Final verification with πϕ (tighter bounds); iterate if violations found

- **Design tradeoffs**:
  - Embedding dimension (8): Higher → more expressive but larger MIQCP
  - Interval bounds vs. policy approximation: Looser bounds find more counterexamples but may over-constrain
  - Network size: Smaller network aids verification; multiplicative structure achieves expressiveness with fewer parameters

- **Failure signatures**:
  - Safe set collapse (verified size = 0.0000): Baseline exhibits this; multiplicative network maintains 0.47-0.69
  - Hazardous region inclusion: Pretrained Q misclassifies hazards as safe (Fig. 3a orange vs. blue)
  - MIQCP timeout: Higher dimensions (robot arm: 6D) push solver limits

- **First 3 experiments**:
  1. Double integrator (2D state, 1D control): Linear dynamics/constraints; verify against ground truth HJB solution (Fig. 3a red contour)
  2. 2D double integrator (4D state, 2D control): Linear dynamics, nonlinear circular hazard; test scalability
  3. Unicycle (5D state, 2D control): Nonlinear dynamics; test generalization to real-world-like systems

## Open Questions the Paper Calls Out
None identified in the provided text.

## Limitations
- Scalability concerns to higher-dimensional systems beyond the 6D robot arm benchmark due to exponential growth in MIQCP verification complexity
- Interval-arithmetic relaxation may miss violations in high-dimensional spaces, potentially providing false verification certificates
- Reliance on Gurobi for MIQCP solving introduces practical limits not captured by theoretical guarantees

## Confidence

- **High Confidence**: Theoretical foundations connecting HJB theory to Q-function safety certification (Theorem 1) are mathematically rigorous
- **Medium Confidence**: Multiplicative architecture's superiority over baseline fully-connected networks is demonstrated empirically but lacks extensive ablation studies
- **Medium Confidence**: Avoidance of zero-sublevel-set collapse is validated on four benchmarks but may not generalize to significantly different systems

## Next Checks

1. **Scalability Test**: Apply the method to a 10+ dimensional nonlinear system (e.g., quadrotor or manipulator with more degrees of freedom) to measure MIQCP solver performance and verify safe set size maintenance.

2. **Counterexample Coverage Analysis**: Compare adversarial counterexample generation via interval arithmetic against alternative methods (particle swarm optimization or Monte Carlo sampling) to quantify false-negative rates in violation detection.

3. **Architecture Ablation**: Systematically vary multiplicative architecture parameters (embedding dimensions, number of layers) and compare verified safe set sizes against baseline to establish architectural contribution beyond reduced parameter count.