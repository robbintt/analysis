---
ver: rpa2
title: Verification of Bit-Flip Attacks against Quantized Neural Networks
arxiv_id: '2502.16286'
source_url: https://arxiv.org/abs/2502.16286
tags:
- networks
- verification
- neural
- attacks
- network
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: This paper introduces BFAVerifier, the first sound and complete
  verification framework for bit-flip attacks (BFAs) against quantized neural networks
  (QNNs). The method combines a novel symbolic polyhedral abstraction domain (SymPoly)
  for reachability analysis with an MILP-based encoding for completeness.
---

# Verification of Bit-Flip Attacks against Quantized Neural Networks

## Quick Facts
- arXiv ID: 2502.16286
- Source URL: https://arxiv.org/abs/2502.16286
- Reference count: 40
- Key outcome: First sound and complete verification framework for bit-flip attacks (BFAs) against quantized neural networks (QNNs), achieving up to 30x speedup over naive verification

## Executive Summary
This paper introduces BFAVerifier, a novel verification framework that soundly and completely verifies whether quantized neural networks are resilient to bit-flip attacks. The framework combines symbolic polyhedral abstraction (SymPoly) with MILP-based encoding to efficiently analyze the vast space of potential bit-flip attacks. Experiments on MNIST and ACAS Xu benchmarks demonstrate that BFAVerifier can prove BFA-freeness for most benign QNNs while identifying vulnerable parameters clustered in earlier layers, with significant speedups over naive per-attack verification.

## Method Summary
BFAVerifier verifies BFA-tolerance of QNNs through a two-phase approach: first, a reachability analysis using SymPoly abstracts over symbolic parameters representing potential bit-flip attacks, efficiently proving safety for most parameters; second, an MILP-based method provides completeness for parameters where SymPoly cannot prove safety. The framework partitions parameter intervals by sign and applies binary search refinement to reduce abstraction precision loss. This combination enables polynomial-time analysis for the majority of parameters while guaranteeing completeness through MILP fallback on the reduced vulnerable parameter set.

## Key Results
- BFAVerifier achieves up to 30x speedup over naive per-attack verification on MNIST and ACAS Xu benchmarks
- Successfully verifies 147/165 ACAS Xu tasks and all 2160 MNIST tasks, identifying vulnerable parameters clustered in earlier layers
- For ACAS Xu, biases show greater robustness than weights, while for MNIST, larger networks demonstrate improved BFA resilience with lower bit-widths

## Why This Works (Mechanism)

### Mechanism 1: Symbolic Polyhedral Abstraction (SymPoly)
BFAVerifier achieves efficient verification by abstracting multiple potential bit-flip attack vectors simultaneously through symbolic parameter ranges rather than enumerating each attack individually. SymPoly extends DeepPoly by introducing symbolic parameters constrained to intervals representing all possible bit-flip outcomes, propagating these symbolic bounds through the network using specialized affine transformers. This transforms an exponential enumeration problem into a polynomial-time reachability analysis.

### Mechanism 2: MILP Fallback for Completeness
When symbolic abstraction cannot prove safety, BFAVerifier encodes the verification problem as Mixed-Integer Linear Programming to guarantee completeness. For parameters flagged as "Unknown" by SymPoly, the framework constructs MILP constraints encoding the input region, network structure with symbolic attacked parameters, and output property to violate. Binary variables represent specific bit-flips, ensuring exactly one attack vector is selected. Off-the-shelf solvers then find counterexamples or prove no attack exists.

### Mechanism 3: Binary Search with Signed Interval Partition
BFAVerifier partitions parameter intervals by sign and applies binary search refinement to reduce abstraction precision loss. For each potentially attacked parameter, the algorithm splits the interval into positive and negative sub-intervals, runs SymPoly separately on each, and applies recursive binary search if intervals remain too wide. This addresses precision loss where weight intervals crossing zero produce looser polyhedral approximations.

## Foundational Learning

- **Abstract Interpretation and DeepPoly**: Why needed here: SymPoly builds directly on DeepPoly's polyhedral abstract domain; understanding how abstract elements (symbolic bounds, concrete intervals, affine transformers) propagate is essential for extending to symbolic parameters. Quick check question: Given a neuron x = ReLU(wâ‚xâ‚ + wâ‚‚xâ‚‚ + b) with xâ‚ âˆˆ [âˆ’1, 1], xâ‚‚ âˆˆ [0, 2], what are the lower and upper bounds after the ReLU if wâ‚=0.5, wâ‚‚=âˆ’1, b=0?

- **Symmetric Quantization and Two's Complement Representation**: Why needed here: The verification problem fundamentally depends on how bit-flips alter two's complement representations; understanding quantization step size Î”w and de-quantization (Ã©W = bW Â· Î”w) is necessary to compute attack parameter ranges. Quick check question: For an 8-bit quantized weight bW = 85 stored as [01010101], what are all possible values after flipping at most 2 bits in the two's complement representation?

- **Mixed-Integer Linear Programming (MILP) Encoding of Neural Networks**: Why needed here: The fallback verification requires encoding ReLU activations with binary variables and formulating output constraints as linear inequalities with big-M method. Quick check question: How would you encode the constraint "output y_g is strictly greater than all other outputs y_i for i â‰  g" using binary variables and linear constraints?

## Architecture Onboarding

- **Component map**: BFAVerifier Pipeline: Input QNN N, input region I, target class g, max bit-flips n â†’ [For each parameter w in N] â†’ BFA_RA (SymPoly + Binary Search) â†’ [Proved] â†’ parameter w marked SAFE / [Unknown] â†’ parameter w added to vulnerable set Î¾ â†’ [If Î¾ is empty] Return TRUE / [Else] BFA_MILP â†’ [Unsatisfiable] â†’ Return TRUE / [Satisfiable] â†’ Return FALSE + counterexample / [Timeout] â†’ Return UNKNOWN

- **Critical path**: The verification bottleneck depends on network size and vulnerability distribution. For most benign QNNs, BFA_RA proves >99% of parameters safe, making the MILP phase minimal. For vulnerable networks, MILP solving on the reduced parameter set determines feasibility.

- **Design tradeoffs**: Abstraction precision vs. computational cost (SymPoly is polynomial-time but incomplete; tighter abstractions increase queries but may avoid expensive MILP); MILP completeness vs. scalability (MILP guarantees completeness but is NP-complete; BFAVerifier relies on SymPoly to reduce problem size); Parameter-only vs. activation quantization (current implementation assumes parameter-only quantization; extending to quantized activations requires additional abstract transformers).

- **Failure signatures**: High "Unknown" rate from SymPoly indicates abstraction too loose; try reducing binary search termination threshold or increasing sub-interval division depth; MILP timeouts indicate vulnerable parameter set Î¾ too large; check if earlier layers have disproportionate vulnerability; disagreement between naive and SymPoly represents over-approximation precision differences in the abstract domain.

- **First 3 experiments**: 1) Baseline validation on small QNNs: Run BFAVerifier on MNIST 3blk_10 with Q=4, n=1, r=0, verify >99% parameters proven safe and correct identification of vulnerable parameters; 2) Scalability stress test: Compare BFA_RA against naive method on larger networks (3blk_512, 5blk_1024) measuring wall-clock time and query count; 3) Precision loss analysis: For network where SymPoly returns "Unknown" for some parameters, inspect whether vulnerable parameter interval spans positive/negative values and test whether forcing additional binary search iterations can recover some "Unknown" parameters as "Proved" without triggering MILP.

## Open Questions the Paper Calls Out

- How can the framework be extended to efficiently verify bit-flip attacks where multiple parameters are compromised simultaneously (i.e., ð”ª > 1)? The authors state extending the threat model to attack multiple parameters poses a "significant and non-trivial challenge" regarding how to partition parameter combinations for abstraction-refinement without causing exponential computation growth.

- Can integrating BFAVerifier with complementary techniques, such as Branch-and-Bound for ReLU splitting or optimizable lower bounds, improve verification precision and scalability? The authors mention BFAVerifier could be integrated with techniques like Branch-and-Bound and optimizable lower bounds as a "promising extension for future work" to address barriers to tight relaxation-based verification.

- How can the MILP-based component be optimized to prevent timeout failures when scaling to larger networks with thousands of neurons? The paper notes verification tasks for networks with architecture 3blk_512 failed to complete within the 1-hour timeout, highlighting a scalability limit for larger networks despite efficiency gains of SymPoly.

## Limitations
- Scalability is primarily limited by MILP solver performance on networks with large vulnerable parameter sets, though SymPoly effectively reduces this set in most cases
- Current implementation assumes parameter-only quantization, with quantized activations identified as future work that could expand the attack surface
- Binary search increases the number of SymPoly queries but remains efficient due to fast GPU operations

## Confidence
- **High Confidence**: Theoretical soundness and completeness guarantees of BFAVerifier, the SymPoly abstraction mechanism, and core experimental results showing 30x speedup over naive verification
- **Medium Confidence**: Scalability claims for larger networks (3blk_512, 5blk_1024) and generalizability to other network architectures beyond those tested
- **Medium Confidence**: Analysis of parameter vulnerability clustering in ACAS Xu, which depends on specific 45 QNN instances generated

## Next Checks
1. **MILP Scalability Stress Test**: Measure the performance gap between SymPoly and MILP phases on increasingly large vulnerable parameter sets (Î¾) to quantify the practical limits of completeness
2. **Activation Quantization Extension**: Implement and evaluate SymPoly with quantized activation functions to assess the expanded attack surface and verification overhead
3. **Random Input Sensitivity Analysis**: Repeat key experiments with multiple random input selections to evaluate the stability of vulnerability findings across different input distributions