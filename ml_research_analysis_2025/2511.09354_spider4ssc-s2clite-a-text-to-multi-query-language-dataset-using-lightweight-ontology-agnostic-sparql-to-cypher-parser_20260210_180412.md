---
ver: rpa2
title: 'Spider4SSC & S2CLite: A text-to-multi-query-language dataset using lightweight
  ontology-agnostic SPARQL to Cypher parser'
arxiv_id: '2511.09354'
source_url: https://arxiv.org/abs/2511.09354
tags:
- sparql
- cypher
- queries
- query
- self
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: This paper introduces Spider4SSC, a unified text-to-query language
  dataset containing 4525 unique questions with semantically equivalent SQL, SPARQL,
  and Cypher queries, and S2CLite, a lightweight parser that translates SPARQL queries
  into Cypher without requiring external RDF graphs or tools. Unlike existing solutions,
  S2CLite uses a rule-based approach inspired by traditional compilers, enabling ontology-agnostic
  parsing.
---

# Spider4SSC & S2CLite: A text-to-multi-query-language dataset using lightweight ontology-agnostic SPARQL to Cypher parser

## Quick Facts
- **arXiv ID:** 2511.09354
- **Source URL:** https://arxiv.org/abs/2511.09354
- **Reference count:** 28
- **Primary result:** Introduces Spider4SSC dataset and S2CLite parser achieving 77.8% parsing accuracy and 96.6% execution accuracy on SPARQL to Cypher translation.

## Executive Summary
This paper presents Spider4SSC, a unified text-to-query language dataset containing 4525 unique questions with semantically equivalent SQL, SPARQL, and Cypher queries, and S2CLite, a lightweight parser that translates SPARQL queries into Cypher without requiring external RDF graphs or tools. Unlike existing solutions, S2CLite uses a rule-based approach inspired by traditional compilers, enabling ontology-agnostic parsing. The parser achieves 27.4% reduction in parsing errors compared to state-of-the-art S2CTrans, with 77.8% total parsing accuracy versus 44.2%. On the subset of queries parsed by both parsers, S2CLite achieves 96.6% execution accuracy, outperforming S2CTrans by 7.3%.

## Method Summary
S2CLite uses an ANTLR4-based parser with the `sparkle-g` grammar to build a parse tree from SPARQL queries. A custom `Visitor` class traverses this tree to generate an Abstract Syntax Tree (AST), which an `Interpreter` then assembles into a Cypher query using builder classes. The parser operates without requiring an RDF graph, instead inferring graph topology directly from SPARQL triple patterns using a two-pass visitor system. The method does not involve model training but relies on deterministic rule application to translate SPARQL 1.1 grammar constructs into equivalent Cypher syntax.

## Key Results
- Achieved 77.8% parsing accuracy on Spider4SPARQL dataset, a 27.4% reduction in parsing errors compared to S2CTrans
- On the intersection of parsed queries, achieved 96.6% execution accuracy, outperforming S2CTrans by 7.3%
- Successfully parsed 1,032 dev and 6,899 train SPARQL queries from the Spider4SPARQL dataset
- Demonstrated ontology-agnostic translation capability without requiring external RDF graphs or tools

## Why This Works (Mechanism)

### Mechanism 1
The parser achieves ontology-agnostic translation by inferring graph topology directly from SPARQL triple patterns using a two-pass visitor system. In the first pass, the Visitor identifies entity nodes by locating `rdf:type` assertions (Type 1 patterns). In the second pass, it classifies remaining triples based on the variables identified in step one. If both subject and object of a triple correspond to identified nodes, it maps the predicate to a Cypher relationship; if the object is a literal, it maps to a node property. Core assumption: The structure of the desired Property Graph can be heuristically derived from the variable bindings in the SPARQL query without accessing the external ontology.

### Mechanism 2
Complex SPARQL solution modifiers (GROUP BY, HAVING) are mapped to Cypher by explicitly synthesizing intermediate `WITH` clauses to handle aggregation scoping. The Visitor captures SPARQL aggregations and `HAVING` constraints. The Interpreter then generates a Cypher `WITH` clause to project aliases (e.g., `AVG(x.age) AS avg`) and applies a secondary `WHERE` clause immediately after this `WITH` to replicate `HAVING` logic, which Cypher lacks natively. Core assumption: Cypher's pipe-line execution order strictly corresponds to SPARQL's solution modifier application order.

### Mechanism 3
Rule-based parsing achieves higher coverage (lower error rate) than existing semantic transpilers by strictly adhering to SPARQL 1.1 grammar definitions rather than relying on fragile external tool integrations. S2CLite uses the `sparkle-g` grammar (ANTLR4) to build a parse tree and applies deterministic visitor rules. This avoids "Black Box" errors found in S2CTrans (which relies on Jena/Neosemantics) and explicitly supports syntax often missed by semantic parsers, such as `SELECT *` or `COUNT(*)`. Core assumption: The source SPARQL queries are syntactically correct and adhere strictly to SPARQL 1.1 standards.

## Foundational Learning

- **Concept: Abstract Syntax Tree (AST)**
  - **Why needed here:** The core of S2CLite is the transformation of a concrete Parse Tree (from ANTLR) into an intermediate AST (graph `G`) before generating Cypher. You must understand how `G` stores nodes, properties, and relationships to debug the translation.
  - **Quick check question:** In the Visitor output (Graph `G`), how does the parser distinguish a variable intended as a node label vs. a literal value?

- **Concept: Property Graph vs. RDF Triple Model**
  - **Why needed here:** The fundamental translation challenge. RDF uses triples `(s, p, o)` for everything. Property Graphs use nodes with properties and directed relationships. The parser must "guess" if `?x :knows ?y` is a relationship (edge) or a property (attribute), which drives the "Two-Pass" logic.
  - **Quick check question:** Why does the S2CLite parser need to know if `?y` has an `rdf:type` before deciding if `?x :knows ?y` is a relationship?

- **Concept: Visitor Pattern (Compiler Design)**
  - **Why needed here:** The software implementation relies on the Visitor design pattern to walk the ANTLR parse tree. Understanding "enter/exit" logic and how context is passed (e.g., checking if inside an aggregate function) is required to extend the parser.
  - **Quick check question:** Which specific node types does the `visitAggregate` handler trigger on, and how does it update the `G_WITH` map?

## Architecture Onboarding

- **Component map:** Input SPARQL Query String -> ANTLR4 + `sparkle-g` grammar -> Parse Tree (`Ts`) -> `Visitor` class (builds AST `G`) -> `Interpreter` class (uses Builders: `MATCHBuilder`, `WHEREBuilder`, `WITHBuilder`) -> Output Cypher Query String

- **Critical path:** The `Visitor._categorise_patterns` (Alg 2) is the most sensitive component. It determines if a triple is a relationship or a property. Any modification here (e.g., adding support for implicit relationships) cascades into the `MATCHBuilder` and `RETURNBuilder`.

- **Design tradeoffs:**
  - **Accuracy vs. Portability:** The parser is "ontology-agnostic" (portable) but "optimistic." It assumes variables appearing in subject position are nodes. This increases portability but creates "False Positives" (syntactically valid Cypher that executes wrong) compared to an ontology-aware parser.
  - **Explicit Relationships:** To fix pattern recognition errors, the system allows passing a list `Re` of explicit relationship names, trading off "zero-config" for accuracy.

- **Failure signatures:**
  - **N4j_EXEC Errors:** Syntactically valid Cypher that crashes Neo4j. Often caused by unsupported nested queries (NS2 errors) or bad variable scoping in `WITH` clauses.
  - **VAL / NUM_RES Errors:** Semantic mismatches. Often caused by the "Optional Relationship" ordering issue (placing MATCH after WHERE vs before).

- **First 3 experiments:**
  1. **BSBM42 Baseline:** Run the 42 BSBM queries to verify the "OptionalRelationship" error case and ensure basic pattern matching works.
  2. **Spider4SPARQL Stress Test:** Run the parser on the `Spider4SPARQL` DEV set (1032 queries) and categorize failures into `NS1`/`NS2` to quantify coverage limits.
  3. **Explicit Relationship Ablation:** Re-run queries with high `NUM_RES` errors using the `Re` (Explicit Relationship) parameter to measure how much "schema hinting" improves semantic accuracy.

## Open Questions the Paper Calls Out

- **Open Question 1:** How can S2CLite's rule-based architecture be extended to robustly support nested SELECT clauses (NS2)? The paper aims to implement support for simple nested queries to eliminate this limitation and further increase parsing accuracy. Current logic does not handle structured queries like nested SELECTs, resulting in a specific parsing error group (NS2) accounting for ~8% of Spider4SPARQL errors.

- **Open Question 2:** What modifications are required to correctly order `MATCH` and `WHERE` clauses for `OPTIONAL` patterns? The parser lacks the logic to position `MATCH` patterns after `WHERE` clauses, which is required to produce execution results equivalent to SPARQL for specific optional relationship queries.

- **Open Question 3:** Can the definition of explicit constraints be refined to reduce "false positive" Cypher queries? While parsing accuracy is high, many queries parse successfully but fail execution (N4j_EXEC), calling for better definition of explicit constraints and boundaries.

- **Open Question 4:** How does S2CLite perform when applied to Text-to-SPARQL datasets beyond Spider4SPARQL? The current experiments are limited to the BSBM42 and Spider4SPARQL datasets, leaving generalizability to other benchmarks unconfirmed.

## Limitations

- The ontology-agnostic approach introduces inherent limitations in semantic accuracy, leading to false positives (8-13% N4j_EXEC errors) and semantic mismatches (22-28% VAL/NUM_RES errors)
- The two-pass algorithm may fail for triples connecting two entities where neither was explicitly typed in the query
- Explicit support for only basic SPARQL 1.1 constructs means complex nested queries or advanced features may fail parsing (NS2 errors)
- The parser relies on heuristic pattern matching rather than explicit schema knowledge, limiting semantic precision

## Confidence

- **High Confidence:** Parsing accuracy metrics (77.8% on Spider4SPARQL) and the 27.4% reduction in parsing errors compared to S2CTrans are directly verifiable from reported experimental results
- **Medium Confidence:** Execution accuracy claims (96.6% on parsed intersection) depend on the quality of the RDF-to-property graph materialization process, which is not fully detailed
- **Medium Confidence:** The ontology-agnostic claim is supported by the described mechanism but could be further validated through experiments on diverse ontologies

## Next Checks

1. Execute the 42 BSBM benchmark queries to verify basic pattern matching and identify the "Optional Relationship" error case mentioned in the paper
2. Run the parser on the Spider4SPARQL DEV set (1032 queries) and categorize failures into NS1/NS2 types to quantify coverage limits and identify patterns of failure
3. Re-run queries with high NUM_RES errors using the Re (explicit relationships) parameter to measure how much schema hinting improves semantic accuracy and quantify the tradeoff between ontology-agnosticism and precision