---
ver: rpa2
title: 'MeanCache: From Instantaneous to Average Velocity for Accelerating Flow Matching
  Inference'
arxiv_id: '2601.19961'
source_url: https://arxiv.org/abs/2601.19961
tags:
- arxiv
- meancache
- acceleration
- caching
- diffusion
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: MeanCache introduces a training-free caching framework that shifts
  from instantaneous to average velocity in Flow Matching inference. By leveraging
  cached Jacobian-vector products to construct interval average velocities, it effectively
  mitigates local error accumulation and trajectory deviations under high acceleration
  ratios.
---

# MeanCache: From Instantaneous to Average Velocity for Accelerating Flow Matching Inference

## Quick Facts
- **arXiv ID:** 2601.19961
- **Source URL:** https://arxiv.org/abs/2601.19961
- **Reference count:** 21
- **Primary result:** MeanCache achieves 4.12×, 4.56×, and 3.59× speedups on FLUX.1, Qwen-Image, and HunyuanVideo while outperforming state-of-the-art caching baselines in generation quality

## Executive Summary
MeanCache introduces a training-free caching framework that accelerates Flow Matching inference by shifting from instantaneous to average velocity. The method leverages cached Jacobian-vector products (JVP) to construct interval average velocities, effectively mitigating local error accumulation and trajectory deviations under high acceleration ratios. A trajectory-stability scheduling strategy employing peak-suppressed shortest path optimization further improves cache timing and JVP reuse stability. Experiments demonstrate consistent speedups across three model families while maintaining or improving generation quality metrics.

## Method Summary
MeanCache operates in two key components: (1) a JVP-based cache estimator that approximates average velocity using cached states and derivatives, and (2) a trajectory-stability scheduling strategy that optimizes cache timing under budget constraints. The method reformulates caching in the average-velocity domain where velocities are smoother, reducing local deviations that compound under reuse. The JVP approximation connects instantaneous and average velocities by estimating the derivative term using reference points. A multigraph-based peak-suppressed shortest path optimization schedules cache steps to minimize error concentration while maximizing acceleration.

## Key Results
- Achieves 4.12×, 4.56×, and 3.59× speedups on FLUX.1, Qwen-Image, and HunyuanVideo respectively
- Consistently outperforms state-of-the-art caching baselines in generation quality metrics
- Maintains stability across diverse prompts and seeds while enabling high acceleration ratios

## Why This Works (Mechanism)

### Mechanism 1
Average velocity provides more stable guidance than instantaneous velocity. The paper demonstrates that instantaneous velocities fluctuate sharply along denoising trajectories while average velocity remains smoother, reducing local deviations under caching reuse. This stability correlates with generation quality.

### Mechanism 2
Cached JVP from reference timesteps approximates the derivative term connecting instantaneous to average velocity. Using the start-point identity, the derivative term is approximated via reference points before the current timestep, with hyperparameter K controlling retrieval span.

### Mechanism 3
Budget-constrained peak-suppressed shortest-path scheduling improves cache timing by preventing error concentration. Timesteps are represented as graph nodes with edges weighted by prediction errors, and peak suppression parameter γ penalizes high-error edges to smooth the error distribution.

## Foundational Learning

- **Concept: Flow Matching ODE formulation**
  - Why needed: MeanCache operates on velocity fields dx_t = v_θ(x_t, t)dt
  - Quick check: Can you explain why Flow Matching uses linear interpolation x_t = (1-t)x_0 + tx_1 as the transport path?

- **Concept: Jacobian-Vector Products (JVP)**
  - Why needed: The core approximation requires understanding how JVP connects velocity derivatives to cached states
  - Quick check: Given z_r, z_t, and v(z_r, r), how would you compute the JVP approximation in Eq. 9?

- **Concept: Shortest-path dynamic programming with constraints**
  - Why needed: The scheduling strategy solves a constrained optimization over the multigraph
  - Quick check: How does the peak-suppression parameter γ change the objective from standard shortest-path?

## Architecture Onboarding

- **Component map:** JVP Cache Module -> Average Velocity Estimator -> Stability Graph Builder -> Peak-Suppressed Path Solver -> Integration Layer
- **Critical path:** 1) Run reference trajectory to collect (z_t, v_t) pairs; 2) Build stability graph computing L_K(t,s) errors; 3) Solve for shortest path under budget B; 4) At inference, follow schedule using cached average velocity
- **Design tradeoffs:** Larger K reuses more distant cache (more savings but higher approximation error); lower budget B enables higher acceleration but requires more aggressive caching; higher γ smooths error distribution but may miss locally optimal skips
- **Failure signatures:** Severe blurring at >3.5× acceleration suggests γ too low or B too aggressive; LPIPS spiking indicates misaligned cache schedule; content drift under rare-word prompts suggests schedule overfitting
- **First 3 experiments:** 1) Run FLUX.1 with 50 steps (no caching) as baseline; 2) Fix B=15, vary K∈{1,2,3,4,5} to confirm K=1 underperforms; 3) Compute shortest path for B=10 and visualize skipped timesteps

## Open Questions the Paper Calls Out
None

## Limitations
- Quality degradation at extreme acceleration ratios (>4×) remains a concern for the JVP approximation
- Schedule stability across truly out-of-distribution prompts and latent space geometries is untested
- Precomputation overhead for stability maps may limit applicability to rapidly changing model architectures

## Confidence

- **High confidence:** Empirical speedups and quality metrics are well-supported; rigorous comparison against baselines; clear ablation trends
- **Medium confidence:** Average velocity stability advantage depends on velocity field smoothness; may diminish in highly nonlinear trajectories
- **Medium confidence:** Peak-suppressed scheduling generalization relies on consistent latent value changes across prompts; robustness in extreme cases untested

## Next Checks

1. **Extreme acceleration stress test:** Run MeanCache at B=5 (6× speedup) on FLUX.1 and measure quality degradation to identify breaking point
2. **Cross-domain stability transfer:** Apply precomputed schedule from FLUX.1 to Qwen-Image without retraining to quantify schedule domain dependence
3. **K-sensitivity analysis:** Sweep K from 2 to 5 at fixed B=15 for each model to identify localized failure points