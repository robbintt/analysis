---
ver: rpa2
title: Foundations of Global Consistency Checking with Noisy LLM Oracles
arxiv_id: '2601.13600'
source_url: https://arxiv.org/abs/2601.13600
tags:
- facts
- consistent
- consistency
- incons
- oracle
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: This paper introduces the task of scalable global consistency checking
  for natural language facts using noisy LLM oracles. The authors formalize the problem
  and prove that pairwise consistency checks are insufficient to guarantee global
  coherence, with worst-case exponential query complexity.
---

# Foundations of Global Consistency Checking with Noisy LLM Oracles

## Quick Facts
- arXiv ID: 2601.13600
- Source URL: https://arxiv.org/abs/2601.13600
- Reference count: 36
- Primary result: Scalable global consistency checking via QXR algorithm outperforms direct LLM judging on recall/F1

## Executive Summary
This paper tackles the challenge of verifying global consistency across sets of natural language facts when using noisy LLM oracles. The authors prove that pairwise consistency checks are insufficient for global coherence and that worst-case query complexity is exponential. They introduce the QXR algorithm, which combines QuickXplain divide-and-conquer MUS extraction with greedy hitting set repairs, achieving substantially higher recall and F1 scores compared to direct all-at-once LLM judging on VitaminC and FEVER datasets.

## Method Summary
The paper formalizes global consistency checking as identifying Minimal Unsatisfiable Subsets (MUSes) from sets of natural language facts using noisy LLM oracles. The QXR algorithm operates in two phases: (1) MUS extraction via QuickXplain, a divide-and-conquer method that recursively queries the oracle on subsets to find minimal inconsistent sets, and (2) greedy hitting set repair that removes the smallest set of facts covering all discovered MUSes. The approach assumes bounded oracle noise (error rates α, β) and MUS size (k ≤ 6), achieving O(k log|S|) query complexity per MUS compared to exponential complexity for brute-force methods.

## Key Results
- QXR achieves substantially higher recall (0.85-0.95) and F1 compared to direct LLM judging baseline (0.6-0.85) on VitaminC and FEVER
- Worst-case query complexity for pairwise checks is exponential, proving insufficiency for global consistency
- QXR's adaptive divide-and-conquer approach reduces query complexity to O(k log|S|) per MUS
- All tested LLMs (GPT-3.5, GPT-4, Claude) exhibit "panic-pruning" behavior in direct baseline, removing too many claims

## Why This Works (Mechanism)
The QXR algorithm works by adaptively focusing oracle queries on subsets that are most likely to contain contradictions, rather than checking all possible combinations. QuickXplain recursively splits the fact set and queries only inconsistent branches, localizing conflicts efficiently. The greedy hitting set then removes the minimal set of facts that cover all identified MUSes, achieving repairs that maximize the size of the consistent subset. This targeted approach avoids the exponential blowup of exhaustive checking while being robust to oracle noise through its divide-and-conquer strategy.

## Foundational Learning
- **Minimal Unsatisfiable Subset (MUS)**: Smallest set of facts that cannot be simultaneously true. Needed because global consistency requires finding all contradictions, not just detecting their existence. Quick check: MUS size k ≤ 6 in experiments.
- **Greedy Hitting Set**: Algorithm that iteratively selects facts covering the most uncovered MUSes. Needed for efficient repair without exhaustive search. Quick check: H = {f ∈ F | f appears in ≥1 MUS}.
- **QuickXplain Algorithm**: Divide-and-conquer method for MUS extraction with O(k log|S|) query complexity. Needed to avoid exponential brute-force checking. Quick check: Base case returns singleton when oracle says inconsistent.
- **LLM Oracle Noise Model**: Binary error rates α (false positive) and β (false negative) for consistency queries. Needed to characterize when the approach is feasible. Quick check: Paper assumes α, β are small constants.
- **Pairwise vs Global Consistency**: Two facts can be pairwise consistent but globally inconsistent with a third. Needed to prove hardness of the problem. Quick check: 3-cycle contradiction example.

## Architecture Onboarding
**Component Map**: Claims F -> QuickXplain -> MUSes {U_j} -> Greedy Hitting Set -> Consistent Subset F'
**Critical Path**: QXR algorithm (Algorithm 1) -> QuickXplain recursive MUS extraction (Algorithm 2) -> Greedy hitting set repair -> Final consistent subset
**Design Tradeoffs**: Adaptive querying vs. query complexity - QXR trades some precision for exponential query savings; greedy repair vs. optimal repair - heuristic is faster but may not find globally optimal solution
**Failure Signatures**: Low recall indicates "panic-pruning" by LLM; high false positive rate in MUS extraction suggests oracle noise too high; non-termination suggests base cases not properly handled
**First Experiments**: 1) Implement QuickXplain on synthetic 3-cycle contradiction to verify MUS extraction; 2) Test greedy hitting set on pre-computed MUSes to verify repair; 3) Compare QXR vs. direct baseline on small VitaminC clusters

## Open Questions the Paper Calls Out
None

## Limitations
- Relies on access to LLM oracle with controlled error rates; performance degrades with high α, β
- Scalability to very large fact sets (beyond 30 statements) remains unproven
- Greedy hitting set repair is heuristic and may not find globally optimal solutions
- Paper doesn't provide exact LLM configuration details (temperature, top-p, max tokens)

## Confidence
- **High**: Theoretical hardness results, empirical superiority of QXR over direct baseline
- **Medium**: Scalability claims, heuristic repair optimality
- **Low**: LLM oracle configuration specifics, exact data preprocessing details

## Next Checks
1. Test QXR on fact sets larger than 30 statements to verify claimed scalability.
2. Compare QXR's greedy hitting set repair against exact (exponential-time) solutions on small instances to bound approximation quality.
3. Evaluate oracle error rate sensitivity by systematically varying α and β in controlled synthetic experiments.