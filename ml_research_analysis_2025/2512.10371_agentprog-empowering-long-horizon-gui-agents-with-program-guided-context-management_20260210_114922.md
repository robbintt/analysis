---
ver: rpa2
title: 'AgentProg: Empowering Long-Horizon GUI Agents with Program-Guided Context
  Management'
arxiv_id: '2512.10371'
source_url: https://arxiv.org/abs/2512.10371
tags:
- task
- context
- tasks
- agentprog
- agents
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: This paper tackles the challenge of managing context in long-horizon
  GUI agent tasks, where traditional approaches struggle with context overhead and
  loss of semantic information. AgentProg introduces a program-guided context management
  framework that reframes interaction history as a Semantic Task Program with variables
  and control flow, providing principled mechanisms to determine what information
  to retain or discard.
---

# AgentProg: Empowering Long-Horizon GUI Agents with Program-Guided Context Management

## Quick Facts
- arXiv ID: 2512.10371
- Source URL: https://arxiv.org/abs/2512.10371
- Reference count: 40
- Primary result: 78.0% success rate on AndroidWorld and 68.4% on AW-Extend benchmarks

## Executive Summary
This paper addresses the challenge of context management in long-horizon GUI agent tasks, where traditional approaches struggle with context overhead and semantic information loss. AgentProg introduces a program-guided context management framework that reframes interaction history as a Semantic Task Program with variables and control flow, providing principled mechanisms to determine what information to retain or discard. The approach incorporates a global belief state to handle partial observability and dynamic environments, enabling more efficient and semantically meaningful context management for GUI agents.

## Method Summary
AgentProg tackles the challenge of context management in long-horizon GUI agent tasks by introducing a program-guided approach that reframes interaction history as a Semantic Task Program with variables and control flow. The method incorporates a global belief state to handle partial observability and dynamic environments, providing principled mechanisms to determine what information to retain or discard. This approach aims to overcome the limitations of traditional methods that suffer from context overhead and loss of semantic information when dealing with complex, multi-step GUI interactions.

## Key Results
- Achieved 78.0% success rate on AndroidWorld benchmark
- Achieved 68.4% success rate on AW-Extend benchmark
- Significantly outperformed existing methods in long-horizon GUI task scenarios

## Why This Works (Mechanism)
The paper's approach works by reframing interaction history as a Semantic Task Program with variables and control flow, which provides a structured representation of GUI tasks. This program-guided framework allows for principled decision-making about what context information to retain or discard based on the semantic meaning of actions. The incorporation of a global belief state addresses partial observability issues and enables the agent to maintain coherent understanding across dynamic environments, while the program structure helps manage context overhead by focusing on semantically relevant information rather than raw interaction sequences.

## Foundational Learning

**Semantic Task Program:** A structured representation of GUI tasks using variables and control flow constructs. Needed to provide semantic meaning to interaction sequences and enable principled context management. Quick check: Verify that the program can accurately capture complex multi-step GUI workflows with conditional logic.

**Global Belief State:** A comprehensive representation of the agent's understanding of the environment across time steps. Needed to handle partial observability and maintain coherent context in dynamic environments. Quick check: Ensure the belief state can track relevant environmental changes while filtering out noise.

**Program-Guided Context Management:** A mechanism that uses the Semantic Task Program to determine what information to retain or discard. Needed to reduce context overhead while preserving semantic information. Quick check: Validate that context pruning doesn't remove information critical to task completion.

## Architecture Onboarding

**Component Map:** User Interface -> Semantic Parser -> Task Program Generator -> Context Manager -> Global Belief State -> Action Selector -> Environment

**Critical Path:** User Action → Semantic Parser → Task Program Update → Context Management Decision → Global Belief State Update → Action Selection

**Design Tradeoffs:** The approach trades computational overhead from maintaining a global belief state and generating semantic programs against improved semantic context management and reduced context loss. This design prioritizes semantic accuracy over raw efficiency but may struggle with highly dynamic environments where belief state updates become costly.

**Failure Signatures:** System failures may manifest as incorrect program generation leading to poor context management decisions, global belief state becoming outdated in highly dynamic environments, or excessive computational overhead from maintaining complex program structures and belief states.

**First Experiments:**
1. Compare context retention accuracy between program-guided and traditional context management approaches
2. Evaluate global belief state accuracy against ground truth environmental states
3. Measure the impact of program generation errors on overall task success rates

## Open Questions the Paper Calls Out
None

## Limitations
- The approach relies heavily on accurate Semantic Task Program generation, and errors in program generation could propagate through the system
- Maintaining a global belief state introduces computational overhead that may become challenging to scale for extremely long task sequences
- The method's effectiveness is fundamentally dependent on the quality of program generation, which may not be feasible for highly complex or unpredictable GUI tasks

## Confidence

**High Confidence:** Experimental results showing improved performance over baselines (78.0% on AndroidWorld, 68.4% on AW-Extend) appear robust with clear quantitative comparisons and multiple task categories evaluated.

**Medium Confidence:** Claims about "efficiency" improvements need more scrutiny as the paper mentions efficiency but doesn't provide detailed runtime or memory usage comparisons against baseline methods.

**Medium Confidence:** Scalability claims for long-horizon tasks are supported by experiments but the evaluation focuses primarily on AndroidWorld and its extension, which may not fully represent real-world GUI environment diversity.

## Next Checks

1. Conduct ablation studies isolating the impact of program-guided context management from other architectural components to quantify the specific contribution of the proposed approach.

2. Test the system on additional GUI automation benchmarks beyond AndroidWorld to evaluate generalization across different platforms and task types.

3. Perform stress tests with intentionally corrupted or incomplete Semantic Task Programs to assess the system's robustness to program generation errors and its ability to recover from such failures.