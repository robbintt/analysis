---
ver: rpa2
title: 'ELIZA Reanimated: The world''s first chatbot restored on the world''s first
  time sharing system'
arxiv_id: '2501.06707'
source_url: https://arxiv.org/abs/2501.06707
tags:
- eliza
- code
- ctss
- input
- lisp
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: "The researchers successfully restored the world\u2019s first chatbot,\
  \ ELIZA, on the world\u2019s first time-sharing system, CTSS, running on an emulated\
  \ IBM 7094. They discovered original MAD-SLIP code and early DOCTOR script in Joseph\
  \ Weizenbaum\u2019s archives, then spent months debugging and completing the code\
  \ to make it functional again after 60 years."
---

# ELIZA Reanimated: The world's first chatbot restored on the world's first time sharing system

## Quick Facts
- arXiv ID: 2501.06707
- Source URL: https://arxiv.org/abs/2501.06707
- Reference count: 40
- Primary result: Original ELIZA chatbot restored on CTSS/IBM 7094 emulator

## Executive Summary
The researchers discovered Joseph Weizenbaum's original ELIZA code and DOCTOR script in his archives, then spent months restoring it to run on an emulated IBM 7094 with CTSS. The restoration involved transcribing 2600 lines of MAD-SLIP code from printouts, implementing missing functions, and fixing a single-character FAP assembly error. The restored ELIZA can hold complete conversations and replicates the famous "Men are all alike" dialogue from the 1966 CACM paper with high fidelity.

## Method Summary
The team built an IBM 7094 emulator and installed CTSS, then compiled the discovered MAD-SLIP source code with FAP assembler. They implemented seven missing functions (BCDIT, INLST, LETTER, KGETBL, PLUS, NUMB, DEL) based on documentation, fixed a one-character typo in SQIN.FAP, and compiled the CTSS "huge loader" to handle object file limits. The DOCTOR script was corrected to match the 1966 paper version, and the system was tested through reproduction of the canonical dialogue.

## Key Results
- ELIZA restored to run on original CTSS/IBM 7094 platform with 96% code fidelity
- Successfully reproduces "Men are all alike" dialogue from 1966 CACM paper (two minor divergences)
- Complete teaching mode discovered and operational, allowing runtime script modification
- Open source release enables anyone with Unix-like OS to run original chatbot on original time-sharing system

## Why This Works (Mechanism)

### Mechanism 1: Pattern Matching via Keyword-Transformation Rules
ELIZA generates responses by matching input keywords to predefined transformation rules with ranked priority. The DOCTOR script contains keyword entries with associated transformation rules and reassembly patterns. Each keyword has a numerical rank determining processing order. Upon input, ELIZA scans for keywords, selects the highest-ranked match, applies transformations, and generates output by reassembling fragments from user input. The `LETTER` function classifies characters into 14 categories to support pattern parsing. Links at the transformation rule level allow keyword redirection.

### Mechanism 2: List Processing for Symbolic Structure Manipulation
SLIP (Symmetric List Processor) enables ELIZA to manipulate symbolic language structures through list operations inherited from IPL and Lisp traditions. MAD-SLIP provides list processing capabilities including `INLST` (adds cells from one list to the left of another), `XMATCH` and `ASSMBL` (critical for pattern matching and reassembly). These operate on s-expression-like structures representing both script rules and parsed input. The architecture separates list processing (SLIP) from algorithmic logic (MAD), enabling symbolic manipulation of language elements as structured data.

### Mechanism 3: Interactive Teaching Mode for Script Evolution
ELIZA supports runtime modification of behavioral rules through an interactive teaching interface, enabling incremental improvement without code changes. Teaching mode (activated by `+` input) provides seven commands: ADD, APPEND, SUBST, TYPE, DISPLA, RANK, and START. These allow modification of transformation rules, reassembly patterns, and keyword priorities during active sessions. The `*` command provides fast rule addition. Modified scripts can persist to disk files as s-expressions.

## Foundational Learning

- **Time-Sharing Systems**: Why needed - CTSS enabled interactive ELIZA development. Without time-sharing, Weizenbaum would face batch processing with hours-long turnaround, making iterative conversational refinement impractical. Quick check: Can you explain why time-sharing was essential for developing interactive programs like ELIZA versus what batch processing would allow?

- **S-Expressions and List Processing**: Why needed - The DOCTOR script uses s-expression syntax from Lisp/IPL traditions. Understanding this format is necessary to read scripts, debug transformation rules, and use teaching mode. Quick check: Given `((HI ELIZA) (HOW DO YOU DO))`, can you identify pattern versus response and explain its relation to the matching mechanism?

- **BCD Character Encoding (6-bit)**: Why needed - CTSS used 6-bit BCD encoding, packing six characters per 36-bit word. This affects string storage, LETTER function behavior, and debugging approaches. Quick check: Why must a modern engineer understand 6-bit BCD when working with this system, and what complications does it introduce?

## Architecture Onboarding

- Component map: IBM 7094 Emulator -> CTSS -> MAD Compiler + FAP -> MAD-SLIP Runtime -> ELIZA.MAD (~2600 lines) -> DOCTOR Script
- Support: SQIN.FAP (input handling), LETTER/INLST/BCDIT (character utilities)
- Critical path: 1) Build/obtain IBM 7094 emulator (Linux, MacOS tested) 2) Install CTSS image 3) Compile MAD-SLIP components 4) Compile ELIZA.MAD with FAP 5) Load corrected DOCTOR script (file 200 with typo fixes) 6) Execute via `r eliza`
- Design tradeoffs: Authenticity vs. Usability (numeric input bug intentionally preserved for 96% fidelity); Separation of Logic/Behavior (external scripts enable experimentation but lack PRE/NEWKEY support); Memory Constraints (32K user memory required efficient list structures); Teaching vs. Editing (internal teaching mode eventually superseded by CTSS editors)
- Failure signatures: `PROTECTION MODE VIOLATION AT 23174` (FAP assembly error, fix: LAS =H 00000 vs 0000); `PRE 5:$5:$ 5QZ5QZ` (PRE transformation unimplemented, avoid "I'm"); Crash on numeric input (SLIP pointer interpretation); `= DIT` (Reassembly-level keyword links unsupported); Loader failure (requires "huge loader" from CTSS source tape)
- First 3 experiments: 1) Reproduce 1966 "Men are all alike" dialogue with script 200; verify outputs match except two documented divergence points 2) Test teaching mode: create new keyword via ADD, verify trigger, adjust priority with RANK, save and reload 3) Map numeric input failure through SLIP list functions; document crash point without fixes to preserve authenticity

## Open Questions the Paper Calls Out

- **Open Question 1**: Do later or earlier versions of the MAD-SLIP ELIZA source code or its associated scripts exist in other archives? Basis: Authors continue searching archives for versions beyond the discovered early code missing features from 1966 paper. Unresolved because discovered code is early version lacking described features. Evidence: Discovery of additional fan-fold printouts, punch cards, or magnetic tapes in other institutional archives or private collections would resolve.

- **Open Question 2**: What are the behavioral characteristics and intended purposes of the early `.TAPE.100` and `.TAPE.102` DOCTOR scripts discovered with the code? Basis: Authors found two early script versions but had no example conversations with these scripts, relying on corrected 1966 script for testing. Unresolved because no transcripts or documentation regarding these specific early scripts were found. Evidence: Running restored ELIZA with these recovered early scripts and analyzing interaction logic, or finding Weizenbaum's notes on their design.

- **Open Question 3**: Was the "crash on numeric input" bug present in the widely disseminated 1966 version of ELIZA? Basis: Authors identified bug where numeric input crashes system due to memory pointer issues, unclear if flaw in famous public version or bug specific to early developmental build. Unresolved because authors prioritized authenticity over repair, leaving bug in restored code; without exact 1966 source, historical presence cannot be confirmed. Evidence: Discovery of user logs from 1960s mentioning crashes, or locating specific source code version used for CACM 1966 demonstrations to compare input handling routines.

## Limitations

- Restoration achieves ~96% fidelity but required re-implementing seven critical functions (BCDIT, INLST, LETTER, KGETBL, PLUS, NUMB, DEL) based on descriptions rather than original code
- DOCTOR script used differs from 1966 CACM paper version - lacks PRE transformations and NEWKEY rules, limiting conversational sophistication
- Teaching mode functionality discovered but never documented in contemporaneous literature, raising questions about intended public use

## Confidence

- **High Confidence**: The system runs authentically on CTSS/IBM 7094 emulator with minimal modifications; "Men are all alike" dialogue reproduction validates core functionality
- **Medium Confidence**: Re-implemented missing functions behave as described in documentation, but edge cases may differ from original implementation
- **Low Confidence**: Pedagogical value of teaching mode and its intended use cases, given lack of contemporaneous documentation

## Next Checks

1. **Cross-Reference Analysis**: Compare restored DOCTOR script's transformation rules against 1966 CACM paper's examples to document all functional differences and their impact on conversation quality
2. **Boundary Testing**: Systematically test numeric input crashes and other failure modes to precisely characterize SLIP's pointer interpretation vulnerabilities and document crash conditions
3. **Teaching Mode Evaluation**: Use interactive teaching interface to add new transformation rules, then analyze whether introduced rules create conflicts or priority cycles that degrade performance