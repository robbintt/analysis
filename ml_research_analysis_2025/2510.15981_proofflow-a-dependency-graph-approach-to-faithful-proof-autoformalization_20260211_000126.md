---
ver: rpa2
title: 'ProofFlow: A Dependency Graph Approach to Faithful Proof Autoformalization'
arxiv_id: '2510.15981'
source_url: https://arxiv.org/abs/2510.15981
tags:
- proof
- language
- theorem
- natural
- step
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: This paper introduces ProofFlow, a novel pipeline for translating
  natural language proofs into machine-verifiable Lean code while preserving their
  logical structure. The approach constructs a dependency graph (DAG) of proof steps
  and uses a lemma-based formalization strategy to ensure each step follows the original
  proof's logical dependencies.
---

# ProofFlow: A Dependency Graph Approach to Faithful Proof Autoformalization

## Quick Facts
- **arXiv ID:** 2510.15981
- **Source URL:** https://arxiv.org/abs/2510.15981
- **Authors:** Rafael Cabral; Tuan Manh Do; Xuejun Yu; Wai Ming Tai; Zijin Feng; Xin Shen
- **Reference count:** 40
- **Key outcome:** ProofFlow achieves 0.545 ProofScore on undergraduate-level proofs by preserving logical structure through dependency graphs

## Executive Summary
This paper introduces ProofFlow, a novel pipeline for translating natural language proofs into machine-verifiable Lean code while preserving their logical structure. The approach constructs a dependency graph (DAG) of proof steps and uses a lemma-based formalization strategy to ensure each step follows the original proof's logical dependencies. To evaluate performance, the authors present ProofFlowBench, a benchmark of 184 undergraduate-level problems with annotated proofs and dependency graphs, and introduce ProofScore, a composite metric measuring syntactic correctness, semantic faithfulness, and structural fidelity.

## Method Summary
ProofFlow is a three-stage pipeline that translates natural language theorems and proofs into Lean 4 code. First, a Graph Builder LLM parses the NL proof into a DAG mapping logical dependencies between proof steps. Second, a Formalizer LLM translates each node's self-contained NL statement into Lean 4 lemma declarations with "by sorry" placeholders, iterating on Lean compiler errors. Third, a Tactic Completer LLM replaces "by sorry" with complete Lean tactics, also iterating on tactic failures. The pipeline uses Goedel-Formalizer-2/Prover-V2 32B models in thinking mode or DeepSeek-Prover-V2 671B in non-thinking mode, with Pass@5 retry logic.

## Key Results
- ProofFlow achieves 0.545 ProofScore, outperforming full-proof formalization (0.123) and step-proof formalization (0.072)
- Formalizer errors account for 38.9-47.0% of failures, identified as the primary bottleneck
- Thinking mode achieves higher scores (0.545 vs 0.355) but costs 3.6x more computation
- Structural fidelity enforcement prevents logical shortcuts that occur in baseline approaches

## Why This Works (Mechanism)

### Mechanism 1: DAG-constrained Dependency Enforcement
Enforcing explicit dependency graphs prevents logical shortcuts and ensures the formalized proof follows the original reasoning path. The pipeline constructs a DAG G=(V,E) where nodes are proof steps and edges encode logical prerequisites. During formalization, each step can only reference its explicitly declared dependencies, preventing the prover from "shortcutting" through unintended premises.

### Mechanism 2: Lemma-based Decomposition Preserves Reasoning Granularity
Formalizing proof steps as independent lemmas preserves the original proof's reasoning granularity better than tactic-based consolidation. Each proof step becomes a standalone lemma with explicit parameter declarations for its dependencies. This prevents tactics like `linarith` from collapsing multiple logical steps into one opaque operation.

### Mechanism 3: Three-stage Pipeline Enables Localized Error Attribution
Separating graph construction, formalization, and tactic completion into distinct stages enables precise identification of error sources. Each stage produces independently verifiable artifacts—the DAG structure, syntactically valid lemma declarations, and complete proofs. The error detection flowchart traces failures back to specific stages.

## Foundational Learning

- **Directed Acyclic Graphs (DAGs) and topological ordering**: The pipeline centers on constructing and traversing a DAG of proof dependencies; understanding topological sort is necessary to follow why proof steps must be processed in dependency order.
- **Lean 4 syntax: `lemma`, `theorem`, tactics, and `sorry`**: The Formalizer outputs Lean lemma declarations; the Tactic Completer replaces `sorry` placeholders; understanding the difference between lemma signatures and proof tactics is essential.
- **LLM prompting for structured code generation with error feedback**: All three pipeline stages use LLMs with iterative error correction—syntactic errors from Lean are fed back to the LLM for retry.

## Architecture Onboarding

- **Component map:** Graph Builder (LLM) → Formalizer (LLM) → Tactic Completer (LLM) → ProofScore Evaluator
- **Critical path:** NL theorem + proof input → Graph Builder → validated DAG → Formalizer (topological order) → syntactically valid lemmas → Tactic Completer → complete Lean proofs → ProofScore evaluation
- **Design tradeoffs:** DAG enforcement ensures structural fidelity but may reduce syntactic pass rates; thinking mode achieves higher scores but costs 3.6x more computation
- **Failure signatures:** Formalizer errors (38.9-47.0%), tactic completion failures (5.6-21.4%), "unknown identifier" errors from missing definitions
- **First 3 experiments:**
  1. Reproduce DAG vs. noDAG structural fidelity difference on 10 benchmark problems
  2. Compare lemma-based vs. tactic-based on a single theorem to observe consolidation patterns
  3. Trace error attribution on a failing proof using the error detection flowchart

## Open Questions the Paper Calls Out

1. **Can improved semantic preservation in the Formalizer component significantly increase ProofScore beyond the current 0.545?** The paper identifies semantic mismatches as the dominant failure mode but proposes no solution.

2. **What methods can successfully replace the "by sorry" placeholders with complete Lean tactics while preserving structural fidelity?** The pipeline deliberately separates formalization from proof completion, leaving all lemmas unproven.

3. **Can the DAG-based approach generalize to graduate-level or research mathematics with more complex dependency structures?** ProofFlowBench contains only undergraduate-level problems; scalability to advanced proofs is untested.

## Limitations

- Performance heavily depends on specific LLM architectures used (Goedel-32B vs DeepSeek-671B), creating uncertainty about generalizability
- Semantic evaluation reliability is uncertain due to LLM-as-judge using a 0.6 threshold without detailed validation
- Dependency graph extraction may struggle with implicit or circular dependencies in natural language proofs

## Confidence

- **High confidence**: The three-stage pipeline architecture is well-specified with clear error attribution and reproducible evaluation methodology
- **Medium confidence**: Relative performance improvements over baselines are convincing, but absolute ProofScore values depend heavily on the semantic evaluation component
- **Low confidence**: Claims about structural fidelity being "essential for practical automated theorem proving" extrapolate beyond the undergraduate-level benchmark domain

## Next Checks

1. **Judge reliability validation**: Run the LLM-as-judge on a held-out set of manually verified NL-Lean pairs to quantify false positive/negative rates in semantic faithfulness scoring.

2. **DAG extraction robustness test**: Systematically introduce ambiguous cross-references and circular dependencies into benchmark proofs to measure the Graph Builder's failure rate and error recovery capability.

3. **Model transfer experiment**: Replace the Goedel and DeepSeek models with open alternatives (e.g., GPT-4, Claude) using identical prompts to assess whether performance differences are model-specific or architecture-driven.