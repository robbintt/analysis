---
ver: rpa2
title: Benchmarking Deep Learning Convolutions on Energy-constrained CPUs
arxiv_id: '2509.26217'
source_url: https://arxiv.org/abs/2509.26217
tags:
- power
- convolution
- inference
- convolutions
- cpus
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: 'This work benchmarks convolution algorithms on embedded CPUs from
  ARM, Intel, AMD, and NVIDIA, focusing on latency and energy consumption. A novel
  high-frequency socket-level power measurement system is used to evaluate three convolution
  implementations: direct, GEMM-based (im2row and gemm), and Winograd.'
---

# Benchmarking Deep Learning Convolutions on Energy-constrained CPUs

## Quick Facts
- arXiv ID: 2509.26217
- Source URL: https://arxiv.org/abs/2509.26217
- Authors: Enrique Galvez; Adrien Cassagne; Alix Munier; Manuel Bouyer
- Reference count: 31
- Primary result: Novel high-frequency socket-level power measurement system reveals MSR power estimates underestimate consumption by 10-30% on embedded CPUs during CNN inference

## Executive Summary
This work benchmarks convolution algorithms on embedded CPUs from ARM, Intel, AMD, and NVIDIA, focusing on latency and energy consumption. A novel high-frequency socket-level power measurement system is used to evaluate three convolution implementations: direct, GEMM-based (im2row and gemm), and Winograd. Socket measurements are compared with MSR estimates, showing MSRs underestimate power by 10-30%. Among the evaluated configurations, the ARM Cortex-A78AE CPU with implicit GEMM (gemm) delivers the best latency-power trade-off, achieving ResNet50v1.5 inference in 102 ms with 25.3 W average power consumption (2.58 J energy). This study provides the first fair, cross-vendor comparison of CPU energy consumption for CNN inference on embedded systems.

## Method Summary
The study evaluates convolution algorithms on four embedded CPUs using a custom high-frequency socket-level power measurement system capable of 1 MHz sampling rate. Three convolution implementations are benchmarked: direct convolution, GEMM-based (im2row and gemm), and Winograd algorithms. Performance is measured using ResNet50v1.5 inference with batch size 1, capturing both latency and energy consumption metrics. MSR power estimates are compared against socket measurements to quantify accuracy differences, revealing systematic underestimation by MSR methods.

## Key Results
- ARM Cortex-A78AE CPU with GEMM implementation achieves best latency-power trade-off: 102 ms latency, 25.3 W power, 2.58 J energy for ResNet50v1.5 inference
- MSR power estimates systematically underestimate actual consumption by 10-30% compared to high-frequency socket measurements
- Winograd algorithm shows inconsistent performance across different CPU architectures, sometimes increasing energy consumption despite theoretical efficiency gains

## Why This Works (Mechanism)
The study's effectiveness stems from its direct power measurement approach using high-frequency socket-level instrumentation, which captures transient power spikes and provides more accurate energy consumption data than MSR estimates. The comparative methodology across multiple vendors with identical software implementations eliminates bias from different optimization strategies, enabling fair cross-platform performance evaluation.

## Foundational Learning

**CPU Architecture Fundamentals**
*Why needed:* Understanding CPU pipeline stages, cache hierarchy, and instruction-level parallelism is essential for interpreting convolution performance differences
*Quick check:* Can identify how cache misses affect GEMM-based convolution performance

**Convolution Algorithms**
*Why needed:* Different algorithms (direct, im2row, Winograd) have distinct computational complexity and memory access patterns
*Quick check:* Can explain why Winograd reduces arithmetic operations but may increase memory bandwidth requirements

**Power Measurement Techniques**
*Why needed:* MSR vs. socket-level measurements capture different aspects of power consumption with varying accuracy
*Quick check:* Can describe the systematic bias in MSR estimates compared to direct measurements

## Architecture Onboarding

**Component Map**
ARM Cortex-A78AE -> GEMM Convolution -> Power Measurement System -> Performance Analysis
Intel CPU -> Direct Convolution -> MSR Monitoring -> Latency Evaluation
AMD CPU -> Winograd Algorithm -> Socket Power Meter -> Energy Assessment
NVIDIA CPU -> im2row Implementation -> Hybrid Measurement -> Comparative Analysis

**Critical Path**
Convolution kernel execution -> Memory bandwidth utilization -> Power consumption measurement -> Performance metric calculation

**Design Tradeoffs**
GEMM implementations offer better latency-energy trade-off but require larger memory footprint compared to direct convolution; Winograd reduces FLOPs but increases memory traffic and implementation complexity

**Failure Signatures**
Unexpected energy spikes indicate cache thrashing or memory bandwidth saturation; inconsistent latency across runs suggests thermal throttling or power management interference

**First Experiments**
1. Measure baseline power consumption during idle state to establish measurement system accuracy
2. Benchmark all three convolution algorithms on single platform to identify performance ranking
3. Compare MSR vs. socket measurements during steady-state operation to quantify systematic bias

## Open Questions the Paper Calls Out
None

## Limitations
- Evaluation limited to specific embedded CPUs from four vendors, reducing generalizability to broader hardware ecosystem
- Power measurement validation only against MSR estimates without independent calibration using alternative measurement tools
- Focus on ResNet50v1.5 inference restricts applicability to other neural network architectures with different computational characteristics

## Confidence

**High confidence in:** Comparative ranking of convolution algorithms within tested hardware configurations
**Medium confidence in:** Absolute power measurement accuracy due to validation methodology limitations
**Medium confidence in:** Cross-vendor performance comparisons due to potential software optimization differences
**Low confidence in:** Generalizability to non-ResNet architectures or different batch sizes

## Next Checks
1. Validate power measurements using an independent high-precision power meter across multiple test runs to quantify measurement uncertainty
2. Test the same convolution algorithms on additional embedded CPU platforms from other vendors to assess result robustness
3. Evaluate performance with diverse neural network architectures (e.g., MobileNet, EfficientNet) to determine if conclusions hold across different model families