---
ver: rpa2
title: 'Text-to-Layout: A Generative Workflow for Drafting Architectural Floor Plans
  Using LLMs'
arxiv_id: '2509.00543'
source_url: https://arxiv.org/abs/2509.00543
tags:
- design
- furniture
- architectural
- revit
- walls
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: This study introduces an AI-driven workflow that translates natural
  language prompts into structured architectural floor plans and generates corresponding
  3D models in Autodesk Revit. The method combines prompt engineering, JSON encoding,
  and Python scripting, supplemented by a greedy algorithm for furniture placement
  refinement.
---

# Text-to-Layout: A Generative Workflow for Drafting Architectural Floor Plans Using LLMs

## Quick Facts
- arXiv ID: 2509.00543
- Source URL: https://arxiv.org/abs/2509.00543
- Reference count: 40
- This study introduces an AI-driven workflow that translates natural language prompts into structured architectural floor plans and generates corresponding 3D models in Autodesk Revit.

## Executive Summary
This paper presents a novel generative workflow that converts natural language prompts into structured architectural floor plans and corresponding 3D models in Autodesk Revit. The system combines prompt engineering, JSON encoding, and Python scripting, supplemented by a greedy algorithm for furniture placement refinement. Tested on a 30x40 ft residential layout, the workflow produces spatially coherent plans with improved circulation and furniture arrangement. Unlike most commercial tools, the approach is open-source, documented for reproducibility, and generates Revit-native models enriched with full parametric attributes, enabling direct use in BIM environments without manual enrichment.

## Method Summary
The workflow operates in three stages: (1) prompt engineering where GPT-4o receives natural language and strict schema directives to generate JSON layout data containing walls, doors, windows, and furniture with explicit coordinates; (2) Python scripting via Revit API that parses the JSON and creates Revit elements using native creation methods; (3) greedy wall-seeking algorithm for furniture placement refinement that iteratively nudges items toward walls until feasibility conditions are met. The system was tested on a 30x40 ft single-story residential layout with four rooms and various furniture items.

## Key Results
- Successfully generated spatially coherent floor plans from natural language prompts
- Produced Revit-native models with full parametric attributes
- Demonstrated improved circulation and furniture arrangement compared to baseline layouts
- Validated workflow on a 30x40 ft single-story residential layout

## Why This Works (Mechanism)

### Mechanism 1: Structured Intermediate Representation (JSON) for Spatial Decoupling
The workflow decouples semantic design intent from geometric execution by using JSON as a translation layer that constrains LLM output into machine-readable coordinates. GPT-4o receives natural language and strict schema directives, forcing it to commit to specific spatial topology before interacting with the strict BIM environment. The LLM must output explicit arrays for walls, doors, and furniture with start/end coordinates and center points.

### Mechanism 2: Greedy Algorithmic Refinement for Collision Resolution
Spatial feasibility is achieved through post-processing with a greedy algorithm that corrects LLM placement errors using hard geometric constraints. The algorithm iteratively checks furniture positions against feasibility functions looking for boundary violations, clearance breaches (< 1 ft), or wall alignment failures, then "nudges" items toward the nearest wall until constraints are met.

### Mechanism 3: Parametric Bridge via API Script Generation
The system preserves Revit-native parametric attributes by using the LLM to generate executable Python scripts for the Revit API rather than exporting static geometry. A secondary prompt instructs the LLM to write Python code utilizing the `Autodesk.Revit.DB` API with proper transaction management, ensuring resulting elements are standard Revit Families with types, levels, and constraints intact.

## Foundational Learning

- **Concept: BIM Parametric Elements vs. Geometry**
  - Why needed: Understanding that BIM elements are data containers with constraints, not just lines or meshes
  - Quick check: Does the workflow export a static mesh or instantiate native Classes like `Wall.Create`?

- **Concept: Prompt Engineering & Schema Enforcement**
  - Why needed: The mechanism relies on LLM outputting valid JSON through schema constraints
  - Quick check: What specific format does the prompt require for wall definitions?

- **Concept: Geometric Feasibility & Clearance**
  - Why needed: Understanding basic computational geometry for collision resolution
  - Quick check: How does the system determine if an LLM-placed bed overlaps with a wall?

## Architecture Onboarding

- **Component map:** User Interface -> GPT-4o (Text → JSON) -> Python Interpreter (JSON + Greedy Algorithm) -> Revit API (Creates native BIM elements) -> Revit Project File (.rvt)
- **Critical path:** The transition from Text → JSON is the highest risk point; malformed JSON or nonsensical coordinates will crash downstream processing
- **Design tradeoffs:** Open source transparency vs. ease of use (manual setup vs. black box commercial tools); greedy local search vs. global optimization for furniture placement
- **Failure signatures:** Hallucinated coordinates outside bounds, API drift causing script failures, deadlock when algorithm cannot resolve all collisions
- **First 3 experiments:**
  1. Validate JSON output from Figure 3 prompt for correct structure and coordinate bounds
  2. Test Python script with hardcoded simple JSON to verify Revit API connection
  3. Run greedy algorithm on intentionally overlapping furniture to observe collision resolution

## Open Questions the Paper Calls Out
- How does the workflow perform on complex geometries or multi-level buildings? (Only tested on simple single-story rectangular layouts)
- Can the greedy algorithm maintain performance in large-scale or densely populated spatial configurations? (Only tested on mid-sized residential layout)
- Can building code compliance and accessibility standards be integrated into the prompt generation phase? (Current prompts lack regulatory constraints)

## Limitations
- Workflow success depends on LLM's spatial reasoning within strict JSON constraints, only validated on one case study
- Greedy algorithm may fail in highly constrained spaces requiring global re-layout optimization
- Revit API integration lacks detailed documentation and assumes specific software versions

## Confidence
- **High confidence:** Three-stage workflow architecture is clearly specified and technically feasible
- **Medium confidence:** Claim of generating Revit-native parametric models is plausible but untested across versions
- **Low confidence:** Assertion of superior spatial coherence compared to commercial tools lacks empirical validation

## Next Checks
1. **JSON Schema Stress Test:** Run Figure 3 prompt across 10 diverse residential layouts and measure valid JSON output percentage
2. **Algorithm Failure Analysis:** Systematically test greedy furniture placement on progressively congested layouts to document failure points
3. **API Version Compatibility:** Execute Figure 5 Python script on Revit 2022, 2023, and 2024 to document deprecated API call issues