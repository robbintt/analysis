---
ver: rpa2
title: 'WinkTPG: An Execution Framework for Multi-Agent Path Finding Using Temporal
  Reasoning'
arxiv_id: '2508.01495'
source_url: https://arxiv.org/abs/2508.01495
tags:
- speed
- agents
- time
- mapf
- agent
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: This paper proposes an execution framework for MAPF using temporal
  reasoning. It first converts a MAPF plan into a TPG encoding passing orders, then
  introduces a new kinodynamic planner kTPG that generates speed profiles satisfying
  both precedence constraints and robot kinodynamics.
---

# WinkTPG: An Execution Framework for Multi-Agent Path Finding Using Temporal Reasoning

## Quick Facts
- arXiv ID: 2508.01495
- Source URL: https://arxiv.org/abs/2508.01495
- Reference count: 12
- Primary result: Improves solution quality by up to 51.7% and scales to 1,000 agents in 1 second

## Executive Summary
WinkTPG addresses the challenge of executing collision-free Multi-Agent Path Finding (MAPF) plans under kinodynamic and temporal uncertainty. It introduces a framework that converts MAPF plans into Temporal Plan Graphs (TPG) encoding passing orders, then generates kinodynamically feasible speed profiles using an iterative refinement algorithm (kTPG). The framework adds safety margins for temporal uncertainty and employs windowed replanning to leverage execution feedback. Compared to existing methods, WinkTPG achieves significant improvements in solution quality while maintaining computational efficiency.

## Method Summary
WinkTPG takes a MAPF plan and converts it to a TPG with Type-1 (within-agent) and Type-2 (between-agent passing) edges. The kTPG algorithm iteratively refines reserved time intervals and generates speed profiles for each agent independently using 1-D SIPP-IP. kTPGu adds safety margins based on uncertainty models to ensure passing orders are preserved with user-defined probability. During execution, WinkTPG performs periodic replanning every t_e seconds within a planning window of t_p vertices, using actual reach-time feedback to reduce uncertainty accumulation.

## Key Results
- Improves solution quality by up to 51.7% compared to baseline methods
- Scales to 1,000 agents in 1 second on benchmark maps
- Achieves <5% suboptimality on empty-32×32 map with 50 agents
- Maintains collision-free execution under temporal uncertainty with 99.9% safety probability

## Why This Works (Mechanism)

### Mechanism 1: Reserved Interval Iteration for Kinodynamic Feasibility
Converting passing-order constraints into reserved time intervals enables decoupled kinodynamic planning while preserving collision-freeness. kTPG assigns each TPG vertex a reserved interval `[0, ∞)`, then iteratively selects agents with most satisfiable conflicting Type-2 edges, generates speed profiles visiting unlocked vertices within their intervals, and uses leave times at shared locations as split times to update reserved intervals, ensuring non-overlapping occupancy windows.

### Mechanism 2: Probabilistic Safety Margins for Temporal Uncertainty
Adding safety margins derived from uncertainty models maintains passing-order constraints with user-defined probability under execution delay. kTPGu models move-time uncertainty as `N(0, (ε·d)^2)` and computes reach-time variance propagating along the path. For each Type-2 edge, it enforces a minimum time gap `F⁻¹(Pd)` between expected leave time of one agent and expected reach time of another.

### Mechanism 3: Windowed Replanning Reduces Uncertainty Accumulation
Periodic replanning with actual reach-time updates bounds uncertainty growth and improves solution quality. WinkTPG triggers replanning every `te` seconds, constructs a planning window starting after `NE` enqueued vertices, recalculates reach times using last reported vertex, resets variance from that point, and recursively expands the window to include all dependencies.

## Foundational Learning

- Concept: **Temporal Plan Graph (TPG) and passing orders**
  - Why needed: The entire framework builds on TPG's encoding of precedence constraints (Type-1: within-agent sequence; Type-2: between-agent passing orders at shared locations)
  - Quick check: Given two agents sharing a location, can you sketch the Type-2 edge and explain how it enforces "one leaves before the other enters"?

- Concept: **Kinodynamic constraints (speed, acceleration, orientation)**
  - Why needed: kTPG's core contribution is generating profiles that respect real robot limits (e.g., max speed 2 m/s, acceleration ±1 m/s², differential-drive turn times)
  - Quick check: For a differential-drive robot at rest, what is the minimum time to move 2 edges forward if max speed is 2 m/s and max acceleration is 1 m/s²?

- Concept: **Uncertainty propagation (variance accumulation)**
  - Why needed: The safety margin mechanism relies on computing cumulative variance along a path
  - Quick check: If each edge move has variance σ² and an agent traverses 5 edges, what is the variance of its reach time at the 5th vertex (assuming independence)?

## Architecture Onboarding

- Component map: MAPF plan -> TPG Encoder -> kTPG/kTPGu -> Speed profiles -> Agents -> Execution feedback -> WinkTPG -> Updated profiles
- Critical path: Generate MAPF plan (e.g., PBS) -> Convert to TPG (ensure DAG) -> Run kTPG/kTPGu to get initial speed profiles -> During execution: agents report reach times -> WinkTPG constructs window -> kTPGu replans within window -> Updated profiles sent -> Repeat until all goals reached
- Design tradeoffs: Smaller execution windows (`te`) improve responsiveness but increase replanning frequency; smaller planning windows (`tp`) limit lookahead and may miss global optimizations; higher `Pd` increases margins, reducing throughput; agent selection order affects iteration count
- Failure signatures: Infeasible profiles (agent cannot meet reserved interval within kinodynamic limits); window overrun (replanning takes longer than `te`); stale feedback (agents don't report in time); cycles in TPG (DAG assumption violated)
- First 3 experiments:
  1. Baseline comparison on empty-32×32 map with 50 agents: Run kTPG vs. ADG vs. KDN to verify <5% suboptimality with <1s runtime
  2. Uncertainty sweep on warehouse-large with ε ∈ {0.01, 0.03, 0.05}: Run WinkTPG with `tp=20`, `te=10s`, `Pd=0.99` to confirm graceful degradation
  3. Window size ablation with 500 agents on den520d: Vary `te` ∈ {5, 10, 20}s and `tp` ∈ {10, 20, 40} to identify Pareto front

## Open Questions the Paper Calls Out

### Open Question 1
Can WinkTPG be effectively integrated with rolling-horizon conflict resolution or switchable TPG techniques? The conclusion states future work includes exploring integration with rolling-horizon conflict resolution (Li et al. 2021) or switchable TPG (Feng et al. 2024).

### Open Question 2
How does the assumption of Gaussian noise in the uncertainty model impact safety and performance in real-world, non-Gaussian environments? Equation 1 models temporal uncertainty strictly as a normal distribution to derive safety margins, but real-world delays often exhibit heavy-tailed distributions.

### Open Question 3
Can the kTPG algorithm be modified to provide bounded-suboptimality guarantees? Theorem 1 proves kTPG is complete but explicitly states the returned solution "may be suboptimal" due to the heuristic agent selection strategy.

## Limitations
- Convergence properties of the kTPG iterative algorithm are not formally proven
- Safety margin calculations assume Gaussian, independent temporal uncertainty that may not hold in real-world environments
- Windowed replanning depends on timely agent state reporting with no performance degradation analysis for communication failures

## Confidence
- **High Confidence**: TPG encoding mechanism and use in passing-order constraint conversion; problem formulation and overall framework architecture
- **Medium Confidence**: kTPG iterative algorithm's practical effectiveness based on experimental results; 51.7% improvement claim over ADG
- **Low Confidence**: Formal guarantees of convergence for kTPG; collision-free execution under non-Gaussian uncertainty

## Next Checks
1. **Convergence Verification**: Create systematic test suite of TPG structures (including pathological cases) to verify kTPG always converges within bounded iterations; measure iteration counts across diverse MAPF plans
2. **Uncertainty Robustness**: Replace Gaussian uncertainty model with empirical delay distributions from real robot experiments; compare predicted vs. actual collision rates across different Pd thresholds
3. **Communication Latency Impact**: Introduce artificial communication delays and packet loss in execution loop; measure solution quality degradation and replanning overhead to identify practical limits of windowed approach