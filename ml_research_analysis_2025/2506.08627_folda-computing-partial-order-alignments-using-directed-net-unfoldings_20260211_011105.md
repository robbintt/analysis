---
ver: rpa2
title: 'FoldA: Computing Partial-Order Alignments Using Directed Net Unfoldings'
arxiv_id: '2506.08627'
source_url: https://arxiv.org/abs/2506.08627
tags:
- unfolding
- process
- alignment
- partial-order
- alignments
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: This paper introduces FoldA, a novel method for computing partial-order
  alignments using directed Petri net unfoldings. The key problem addressed is the
  state space explosion and loss of concurrency information in traditional alignment-based
  conformance checking, particularly for models with high degrees of choice and concurrency.
---

# FoldA: Computing Partial-Order Alignments Using Directed Net Unfoldings

## Quick Facts
- **arXiv ID:** 2506.08627
- **Source URL:** https://arxiv.org/abs/2506.08627
- **Reference count:** 23
- **Primary result:** FoldA computes partial-order alignments using directed Petri net unfoldings, reducing queued states and better capturing concurrency compared to Dijkstra/A*, though with higher computation time.

## Executive Summary
This paper introduces FoldA, a novel method for computing partial-order alignments using directed Petri net unfoldings. The key problem addressed is the state space explosion and loss of concurrency information in traditional alignment-based conformance checking, particularly for models with high degrees of choice and concurrency. FoldA constructs a synchronous product of the process model and trace, then unfolds it in a directed, cost-based manner to compute an optimal partial-order alignment that better captures concurrent behavior. Experiments on 485 synthetic model-log pairs and 13 real-life benchmark pairs show that while FoldA requires more computation time than Dijkstra- and A* alignments, it generally reduces the number of queued states and provides a more accurate representation of concurrency.

## Method Summary
FoldA computes optimal partial-order alignments by constructing a synchronous product of the process model and trace, then performing a directed unfolding of this product net. The method uses two variants: FoldA_n (naive) and FoldA_h (heuristic-guided), with the latter employing a marking equation heuristic to guide the search. The cost function assigns zero cost to synchronous moves and silent transitions, and unit cost to log and model moves. The algorithm stops when the final marking is reached in a local configuration. This approach aims to better preserve concurrency information and reduce the state space explosion typically seen in traditional alignment methods.

## Key Results
- FoldA generally reduces the number of queued states compared to Dijkstra and A* alignments
- FoldA shows higher computation time (mean ET ~0.29s) than A* (mean ET ~0.01s) but comparable to Dijkstra (mean ET ~0.28s)
- On synthetic models, FoldA outperformed Dijkstra in state reduction for all model types
- On real-life logs, FoldA's performance was comparable to baselines, with some cases showing significant timeout issues

## Why This Works (Mechanism)
FoldA works by leveraging directed net unfoldings to preserve concurrency information that is typically lost in traditional alignment approaches. By unfolding the synchronous product in a directed manner based on cost, the method creates a branching process that captures alternative execution paths without explicit state repetition. The heuristic-guided variant (FoldA_h) uses marking equations to prioritize promising paths, reducing unnecessary exploration. This approach effectively trades computation time for better state space management and more accurate concurrency representation.

## Foundational Learning
- **Petri Net Unfoldings**: Transformation of a Petri net into a branching process structure that preserves causal relationships. Needed to understand how FoldA represents concurrent behavior without state explosion. Quick check: Verify that the unfolding correctly captures all possible execution sequences.
- **Synchronous Product Construction**: Combining the process model and trace into a single net where transitions represent alignment possibilities. Needed to understand the input to the unfolding algorithm. Quick check: Confirm that all valid alignments correspond to paths in the synchronous product.
- **Marking Equation Heuristics**: Linear programming approach to guide search based on state invariants. Needed to understand how FoldA_h reduces search space. Quick check: Validate that the heuristic correctly identifies high-potential paths.
- **Partial-Order Alignments**: Alignments that preserve the partial order of events rather than imposing a total order. Needed to understand the advantage over traditional alignments. Quick check: Compare the concurrency representation between FoldA and Dijkstra alignments.

## Architecture Onboarding

**Component Map:** Process Model -> Synchronous Product -> Directed Unfolding -> Branching Process -> Optimal Alignment

**Critical Path:** Model+Trace Input → Synchronous Product Construction → Directed Unfolding (Algorithm 1) → Heuristic Guidance (FoldA_h) → Final Configuration Check → Output Alignment

**Design Tradeoffs:** FoldA trades increased computation time for reduced queued states and better concurrency preservation. The directed unfolding creates a more compact representation of the search space but requires more complex bookkeeping and heuristic guidance.

**Failure Signatures:** Timeouts on complex traces indicate excessive backtracking in the unfolding. Memory overflow suggests the branching process structure is too large. Poor performance on nested choice models indicates the heuristic is not well-suited to choice-heavy structures.

**First Experiments:**
1. Verify FoldA correctly computes alignments on a simple sequential model with known optimal alignment
2. Compare state space size (visited states) between FoldA and Dijkstra on a moderately complex parallel model
3. Test FoldA_h performance with different LP solver backends to quantify heuristic impact

## Open Questions the Paper Calls Out
- **Can heuristics specifically tailored to the structure of branching processes significantly reduce the computation time of FoldA to compete with A*-based alignment methods?** The paper suggests future work on designing heuristics tailored towards branching processes to improve performance.
- **To what extent does a parallel or incremental implementation of the FoldA algorithm improve performance on large-scale or streaming event data?** The paper notes that the approach can be adapted to incremental and parallel alignment computing, but this remains untested.
- **Can the computational overhead of checking condition sets be optimized to prevent the exponential growth of elapsed time in models with deeply nested choice constructs?** The paper identifies that nested choice models exhibit the fastest increase in elapsed time due to checking multiple condition sets.

## Limitations
- FoldA shows significantly higher computation time than A* alignments, with median ET around 0.29s vs 0.01s for A*
- The method experiences timeouts on complex traces, with maximum ET reaching 2702s on some real-life logs
- The heuristic guidance (FoldA_h) does not fully optimize the directed unfolding process, leaving room for improvement
- Implementation details for the marking equation heuristic and data preprocessing are underspecified, affecting reproducibility

## Confidence
- **High confidence** in the core FoldA methodology and its correctness for computing partial-order alignments via directed unfoldings
- **Medium confidence** in the reported computational performance metrics (ET, #QS, #VS), as these are sensitive to implementation details and heuristic solver choice
- **Medium confidence** in the qualitative claim that FoldA better captures concurrency and reduces queued states compared to Dijkstra/A*, supported by the structural differences in the unfolding approach

## Next Checks
1. Implement and test FoldA using multiple LP solver backends (e.g., Gurobi, PuLP, OR-Tools) on a simple synthetic model to quantify the impact of the marking equation heuristic on performance
2. Re-run the ITL prDm6 benchmark to verify whether FoldA can complete within reasonable memory constraints and compare its state space growth to Dijkstra's reported failure
3. Conduct a sensitivity analysis by varying the synthetic model parameters (degree of parallelism, choice density) to determine the conditions under which FoldA's state reduction advantage is most pronounced