---
ver: rpa2
title: 'TITAN: Graph-Executable Reasoning for Cyber Threat Intelligence'
arxiv_id: '2510.14670'
source_url: https://arxiv.org/abs/2510.14670
tags:
- titan
- reasoning
- path
- malware
- paths
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: TITAN introduces a graph-executable reasoning framework for Cyber
  Threat Intelligence (CTI) queries, integrating a path planner model that predicts
  logical relation chains from natural language and a graph executor that traverses
  the TITAN Ontology (a modified MITRE ATT&CK knowledge graph) to retrieve factual
  answers. The framework enables interpretable, multi-hop reasoning over a structured,
  typed, and bidirectional CTI knowledge graph, moving beyond retrieval-based systems
  to support executable reasoning paths.
---

# TITAN: Graph-Executable Reasoning for Cyber Threat Intelligence

## Quick Facts
- arXiv ID: 2510.14670
- Source URL: https://arxiv.org/abs/2510.14670
- Reference count: 24
- Primary result: Graph-executable reasoning framework for CTI queries with 0.67 path accuracy on L4+ queries using Chain-of-Thought reasoning

## Executive Summary
TITAN introduces a graph-executable reasoning framework for Cyber Threat Intelligence (CTI) queries, integrating a path planner model that predicts logical relation chains from natural language and a graph executor that traverses the TITAN Ontology (a modified MITRE ATT&CK knowledge graph) to retrieve factual answers. The framework enables interpretable, multi-hop reasoning over a structured, typed, and bidirectional CTI knowledge graph, moving beyond retrieval-based systems to support executable reasoning paths. To train and evaluate the system, TITAN Dataset was constructed with 88,209 examples pairing questions with reasoning paths and Chain-of-Thought explanations. Empirical results show that models with explicit Chain-of-Thought reasoning outperform non-reasoning baselines, especially on long and multi-hop paths, with path accuracy improving from 0.57 to 0.67 on L4+ queries.

## Method Summary
TITAN combines a path planner (Phi-3.5 LLM) that generates reasoning paths from natural language queries with a deterministic graph executor that traverses the TITAN Ontology. The framework uses typed, bidirectional relations to eliminate traversal ambiguity and supports set-based operators (select, exec_common, exec_difference) for comparative queries. The TITAN Dataset contains 88,209 examples with Chain-of-Thought explanations and was generated from 700+ manually-built templates. Two variants are evaluated: CoT (generates step-by-step reasoning then path) and NoCoT (direct path prediction). The knowledge graph contains 2,350 nodes and 48,795 edges derived from MITRE ATT&CK.

## Key Results
- Path accuracy improves from 0.57 to 0.67 on L4+ queries using Chain-of-Thought reasoning
- Typed relations enable deterministic traversal without probabilistic disambiguation
- Decoupled planner-executor architecture provides interpretable, verifiable reasoning paths
- Filter operators achieve highest accuracy while select/exec_common/exec_difference show larger performance gaps

## Why This Works (Mechanism)

### Mechanism 1: Chain-of-Thought Decomposition Improves Multi-Hop Path Accuracy
Explicit CoT reasoning before path prediction improves accuracy on long, multi-hop queries compared to direct path prediction. The model first generates intermediate reasoning steps ("Step 1: Follow the uses_attack_pattern relation..."), which scaffolds the final path prediction. This decomposition reduces the cognitive load of predicting a 4+ hop path in a single forward pass.

### Mechanism 2: Typed Relations Enable Deterministic Traversal Ambiguity Resolution
Encoding target node types directly into relation labels (e.g., `uses_attack_pattern` vs `uses_malware`) allows the executor to traverse unambiguously without probabilistic disambiguation. At each node, the executor matches predicted relations against outgoing edges. Typed relations ensure only one candidate edge type exists per predicted relation, eliminating branching decisions during traversal.

### Mechanism 3: Decoupled Planner-Executor Architecture Enables Verifiable Reasoning
Separating probabilistic path planning from deterministic graph execution provides interpretability and error traceability unavailable in end-to-end neural retrieval. The LLM planner outputs an explicit, human-readable path (e.g., `<PATH>uses_malware<SEP>uses_attack_pattern<SEP>mitigated_by</PATH>`). The executor deterministically traverses this path on the KG. Failures can be attributed to either planning errors or graph coverage gaps.

## Foundational Learning

- **Concept: Typed Knowledge Graph Traversal**
  - Why needed here: The executor relies on relation types to resolve traversal decisions; understanding this is essential for debugging failed paths and extending the ontology.
  - Quick check question: Given a `malware` node, what typed relation would you follow to reach `attack_pattern` nodes? (Answer: `uses_attack_pattern`)

- **Concept: Multi-Hop Reasoning Complexity**
  - Why needed here: Path accuracy degrades with length (L1: 0.77 → L4+: 0.57 without CoT); understanding hop depth helps prioritize where CoT provides most value.
  - Quick check question: Classify this query by hop depth: "What mitigations apply to techniques used by malware employed by APT29?" (Answer: L4+: intrusion_set → uses_malware → uses_attack_pattern → mitigated_by_course_of_action)

- **Concept: Set-Based Operators for Comparative Queries**
  - Why needed here: `exec_common` and `exec_difference` operators enable comparative reasoning (e.g., shared vs. unique techniques), but show lowest accuracy in experiments.
  - Quick check question: Which operator would find techniques shared by both Cannon and LitePower malware? (Answer: `exec_common` after `select` creates parallel branches)

## Architecture Onboarding

- **Component map:**
  User Query (natural language) → Path Planner (Phi-3.5 LLM) → Graph Executor (deterministic) → Factual Answer + Executable Path Trace

- **Critical path:** Query → entity extraction (planner) → path prediction (planner) → node resolution (executor) → traversal (executor) → result. The planner is probabilistic; the executor is deterministic post-prediction.

- **Design tradeoffs:**
  - Typed relations increase schema verbosity but eliminate traversal ambiguity
  - CoT improves accuracy on long paths at the cost of inference latency and token usage
  - Template-based dataset generation enables scale but may underrepresent edge-case phrasing

- **Failure signatures:**
  - Empty result set: Either path is invalid (planner error) or KG lacks required entities (coverage gap)
  - Wrong entity type returned: Planner confused semantically similar typed relations (e.g., `uses_malware` vs `uses_tool`)
  - Operator returns unexpected results: `select` may not have correctly instantiated parallel branches before `exec_common`/`exec_difference`

- **First 3 experiments:**
  1. Reproduce reported accuracy gap: Run CoT vs NoCoT on test split; confirm L4+ improvement (0.57 → 0.67)
  2. Error attribution analysis: For failing queries, manually classify whether errors stem from path prediction, entity extraction, or KG coverage
  3. Operator isolation test: Evaluate `filter`, `select`, `exec_common`, `exec_difference` separately to identify which compositional operations are most fragile

## Open Questions the Paper Calls Out

### Open Question 1
Can Reinforcement Learning (RL) alignment significantly improve the path planner's ability to generate valid reasoning paths compared to the current supervised fine-tuning approach?
- Basis in paper: The authors explicitly state in the Future Work section that they plan to "refine the planner's reasoning through Reinforcement Learning–based alignment."
- Why unresolved: The current study relies on supervised learning using the TITAN Dataset (Chain-of-Thought vs. NoCoT); the potential gains from RL-based optimization for graph traversal remain untested.
- What evidence would resolve it: A comparative evaluation showing Path Accuracy and BERTScore improvements for an RL-aligned model against the current Phi-3.5 baselines on the TITAN test set.

### Open Question 2
Does incorporating unstructured, real-world malware reports into the TITAN Knowledge Graph degrade or enhance the reliability of the graph executor?
- Basis in paper: The authors identify the need to enrich the "TITAN KG with real malware reports" as a primary direction for future work.
- Why unresolved: The current framework operates on a clean, structured, and typed ontology derived from MITRE ATT&CK; it is unclear if the system can maintain semantic coherence and path accuracy when processing noisy, real-world data.
- What evidence would resolve it: Performance metrics (Path Accuracy) on a modified KG that includes entity extraction from real reports, compared to the current baseline.

### Open Question 3
How does TITAN's performance compare to established CTI retrieval baselines when evaluated on external, non-synthetic benchmarks?
- Basis in paper: The paper notes the intent to "evaluate TITAN against existing CTI benchmarks," implying current results are isolated to the internal TITAN Dataset.
- Why unresolved: The current evaluation is self-contained (trained and tested on splits of the TITAN Dataset), leaving the framework's generalizability to other standard CTI tasks or datasets unproven.
- What evidence would resolve it: Benchmarking results on standard external CTI datasets (e.g., HackMent or CTI-v1) comparing TITAN against standard RAG or retrieval baselines.

## Limitations
- Synthetic template-based data generation may not capture real-world linguistic diversity
- Typed relation schema increases maintenance overhead and could become brittle as ontology evolves
- Performance gaps on complex comparative queries using select/exec_common/exec_difference operators

## Confidence
- **High confidence**: The architectural separation of planner and executor is sound and provides verifiable reasoning paths. The path accuracy improvements on long queries are well-documented.
- **Medium confidence**: The CoT mechanism's benefits are demonstrated but may be overstated for real-world variability. The typed relations eliminate traversal ambiguity but introduce schema rigidity.
- **Low confidence**: The dataset's coverage of rare CTI entities and edge cases is unknown. Operator accuracy (especially `exec_common`/`exec_difference`) shows the largest gaps and may break on complex comparative queries.

## Next Checks
1. Test CoT vs NoCoT performance on a manually-curated set of real-world CTI questions (not from TITAN Dataset) to assess generalization
2. Introduce a small set of untyped relations into the KG and measure executor failure rate to quantify the typed schema's necessity
3. Conduct ablation study: Remove `select` operator from all queries and measure accuracy drop to isolate the impact of compositional operators