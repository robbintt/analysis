---
ver: rpa2
title: 'Co-Layout: LLM-driven Co-optimization for Interior Layout'
arxiv_id: '2511.12474'
source_url: https://arxiv.org/abs/2511.12474
tags:
- room
- furniture
- design
- constraints
- layout
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: This paper introduces Co-Layout, a framework that jointly optimizes
  room layout and furniture placement for interior design. It uses a large language
  model (LLM) to extract design constraints from textual prompts, which are encoded
  into a grid-based integer programming model inspired by Modulor.
---

# Co-Layout: LLM-driven Co-optimization for Interior Layout

## Quick Facts
- arXiv ID: 2511.12474
- Source URL: https://arxiv.org/abs/2511.12474
- Reference count: 15
- Primary result: CLIP similarity score of 26.50, outperforming baselines like Holodeck (25.15) and AnyHome (25.75)

## Executive Summary
This paper introduces Co-Layout, a framework that jointly optimizes room layout and furniture placement for interior design. It uses a large language model (LLM) to extract design constraints from textual prompts, which are encoded into a grid-based integer programming model inspired by Modulor. Key constraints include corridor connectivity, room accessibility, and spatial exclusivity. To improve efficiency, the authors employ a coarse-to-fine optimization strategy that begins with a low-resolution grid and refines the solution. Experiments demonstrate that Co-Layout outperforms existing two-stage pipelines in solution quality, producing layouts with no object overlaps or boundary violations.

## Method Summary
The framework extracts structured constraints from natural language prompts using a multi-agent LLM workflow, then encodes these into a grid-based integer programming model. The solver jointly optimizes room layout and furniture placement, enforcing hard constraints like corridor connectivity and non-overlapping. A coarse-to-fine strategy accelerates the optimization by first solving a simplified low-resolution problem and using it as a warm start for the fine-resolution solution. The method outputs a 3D layout rendered in Blender.

## Key Results
- CLIP similarity score of 26.50, outperforming baselines Holodeck (25.15) and AnyHome (25.75)
- Zero object overlaps and boundary violations in optimized layouts
- Superior performance in user studies for semantic alignment, layout rationality, and path clearance

## Why This Works (Mechanism)

### Mechanism 1
- **Claim:** Joint optimization of room layout and furniture placement produces more functionally consistent designs than sequential pipelines.
- **Mechanism:** By simultaneously solving for room boundaries and furniture placement within a single integer programming model, the system avoids local optima where a room is shaped correctly but furniture blocks access or circulation.
- **Core assumption:** Room function and furniture arrangement are interdependent variables rather than independent sequential steps.
- **Evidence anchors:**
  - [abstract] "joint optimization approach significantly outperforms existing two-stage design pipelines in solution quality."
  - [section] Section 5.3 "Comparative Analysis" notes baselines suffer from "randomness, indicating a lack of robust understanding of room function... connectivity."
  - [corpus] Corpus signals (e.g., *RoomCraft*, *FlairGPT*) focus on generation or sequential steps; Co-Layout explicitly targets the "joint" aspect to solve disconnection issues.
- **Break condition:** If the integer solver times out or constraints are contradictory, the joint model may fail to produce any feasible layout, whereas a sequential model might still produce a (flawed) partial result.

### Mechanism 2
- **Claim:** A grid-based representation with flow variables effectively enforces hard spatial constraints like connectivity and accessibility.
- **Mechanism:** The "Modulor"-inspired grid discretizes continuous space into cells. "Flow" variables are introduced from the entrance to every corridor/open room cell, mathematically guaranteeing a path exists (single connected component) via flow conservation constraints.
- **Core assumption:** The grid resolution is sufficiently fine to approximate the required furniture dimensions and circulation paths.
- **Evidence anchors:**
  - [abstract] "encoded into a grid-based integer programming model... accounts for key design requirements, including corridor connectivity, room accessibility."
  - [section] Section 4.1 "Corridor Connectivity Constraint" details the flow-based formulation: "outflow... inflow... ensures that the entrance cell... supplying flow."
  - [corpus] *OID-PPO* uses RL for guidelines; Co-Layout uses hard IP constraints, differing from soft reward-based approaches.
- **Break condition:** If the "Modulor" grid unit is too large relative to the furniture, valid configurations may be pruned, rendering the problem infeasible.

### Mechanism 3
- **Claim:** A coarse-to-fine strategy accelerates the solver by providing a high-quality warm start for the high-resolution grid.
- **Mechanism:** The solver first optimizes room layout on a down-sampled grid (e.g., 6x5 instead of 12x10). This coarse assignment maps to the fine grid, initializing variables and adding penalty terms to keep the fine solution close to the coarse structure, significantly reducing the search space.
- **Core assumption:** A solution exists on the coarse grid that roughly corresponds to a feasible solution on the fine grid.
- **Evidence anchors:**
  - [abstract] "coarse-to-fine optimization strategy... begins with a low-resolution grid to solve a simplified problem and guides the solution."
  - [section] Section 5.5 "Ablation of Coarse-to-fine Strategy" shows "strategy significantly reduces computation time as the grid resolution increases."
  - [corpus] Weak external corpus evidence for this specific acceleration technique in interior layout; this appears to be a specific efficiency contribution of this paper.
- **Break condition:** If the coarse solution over-constrains the fine grid (e.g., making rooms too small for fine-grained furniture), the solver may struggle to reconcile the penalties with hard constraints.

## Foundational Learning

- **Concept:** **Integer Programming (IP) & Mixed-Integer Linear Programming (MILP)**
  - **Why needed here:** The entire layout generation is framed as an IP problem. Understanding binary variables (e.g., $x_{i,j}=1$ if room $k$ occupies cell), objective functions (weighted penalties), and "Big-M" formulations is required to read the math in Section 4.
  - **Quick check question:** Can you explain why a "flow conservation" constraint is linear and how it guarantees connectivity?

- **Concept:** **LLM Agent Workflows (Chain of Thought)**
  - **Why needed here:** The system does not just prompt an LLM; it uses a "multi-agent" workflow (Information Analysis, Environment Analysis, etc.) to convert unstructured text into structured JSON constraints.
  - **Quick check question:** How would you prompt an LLM to output a strict JSON schema containing room adjacency lists rather than a descriptive paragraph?

- **Concept:** **Modulor & Grid Discretization**
  - **Why needed here:** The paper bases its spatial unit on Le Corbusier's "Modulor." You must understand how continuous real-world coordinates (meters) map to discrete grid cells to interpret the scale and resolution tradeoffs.
  - **Quick check question:** If a room is 15.5 sqm and a grid cell is 1 sqm, how does the optimization handle the 0.5 sqm discrepancy in the "Area Target" objective?

## Architecture Onboarding

- **Component map:**
  1. **Input:** Natural Language Prompt.
  2. **LLM Preprocessor:** Multi-agent system outputs `Constraints.json` (Room list, Furniture list, Adjacency rules).
  3. **Optimizer (Core):** Python script wrapping **GUROBI**. encodes constraints into a Grid-based IP model.
  4. **Strategy:** Coarse-to-fine heuristic loop.
  5. **Post-processing:** Heuristic wall/door/window placement.
  6. **Visualization:** Blender rendering script.

- **Critical path:** The constraint encoding in the **Optimizer**. If the LLM outputs a constraint that cannot be mathematically encoded (e.g., "the room should feel cozy"), the pipeline breaks. The mapping from LLM JSON to GUROBI constraints is the brittle link.

- **Design tradeoffs:**
  - **Grid Resolution:** High resolution = better furniture fit but exponential compute time.
  - **Hard vs. Soft Constraints:** Area targets are soft (objectives), but non-overlapping is hard. Tuning the weights ($\omega_s$) in the objective function $E$ is critical for convergence.

- **Failure signatures:**
  - **Infeasibility:** GUROBI returns "infeasible." Usually caused by conflicting LLM constraints (e.g., "Bathroom adjacent to Kitchen" + "Kitchen far from wet zones") or furniture too large for allocated grid area.
  - **Slow Convergence:** Solver runs > 10 mins. Likely stuck in the fine-optimization phase; implies coarse-to-fine mapping was ineffective or weights are unbalanced.

- **First 3 experiments:**
  1. **Constraint Sanity Check:** Run the optimizer with a single room and one furniture item. Verify the IP converges and the visualization renders correctly.
  2. **Ablation on Connectivity:** Disable the "Corridor Connectivity" flow constraints. Verify that the output contains isolated rooms (as shown in Fig. 7 of the paper).
  3. **LLM Robustness:** Prompt the LLM with contradictory requirements (e.g., "Place a 4m bed in a 3m room"). Check if the system detects the infeasibility or if the solver hangs.

## Open Questions the Paper Calls Out

- **Open Question 1:** Can the framework be extended to support non-floor objects, such as wall-mounted fixtures and tabletop items?
  - **Basis in paper:** [explicit] The authors state the scope of furniture is currently limited to floor-based objects and suggest extending it to wall-mounted and tabletop items.
  - **Why unresolved:** The current integer programming formulation relies on a 2D grid representation where each cell is uniquely assigned to a room or floor object; adding vertical stacking or wall-attachment logic requires significant structural changes to the spatial exclusivity constraints.
  - **What evidence would resolve it:** A modified optimization model that successfully generates layouts containing shelves or wall-units without violating furniture non-overlap constraints.

- **Open Question 2:** How can the system effectively resolve conflicting design constraints generated by the LLM preprocessor?
  - **Basis in paper:** [explicit] The paper notes that LLMs may occasionally produce conflicting constraints, which degrades solution quality, and suggests iterative refinement or human-in-the-loop feedback as solutions.
  - **Why unresolved:** The current pipeline treats the LLM-extracted scene graph as a static input for the solver; it lacks a feedback mechanism to detect and repair semantic contradictions (e.g., mutually exclusive adjacency requirements) before optimization begins.
  - **What evidence would resolve it:** Demonstrating an automated validation loop that re-prompts the LLM or relaxes constraints upon detecting infeasibility, resulting in higher success rates for complex prompts.

- **Open Question 3:** Can this co-optimization approach be adapted for multi-story buildings while maintaining connectivity across floors?
  - **Basis in paper:** [explicit] The authors propose extending the framework to design multi-story buildings by incorporating inter-floor constraints.
  - **Why unresolved:** The existing connectivity formulation uses a single-source flow model on a 2D grid; extending this to 3D requires defining vertical circulation elements (stairs/elevators) and ensuring they align structurally and spatially across different floor plans.
  - **What evidence would resolve it:** A 3D extension of the grid formulation that successfully generates a multi-story layout with aligned stairwells and consistent vertical load-bearing structures.

## Limitations

- The exact LLM prompt templates for constraint extraction are not provided, making replication of the multi-agent preprocessing challenging.
- Weight values for the objective function (Ï‰_s) are referenced but not specified, requiring manual tuning for different use cases.
- The system's scalability to larger spaces (beyond 100 sqm) is untested, as is its performance with irregular room shapes.

## Confidence

- **High confidence** in the core integer programming formulation and constraint encoding mechanisms, as these are mathematically rigorous and well-explained.
- **Medium confidence** in the coarse-to-fine acceleration strategy, as the ablation study shows benefit but the specific parameters are underspecified.
- **Medium confidence** in the overall system performance, as the CLIP score improvement (26.50 vs 25.15-25.75) is modest and user study sample sizes are not reported.

## Next Checks

1. **Constraint Robustness Test:** Systematically generate contradictory constraints (e.g., "4m bed in 3m room") to verify if the system gracefully handles infeasibility versus hanging or producing invalid layouts.
2. **Grid Resolution Sensitivity:** Vary grid resolution parameters systematically and measure the trade-off between solution quality (OOR/OOB metrics) and solve time to establish practical resolution limits.
3. **Multi-room Scaling:** Test the system with apartment layouts containing 4+ rooms to evaluate whether corridor connectivity and accessibility constraints remain effective as layout complexity increases.