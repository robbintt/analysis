---
ver: rpa2
title: On the Effectiveness of Graph Reordering for Accelerating Approximate Nearest
  Neighbor Search on GPU
arxiv_id: '2508.15436'
source_url: https://arxiv.org/abs/2508.15436
tags:
- graph
- reordering
- search
- memory
- anns
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: This paper investigates the effectiveness of graph reordering for
  accelerating approximate nearest neighbor search (ANNS) on GPUs. While graph-based
  ANNS dominates modern AI applications, existing approaches focus on algorithmic
  innovations while neglecting memory layout considerations that significantly impact
  execution time.
---

# On the Effectiveness of Graph Reordering for Accelerating Approximate Nearest Neighbor Search on GPU

## Quick Facts
- arXiv ID: 2508.15436
- Source URL: https://arxiv.org/abs/2508.15436
- Reference count: 40
- Primary result: GPU-targeted graph reordering achieves up to 15% QPS improvements while preserving search accuracy

## Executive Summary
This paper investigates the effectiveness of graph reordering for accelerating approximate nearest neighbor search (ANNS) on GPUs. While graph-based ANNS dominates modern AI applications, existing approaches focus on algorithmic innovations while neglecting memory layout considerations that significantly impact execution time. The authors develop a unified evaluation framework that enables comprehensive evaluation of diverse reordering strategies across different graph indices through a graph adapter and GPU-optimized traversal engine. Their GPU-targeted reordering achieves up to 15% QPS improvements while preserving search accuracy, demonstrating that memory layout optimization operates orthogonally to existing algorithmic innovations.

## Method Summary
The paper develops a unified evaluation framework that enables comprehensive evaluation of diverse reordering strategies across different graph indices. The framework uses a graph adapter to convert arbitrary indices (NSG, Vamana, NN-Descent) into Faiss's GPU-compatible format, then runs them through the same cuVS traversal kernel. This eliminates implementation-specific optimizations as confounding variables. The method applies permutation π to reassign vertex IDs so that vertices accessed together during beam search traversal occupy adjacent memory addresses, improving GPU memory bandwidth utilization through memory coalescing. The approach operates purely on the mapping between vertex IDs and physical memory positions without changing graph structure or traversal algorithm.

## Key Results
- GPU-targeted reordering achieves up to 15% QPS improvements while preserving search accuracy
- Reordering effectiveness varies significantly by dataset and dimensionality
- Memory layout optimization operates orthogonally to existing algorithmic innovations
- Effectiveness shows negative correlation with dimensionality for CPU-oriented indices

## Why This Works (Mechanism)

### Mechanism 1: Memory Coalescing via Vertex Collocation
Reordering vertices to place frequently co-accessed nodes in consecutive memory regions improves GPU memory bandwidth utilization. Graph reordering applies a permutation π that reassigns vertex IDs so that vertices accessed together during beam search traversal occupy adjacent memory addresses. When GPU warps (32 threads) access consecutive addresses, individual memory requests coalesce into fewer transactions, maximizing bandwidth. The transition from scattered access patterns to collocated vertices demonstrates how reordering improves hardware utilization.

### Mechanism 2: Orthogonal Optimization to Algorithmic Design
Memory layout optimization provides performance gains without altering graph topology or search accuracy. Reordering operates purely on the mapping between vertex IDs and physical memory positions. The graph structure (edges, connectivity) and traversal algorithm remain unchanged, so recall is preserved while QPS improves through better hardware utilization. This demonstrates that reordering is a non-intrusive optimization technique that can complement existing algorithmic innovations.

### Mechanism 3: Unified Traversal Engine Isolates Layout Effects
Using CAGRA's GPU-optimized search implementation across all graph indices enables fair comparison of pure topological and layout effects. The framework's graph adapter converts arbitrary indices into Faiss's GPU-compatible format, then runs them through the same cuVS traversal kernel. This eliminates implementation-specific optimizations as confounding variables, allowing researchers to isolate the impact of memory layout changes from other performance factors.

## Foundational Learning

- **GPU Memory Coalescing**: Understanding why reordering improves performance requires knowing how GPU warps combine memory requests. Scattered access patterns (32 threads hitting random addresses) cannot coalesce, wasting bandwidth. Quick check: If 32 threads in a warp access addresses [0, 128, 256, 384, ...] versus [0, 4, 8, 12, ...], which pattern yields fewer memory transactions?

- **Beam Search in Graph-based ANNS**: Reordering effectiveness depends on understanding traversal patterns. Beam search maintains a candidate list and iteratively explores neighbors—co-accessed vertices are typically at similar hop distances. Quick check: During beam search iteration, which vertices are most likely to be accessed together: (a) vertices at different hop distances from entry point, or (b) neighbors of the same candidate vertex?

- **Local Clustering Coefficient (LCC)**: Paper investigates whether community structure predicts reordering effectiveness. LCC quantifies how densely a vertex's neighbors are interconnected. Quick check: A vertex has 4 neighbors with 6 edges among them. What is its LCC? (Formula: C_v = 2T_v / k_v(k_v-1), where T_v = triangles)

## Architecture Onboarding

- **Component map**: Input Graph Index (NSG/Vamana/CAGRA/NN-Descent) → Graph Adapter → Index Analyzer → Graph Reordering → cuVS Traversal Engine → QPS/Recall Metrics

- **Critical path**: 1. Build or load a pre-constructed graph index (use K=32 max degree) 2. Convert via graph adapter (adjacency list or CSR format → Faiss GpuIndex) 3. Apply reordering algorithm to generate vertex permutation 4. Run search with runtime parameter L (priority queue size, controls recall-speed tradeoff) 5. Measure Recall@k and QPS

- **Design tradeoffs**: Reordering algorithm choice (GOrder maximizes locality but degrades in high-recall regions; Degree/Hub Sort are stable but lower ceiling; RCM balances both); Runtime parameter L (larger L increases recall but reduces QPS; reordering impact varies with L); Dimensionality (higher dimensions reduce reordering effectiveness for CPU-oriented indices; CAGRA is dimension-agnostic)

- **Failure signatures**: QPS degradation (up to -10%) in high-recall regions, especially with GOrder on certain datasets; No improvement on datasets with high LCC but high dimensionality; Reordering benefits inconsistent across indices on the same dataset

- **First 3 experiments**: 1. Baseline comparison: Run all four indices on SIFT1M without reordering across L ∈ {20, 100, 180} to establish Recall-QPS curves 2. Reordering ablation: Apply all reordering algorithms to a single index-dataset pair and measure QPS improvement 3. Dimensionality sensitivity: Generate synthetic datasets with d ∈ {32, 128, 512, 1024}, build NSG indices, apply best reordering, and plot speedup vs. dimensionality

## Open Questions the Paper Calls Out

1. What graph structural metrics, beyond community strength (Local Clustering Coefficient), can reliably predict the effectiveness of reordering for GPU-based ANNS? The authors conclude that "conventional structural metrics like community strength do not reliably predict reordering effectiveness" and fail to find a correlation between LCC and speed-up.

2. How can an intelligent system automatically select the optimal reordering algorithm (e.g., RCM vs. Degree Sort) based on dataset characteristics? The "Conclusion and Future Work" section explicitly lists "developing intelligent reordering algorithm selection based on graph properties" as a primary direction for future research.

3. Can novel graph index topologies be designed specifically to maximize GPU memory hierarchy utilization, rather than optimizing existing CPU-oriented structures? The authors list "advancing novel index topologies optimized for GPU memory hierarchies" as a key area for future work.

## Limitations

- The paper's core claim depends critically on the correctness of the graph adapter layer, which is not yet available as source code
- The negative correlation between dimensionality and reordering effectiveness is based on correlation analysis without establishing causation
- The unified traversal engine may not capture true performance characteristics for indices with fundamentally different search strategies
- The paper excludes hierarchical graph indices like HNSW, limiting generalizability to all ANNS approaches

## Confidence

- **High Confidence**: Memory coalescing mechanism and its relationship to vertex collocation; preservation of search accuracy during reordering; orthogonal nature of layout optimization
- **Medium Confidence**: Negative correlation between dimensionality and reordering effectiveness; dataset-specific variability in reordering benefits; claim that CAGRA is dimension-agnostic
- **Low Confidence**: Precise causal mechanisms behind dataset-dependent reordering effectiveness; whether the unified traversal engine truly eliminates all implementation biases; generalizability to indices beyond the four studied

## Next Checks

1. **Adapter Verification**: Implement the graph adapter conversion process and validate that it preserves graph topology by comparing edge connectivity before/after conversion for all four index types.

2. **Dimensionality Threshold**: Systematically test reordering effectiveness across a broader range of dimensions (32-1536) to identify the precise dimensionality threshold where benefits plateau or reverse.

3. **Community Structure Analysis**: Measure local clustering coefficient distributions for all datasets and correlate with reordering effectiveness to validate the community structure hypothesis beyond the preliminary observations presented.