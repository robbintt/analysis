---
ver: rpa2
title: Counterfactual Scenarios for Automated Planning
arxiv_id: '2508.21521'
source_url: https://arxiv.org/abs/2508.21521
tags:
- counterfactual
- planning
- problem
- plan
- goal
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: This paper introduces counterfactual scenarios for automated planning,
  a novel explanation paradigm that identifies minimal modifications to a planning
  problem enabling plans that satisfy user-specified LTLf properties. Unlike existing
  approaches that modify plans or policies, counterfactual scenarios alter the planning
  problem itself, making them applicable even when no initial plan exists.
---

# Counterfactual Scenarios for Automated Planning

## Quick Facts
- arXiv ID: 2508.21521
- Source URL: https://arxiv.org/abs/2508.21521
- Reference count: 13
- This paper introduces counterfactual scenarios for automated planning, showing they are PSPACE-complete in most cases

## Executive Summary
This paper introduces counterfactual scenarios for automated planning, a novel explanation paradigm that identifies minimal modifications to a planning problem enabling plans that satisfy user-specified LTLf properties. Unlike existing approaches that modify plans or policies, counterfactual scenarios alter the planning problem itself, making them applicable even when no initial plan exists. The authors formalize existential and universal variants of counterfactual scenarios, allowing changes to initial states, goals, or action preconditions.

The key contribution is characterizing the computational complexity of generating such scenarios, showing that most cases are PSPACE-complete, matching the complexity of solving planning problems. This result demonstrates the practical feasibility of counterfactual scenarios and provides a foundation for developing algorithms that can diagnose planning problems, guide domain design, and enhance user interaction with planning systems.

## Method Summary
The method translates classical planning problems into LTLf formulas whose models correspond to valid plans, then searches for minimal modifications by enumerating candidate changes and testing LTLf properties. For each candidate modification (e.g., initial state differing by ≤K fluents), the modified problem P' is constructed and tested whether existentially or universally it admits plans satisfying the user-specified LTLf property ψ. This reduces to LTLf satisfiability or validity checking, leveraging existing PSPACE-complete procedures.

## Key Results
- Counterfactual scenarios are PSPACE-complete in most cases, matching the complexity of planning itself
- For existential counterfactuals, only weakening (preconditions, goals) is useful; for universal counterfactuals, only strengthening applies
- The framework handles three change classes: initial states, goals, and action preconditions
- Counterfactual scenarios can explain why planning problems are unsolvable by identifying minimal fixable changes

## Why This Works (Mechanism)

### Mechanism 1
- Claim: Planning problems can be translated into LTLf formulas whose models correspond to valid plans.
- Mechanism: Given a planning problem P = ⟨F, A, I, G⟩, encode it as LTLf formula [P]G over alphabet A ∪ F. Actions that appear true in the model indicate execution steps, and fluents encode visited states. This allows counterfactual search to leverage LTLf satisfiability/validity procedures.
- Core assumption: Planning is classical (finite-state, Boolean fluents); numeric planning is undecidable and thus excluded.
- Evidence anchors:
  - [abstract]: "LTLf formula ψ defining desired properties of a plan"
  - [section]: Proposition 1 (Cialdea Mayer et al. 2007) in Section 6: "from any model of [P]G one can extract in polynomial time a solution plan for P"
  - [corpus]: Related work on LTLf confirms PSPACE-completeness of satisfiability (De Giacomo and Vardi 2013)
- Break condition: Numeric or hybrid domains where planning becomes undecidable.

### Mechanism 2
- Claim: Counterfactual scenarios are found by enumerating minimal modifications and testing LTLf properties.
- Mechanism: For each candidate modification (e.g., initial state differing by ≤K fluents), construct modified problem P′ and test whether ∃π′ ∈ ΠP′ : π′ |= ψ (existential) or ∀π′ ∈ ΠP′ : π′ |= ψ (universal). This reduces to LTLf satisfiability or validity checking.
- Core assumption: The budget K and modification space allow tractable enumeration; LTLf procedures scale sufficiently.
- Evidence anchors:
  - [abstract]: "counterfactual scenarios identify minimal modifications to P"
  - [section]: Theorem 2 proof describes enumeration over initial states; Algorithm 1 counts goal states violating ψ
  - [corpus]: Corpus lacks direct evidence on enumeration strategies for counterfactual planning scenarios
- Break condition: Exponential state spaces (2^|F|) make brute-force enumeration impractical for large K.

### Mechanism 3
- Claim: For existential counterfactuals, only weakening (preconditions, goals) is useful; for universal counterfactuals, only strengthening applies.
- Mechanism: Weakening preconditions (disjoining with reachable states) enables new plans; strengthening goals (removing states reached by ψ-violating plans) forces compliance. This asymmetric strategy avoids wasted search.
- Core assumption: ψ is satisfiable; otherwise no counterfactual exists.
- Evidence anchors:
  - [abstract]: Not explicitly stated but implied by the formalization
  - [section]: Section 5: "for existential counterfactuals, only weakening the goal makes sense... for universal counterfactuals, weakening is never useful"
  - [corpus]: No corpus evidence on this pruning insight
- Break condition: User specifies unsatisfiable ψ (e.g., contradictory LTLf constraints).

## Foundational Learning

- **Concept: LTLf (Linear Temporal Logic on finite traces)**
  - Why needed here: User requirements ψ are expressed in LTLf; understanding operators (□ globally, ♢ eventually, U until, ⃝ next) is essential for writing and debugging specifications.
  - Quick check question: Given ψ := □(at(truck, depot) → ♢at(truck, butchery)), what does this require of all plans?

- **Concept: PSPACE-completeness**
  - Why needed here: Both planning and LTLf satisfiability are PSPACE-complete; the main result shows counterfactual generation remains PSPACE-complete in most cases, meaning it's "only as expensive as planning itself."
  - Quick check question: Why is PSPACE-completeness considered "feasible" compared to EXPTIME or undecidable?

- **Concept: Oracle machines and NEXPNP**
  - Why needed here: CSEP∀(Cact) has an upper bound of NEXPNP (nondeterministic exponential time with NP oracle); understanding this hierarchy helps assess theoretical tractability.
  - Quick check question: What does it mean for a problem to be in NEXPNP but not known to be PSPACE-complete?

## Architecture Onboarding

- **Component map:**
  Input parser -> Encoder -> Enumerator -> LTLf solver -> Optimizer

- **Critical path:**
  1. Parse P, ψ, K; select change class C
  2. Encode P as [P]G via Proposition 1
  3. For existential: iterate candidates, test ψ ∧ [P′]G satisfiability
  4. For universal: iterate candidates, test [P′]G → ψ validity (or equivalently, unsatisfiability of [P′]G ∧ ¬ψ)
  5. Return first valid candidate at minimum cost, or report non-existence

- **Design tradeoffs:**
  - Existential vs Universal: Existential (Ξ∃) is PSPACE-complete for all three change classes; Universal (Ξ∀) is PSPACE-complete for Cinit/Cgoal but NEXPNP for Cact (potentially harder)
  - Change class selection: Cinit is simplest (single fluent flips); Cgoal requires counting goal states; Cact requires tracking state-action pairs
  - Plausibility constraints: Encoded directly into ψ (e.g., conjoin ♢(∼⃝⊥ ∧ ϕgoal) for goal plausibility), increasing formula size but not complexity class

- **Failure signatures:**
  - No counterfactual exists: ψ may be fundamentally unsatisfiable, or K is too small
  - Incoherent problem generated: Modification creates impossible state (e.g., at(truck, depot) ∧ at(truck, butchery)); requires plausibility constraints
  - Timeout on LTLf solver: Excessive formula length or deep temporal nesting; consider bounded horizon approximations

- **First 3 experiments:**
  1. Implement CSEP∃(Cinit) on the food delivery domain (Example 1–2) with K=1; verify that changing driver's initial location to depot yields a solvable problem.
  2. Test CSEP∀(Cgoal) on a modified logistics domain with constraint "all plans must return truck to depot"; verify goal strengthening (adding at(truck, depot)) works.
  3. Compare runtime scaling of CSEP∃(Cinit) vs CSEP∀(Cact) as |F| increases, confirming PSPACE vs NEXPNP separation empirically on small instances.

## Open Questions the Paper Calls Out

### Open Question 1
- Question: Is the universal action precondition counterfactual scenario existence problem (CSEP∀(Cact)) PSPACE-complete, or does it strictly require NEXPNP resources?
- Basis in paper: [explicit] The paper notes that while CSEP∀(Cact) belongs to NEXPNP, "a matching lower bound is still missing and not trivial to prove."
- Why unresolved: Proving lower bounds for this specific interaction of planning problems and LTLf modifications is technically complex and was not resolved in the initial complexity analysis.
- What evidence would resolve it: A formal reduction proving PSPACE-hardness or a proof establishing the necessity of the NEXPNP upper bound.

### Open Question 2
- Question: Can algorithmic techniques from the model repair domain be effectively adapted to compute counterfactual scenarios while integrating plausibility constraints?
- Basis in paper: [explicit] The authors state it would be "interesting to investigate whether some of the algorithmic techniques developed in that [model repair] space could be adapted to compute counterfactual scenarios."
- Why unresolved: While model repair shares similarities with counterfactual scenarios, the latter must handle arbitrary LTLf specifications and distinct plausibility requirements, necessitating specific algorithmic development.
- What evidence would resolve it: The implementation and empirical evaluation of an algorithm that translates model repair techniques into the counterfactual scenario framework.

### Open Question 3
- Question: How can the framework be extended to modify action effects without resulting in trivial or implausible solutions?
- Basis in paper: [inferred] The authors explicitly exclude modifying action effects to avoid "trivial counterfactuals" (e.g., achieving a goal immediately via a modified effect), noting only that the framework "can easily accommodate" them technically.
- Why unresolved: The current work focuses on preconditions, initial states, and goals; a rigorous method for constraining effect modifications to ensure they remain useful and realistic is undefined.
- What evidence would resolve it: A formal definition of a "possible-change relation" for effects that incorporates plausibility constraints and the subsequent complexity analysis.

## Limitations
- Enumeration-based approaches may face exponential blowup in state spaces (2^|F|) for large K values
- The NEXPNP complexity for universal action counterfactuals (CSEP∀(Cact)) suggests potentially worse-than-PSPACE behavior
- Practical scalability for moderate-to-large planning problems remains unverified

## Confidence
- **High confidence**: The theoretical characterization of computational complexity (PSPACE-completeness for most variants) is well-supported by formal proofs and reductions to LTLf satisfiability/validity
- **Medium confidence**: The pruning strategy (only weakening for existential, only strengthening for universal) is logically sound but lacks empirical validation on real planning domains
- **Low confidence**: The practical feasibility of enumeration-based approaches for moderate-to-large K values remains unverified

## Next Checks
1. Implement the food delivery domain (Example 1) with CSEP∃(Cinit) and K=1 to verify that changing the driver's initial location to the depot yields a solvable problem, confirming the basic mechanism works as intended.

2. Test CSEP∀(Cgoal) on a logistics domain with a return-to-depot constraint, measuring whether goal strengthening correctly forces compliance while maintaining plan existence.

3. Compare empirical runtime scaling of CSEP∃(Cinit) versus CSEP∀(Cact) as the number of fluents increases, using small instances to confirm the theoretical PSPACE versus NEXPNP complexity separation.