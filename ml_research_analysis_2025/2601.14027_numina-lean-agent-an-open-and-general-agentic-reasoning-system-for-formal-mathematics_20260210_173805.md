---
ver: rpa2
title: 'Numina-Lean-Agent: An Open and General Agentic Reasoning System for Formal
  Mathematics'
arxiv_id: '2601.14027'
source_url: https://arxiv.org/abs/2601.14027
tags:
- numina-lean-agent
- formal
- lean
- proof
- reasoning
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: This paper introduces Numina-Lean-Agent, a general agentic reasoning
  system for formal mathematics built on Claude Code and Numina-Lean-MCP. The system
  uses a general coding agent paradigm to interact with the Lean theorem prover, enabling
  diverse reasoning tasks beyond traditional theorem proving.
---

# Numina-Lean-Agent: An Open and General Agentic Reasoning System for Formal Mathematics

## Quick Facts
- arXiv ID: 2601.14027
- Source URL: https://arxiv.org/abs/2601.14027
- Reference count: 3
- Primary result: Achieved 12/12 on Putnam 2025 using Claude Opus 4.5, matching top closed-source systems

## Executive Summary
Numina-Lean-Agent is an open agentic reasoning system for formal mathematics that leverages a general coding agent paradigm to interact with the Lean theorem prover. Built on Claude Code and Numina-Lean-MCP, the system uses specialized tools for theorem retrieval, informal proof generation, and autonomous formalization. The approach demonstrates that general-purpose coding agents can effectively handle diverse mathematical reasoning tasks without task-specific training. The system achieved state-of-the-art performance by solving all 12 Putnam 2025 problems and demonstrated its generality through successful human-AI collaboration to formalize the Brascamp-Lieb theorem.

## Method Summary
Numina-Lean-Agent uses Claude Code as a base agent that autonomously orchestrates specialized tools via the Model Context Protocol. The system integrates Lean-LSP-MCP for Lean interaction, LeanDex for semantic theorem retrieval, an iterative Generator-Verifier loop for informal proof refinement, and a blueprint-based hierarchical decomposition strategy for complex theorems. The agent dynamically selects and invokes appropriate tools within Numina-Lean-MCP to handle diverse queries, from simple theorem proving to long-horizon formalization tasks. The approach is training-free, relying on the reasoning capability of the underlying LLM and specialized tool orchestration rather than fine-tuned formal provers.

## Key Results
- Solved all 12 problems in Putnam 2025 (12/12) using Claude Opus 4.5, matching the best closed-source systems
- Successfully formalized the Brascamp-Lieb theorem through human-AI collaboration, producing over 8,000 lines of Lean code
- Demonstrated state-of-the-art performance without requiring task-specific training or fine-tuning

## Why This Works (Mechanism)

### Mechanism 1: General Coding Agent as Formal Math Reasoner
The system uses Claude Code as a general-purpose coding agent that autonomously selects and invokes specialized tools via MCP. This training-free approach relies on the base model's reasoning capability to decompose mathematical problems and orchestrate tool calls effectively.

### Mechanism 2: Iterative Informal Proof Refinement
An iterative Generator-Verifier loop produces more reliable informal proofs than independent sampling. The Verifier evaluates solutions three times independently, providing feedback to the Generator until convergence, which improves downstream formalization success.

### Mechanism 3: Blueprint-Based Hierarchical Decomposition
Explicit planning via blueprints—DAGs of definitions, lemmas, and dependencies—enables long-horizon formalization. Critically, the blueprint is recursively refined using compilation feedback from Lean, creating a closed-loop "plan–formalize–refine" workflow.

## Foundational Learning

- **Lean 4 Theorem Prover Basics**: Understanding tactic-based proving, type classes, and proof states is essential. Quick check: Can you explain what a `sorry` placeholder means in Lean and how the `ring` tactic works?
- **Model Context Protocol (MCP)**: Understanding how MCP servers expose tools and how agents call them is critical for extending the system. Quick check: What is the difference between an MCP tool and a direct API call in terms of agent autonomy?
- **Agentic Reasoning Patterns**: Understanding multi-step autonomous reasoning patterns helps predict where failures occur. Quick check: How does a "trial-feedback-optimization" closed loop differ from one-shot generation?

## Architecture Onboarding

- **Component map**: Claude Code -> Numina-Lean-MCP -> (Lean-LSP-MCP, LeanDex, Informal Prover, Discussion Partner)
- **Critical path**: Start with Lean-LSP-MCP → verify basic Lean interaction works → add LeanDex for retrieval → integrate Informal Prover → enable Discussion Partner for complex proofs. Minimal viable system: Claude Code + Lean-LSP-MCP.
- **Design tradeoffs**: Training-free vs. trained prover (no fine-tuning required, but depends heavily on base model capability); Sequential vs. parallel execution (simpler debugging, but slower); Verbose vs. concise proofs (system generates correct but often verbose code).
- **Failure signatures**: Context overload (model's instruction-following