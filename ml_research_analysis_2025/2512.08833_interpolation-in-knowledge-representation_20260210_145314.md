---
ver: rpa2
title: Interpolation in Knowledge Representation
arxiv_id: '2512.08833'
source_url: https://arxiv.org/abs/2512.08833
tags:
- interpolation
- logic
- uniform
- interpolants
- interpolant
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: 'The paper discusses interpolation in two prominent knowledge representation
  formalisms: description logics (DLs) and logic programming. In DLs, it focuses on
  uniform interpolation for ontologies and Craig interpolation for concept descriptions.'
---

# Interpolation in Knowledge Representation

## Quick Facts
- arXiv ID: 2512.08833
- Source URL: https://arxiv.org/abs/2512.08833
- Authors: Jean Christoph Jung; Patrick Koopmann; Matthias Knorr
- Reference count: 40
- Primary result: Discusses uniform and Craig interpolation for description logics and logic programming, showing existence conditions and computation methods

## Executive Summary
This paper systematically explores interpolation in knowledge representation, focusing on description logics (DLs) and logic programming. It distinguishes between uniform interpolation (forgetting symbols outside a target signature) and Craig interpolation (constructing formulas using only common symbols). The work provides theoretical characterizations of when interpolants exist, decision procedures for their existence, and practical methods for their computation. Results show that while Craig interpolants always exist for many DLs, uniform interpolants may not, with 2ExpTime complexity for existence testing in ALC.

## Method Summary
The paper employs multiple complementary approaches for computing interpolants. For uniform interpolation in DLs, it combines resolution-based inference with Ackermann's Lemma to systematically eliminate symbols outside the target signature. For Craig interpolation, it uses a characterization via joint Σ-bisimulation consistency, implementing this through mosaic elimination. For logic programming, it defines forgetting operators that preserve answer set consequences under projection. These methods are implemented in tools like Lethe (resolution-based) and FAME (Ackermann-based) for DLs, while ASP forgetting operators are characterized by consequence persistence properties.

## Key Results
- Uniform interpolants don't always exist in ALC but can be computed when they do, with 2ExpTime-complete existence decision
- ALC and extensions with S, I, F enjoy the Craig Interpolation Property, while ALCO and ALCH do not
- Logic programming uniform interpolants (forgetting results) exist for coherent propositional programs
- Practical tools Lethe and FAME implement different approaches to DL uniform interpolation
- Beth definability is closely related to interpolation and has applications in learning and query answering

## Why This Works (Mechanism)

### Mechanism 1: Uniform Interpolation via Resolution and Ackermann's Lemma
- Claim: Uniform interpolants for ALC ontologies can be computed by combining resolution-based inference with Ackermann's Lemma to systematically eliminate symbols outside the target signature.
- Mechanism: Ontologies are normalized into DL clauses using "definers" (fresh concept names). Resolution and role propagation rules perform inferences on symbols to be eliminated while maintaining an invariant (at most one negative definer per clause). After saturation, Ackermann's Lemma (or its generalized fixpoint version) eliminates the definers, yielding the interpolant.
- Core assumption: The ontology can be normalized such that definers isolate negative occurrences of symbols to be eliminated.
- Evidence anchors:
  - [abstract]: "methods implemented in tools like Lethe and FAME"
  - [section 3.2]: Describes the Lethe approach combining resolution with Ackermann's lemma, including the resolution rule "C₁⊔A, C₂⊔¬A / C₁⊔C₂" and role propagation rule.
  - [corpus]: Weak direct evidence; related work on approximation fixpoint theory touches on non-monotonic semantics but not this specific resolution method.
- Break condition: Uniform interpolants do not always exist in ALC (2ExpTime-complete to decide existence). When non-existence occurs, fixpoints or auxiliary symbols may be needed.

### Mechanism 2: Craig Interpolation via Mosaic Elimination and Bisimulation Characterization
- Claim: Interpolant existence for DL concepts is characterized by joint ∼L,Σ-consistency under ontologies, which can be decided via mosaic elimination.
- Mechanism: A "mosaic" (t₁, t₂) represents two elements from two models that are Σ-bisimilar. Bad mosaics violating atomic consistency or existential saturation are iteratively eliminated. If the fixpoint contains a mosaic with C₁∈t₁ and C₂∈t₂, no interpolant exists; otherwise, an interpolant can be constructed from the elimination sequence.
- Core assumption: The DL's bisimulation notion correctly captures its expressive power (holds for ALC and standard extensions).
- Evidence anchors:
  - [section 4.1]: Lemma 19 and Lemma 23 formally establish the characterization via joint consistency and mosaic elimination.
  - [section 4.1]: Theorem 18 confirms ALC and extensions with S, I, F enjoy the Craig Interpolation Property.
  - [corpus]: "Space Explanations of Neural Network Classification" leverages Craig interpolation algorithms for provable guarantees—indirect support for interpolation's utility.
- Break condition: ALCO and ALCH (with nominals or role hierarchies) do NOT enjoy CIP (Theorem 22). Interpolant existence becomes 2ExpTime-complete rather than trivial.

### Mechanism 3: Logic Programming Forgetting via Consequence Persistence
- Claim: For coherent propositional programs, uniform interpolants (forgetting results) exist and can be characterized by preserving answer sets under projection.
- Mechanism: A forgetting operator f satisfying Consequence Persistence (CP) ensures AS(f(P,V)) = AS(P) ∥V (answer sets of the result equal original answer sets projected to remaining atoms). This guarantees the result is a uniform (V, |∼c)-interpolant.
- Core assumption: Programs are coherent (have at least one answer set) and in the propositional case (or safe, function-free first-order).
- Evidence anchors:
  - [section 5.3]: Theorem 44 guarantees uniform (V, |∼c)-interpolants exist for propositional programs.
  - [section 5.3]: Definition 42 and property (CP) formalize the forgetting operator requirements.
  - [corpus]: "Approximation Fixpoint Theory with Refined Approximation Spaces" covers non-monotonic semantics in logic programming—conceptually related but not directly about forgetting operators.
- Break condition: Strong Persistence (SP)—preserving answer sets under arbitrary program additions—is not always achievable. First-order programs with function symbols may lack first-order definable interpolants.

## Foundational Learning

- Concept: **Signature and Symbol Elimination**
  - Why needed here: Interpolation fundamentally restricts formulas to use only symbols in a target signature. Understanding what symbols are "forgotten" vs. preserved is central.
  - Quick check question: Given ontology O = {A ⊑ B, B ⊑ ∃r.B} and signature Σ = {A, r}, which symbol is being eliminated and what entailments must be preserved?

- Concept: **Bisimulation in Description Logics**
  - Why needed here: Mosaic elimination and interpolant characterization rely on Σ-bisimulation to determine when two domain elements are indistinguishable using Σ-concepts.
  - Quick check question: In an ALC(Σ)-bisimulation between interpretations I₁ and I₂, what three conditions must hold for each pair (d, e) in the bisimulation relation?

- Concept: **Answer Set Semantics and HT-models**
  - Why needed here: Logic programming interpolation uses the logic of here-and-there (HT) as the deductive base for stable model semantics.
  - Quick check question: Given a ground program P, what is the relationship between HT-models HT(P) and answer sets AS(P)?

## Architecture Onboarding

- Component map:
  - **DL Uniform Interpolation Pipeline**: Ontology → Normalization (DL clauses + definers) → Resolution/Role Propagation → Ackermann Elimination → Uniform Interpolant
  - **DL Craig Interpolation Pipeline**: Concepts + Ontology → Type Computation → Mosaic Set → Elimination Loop → Interpolant Construction
  - **LP Forgetting Pipeline**: Program → HT-model Computation → Forgetting Operator (e.g., FSM class) → Result Program

- Critical path:
  1. Determine target signature Σ and symbols to eliminate
  2. Check interpolant existence (trivial for DLs with CIP; requires decision procedure otherwise)
  3. Apply appropriate computation method based on formalism and existence

- Design tradeoffs:
  - Lethe (resolution-based): Always produces result in ALCμ; may introduce fixpoints even when ALC interpolant exists
  - FAME (Ackermann-based): Produces SOL(Σ)-inseparable results ("semantic forgetting") but cannot compute for all inputs
  - Approximation: Bounded role depth guarantees but may miss deeper entailments

- Failure signatures:
  - **Non-existence**: Triple-exponential blowup or infinite entailment chain (e.g., A ⊑ ∃r.∃r.∃r...). Fixpoint operators required.
  - **CIP violation**: ALCO/ALCH may have valid subsumptions with no Craig interpolant in the common signature.
  - **Strong persistence failure**: In ASP, forgetting with SP is not always possible; may need to settle for weaker (CP) or restrict added programs to facts.

- First 3 experiments:
  1. Run Lethe on SNOMED-CT subset with a small signature to observe definers introduced and final interpolant size; verify Σ-inseparability using a DL reasoner.
  2. Implement mosaic elimination for ALC on toy examples (e.g., Example 16) and compare constructed interpolants against manually derived ones.
  3. Apply FSM-class forgetting operator to a propositional ASP program (e.g., Example 37) and verify CP holds by comparing AS(P) ∥V against AS(f(P,V)).

## Open Questions the Paper Calls Out
None

## Limitations
- Uniform interpolant existence is undecidable for many DL fragments, with 2ExpTime complexity for ALC
- Craig interpolation fails for DLs with nominals (ALCO) or role hierarchies (ALCH)
- First-order logic programming interpolation is limited by safety requirements and function symbols

## Confidence
- High: DLs with Craig Interpolation Property (ALC, extensions with S, I, F); uniform interpolant existence characterization via consequence preservation in propositional ASP
- Medium: Practical effectiveness of Lethe/FAME implementations; complexity bounds for interpolation decision procedures
- Low: Scalability of current implementations on large ontologies; effectiveness of approximation methods for deep role chains

## Next Checks
1. Benchmark Lethe on a realistic ontology subset (e.g., SNOMED-CT) to measure interpolant size growth and computational feasibility for practical signature sizes.
2. Systematically test Craig interpolation failure cases in ALCO/ALCH to characterize exactly when interpolants exist and when they don't.
3. Evaluate the forgetting operator's behavior on ASP programs with complex rules beyond facts to assess the gap between CP and SP guarantees in practice.