---
ver: rpa2
title: 'AgriAgent: Contract-Driven Planning and Capability-Aware Tool Orchestration
  in Real-World Agriculture'
arxiv_id: '2601.08308'
source_url: https://arxiv.org/abs/2601.08308
tags:
- tool
- execution
- arxiv
- planning
- tasks
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: AgriAgent introduces a two-level agent framework for real-world
  agriculture that addresses the challenge of diverse task complexity and incomplete
  tool availability. The system routes tasks to System-1 for simple multimodal question
  answering or System-2 for complex tasks requiring contract-driven planning and capability-aware
  tool orchestration.
---

# AgriAgent: Contract-Driven Planning and Capability-Aware Tool Orchestration in Real-World Agriculture

## Quick Facts
- arXiv ID: 2601.08308
- Source URL: https://arxiv.org/abs/2601.08308
- Reference count: 13
- Primary result: Achieves 94.4-100% contract fulfillment rates and significantly improved execution success on complex agricultural tasks using a two-level agent framework with explicit contracts and capability-aware tool orchestration

## Executive Summary
AgriAgent introduces a two-level agent framework addressing the challenge of diverse task complexity and incomplete tool availability in real-world agriculture. The system routes simple multimodal queries to System-1 for fast-path processing while delegating complex multi-step tasks to System-2, which employs contract-driven planning and capability-aware tool orchestration. System-2 uses explicit contracts to formalize task requirements, enabling verifiable multi-step execution with failure recovery. The framework demonstrates significantly improved execution success rates and robustness compared to existing tool-centric agent baselines, achieving high contract fulfillment rates across different model scales while scaling to large tool inventories.

## Method Summary
The method implements a two-level agent framework with distinct routing and processing pathways. System-1 handles simple multimodal question answering through modality-specialized models (text, vision, omni) with unified RAG pipelines combining dense, sparse, and graph retrieval strategies. System-2 addresses complex tasks using contract-driven planning with DAG-based task specification, where each node includes explicit goals, inputs, outputs, constraints, and evidence requirements. The framework employs a multi-agent debate process for plan refinement, ToolHub with dual-protocol matching (TDI for capability matching, TOCI for schema composition) for adaptive tool selection, and ToolMaker as a fallback for on-demand tool generation. The approach is evaluated across 1,000 complex agricultural tasks with tool inventories ranging from 24 to 506 tools.

## Key Results
- Contract fulfillment rates of 94.4-100% across different model scales (Qwen2.5-7B/14B, Qwen3-8B/32B/235B, LLaMA3-8B, AgriGPT-8B, DeepSeek-v3.1)
- ToolHub maintains stable Hit@1 performance (0.907-0.937) across 24→506 tool scales while prompt-based baselines degrade to 0.031-0.353
- Consistent Hit@1/3/5 scores above 75-90% for tool selection accuracy at scale
- Significant improvement in execution success rates and robustness on complex agricultural tasks compared to existing tool-centric agent baselines

## Why This Works (Mechanism)

### Mechanism 1
- Claim: Explicit structural representation of tasks reduces cascading execution errors in multi-step workflows.
- Mechanism: Tasks are encoded as Directed Acyclic Graphs (DAGs) where each node vi = ⟨gi, Ii, Oi, Ci, Ei⟩ specifies goal, inputs, outputs, constraints, and evidence requirements. This transforms implicit reasoning chains into inspectable, editable structures that can be validated before execution.
- Core assumption: Models can reliably generate structured outputs conforming to predefined schemas when given explicit specification formats.
- Evidence anchors: Abstract states "formulates tasks as capability requirements and performs capability-aware tool orchestration"; section 3.3.1 explains this explicit representation enables systematic planning refinement, execution control, and error localization.

### Mechanism 2
- Claim: Decoupling capability requirements from tool implementations via dual-protocol matching improves tool selection at scale.
- Mechanism: ToolHub uses TDI (Tool Description Index) for semantic capability matching against need contracts, then TOCI (Tool Output Composition Index) verifies schema compatibility for composition. This two-stage filter prevents invalid tool chains before execution.
- Core assumption: Tool metadata embeddings accurately capture functional capabilities and schema constraints can be explicitly represented.
- Evidence anchors: Abstract mentions "ToolHub with dual-protocol matching (TDI/TOCI) for adaptive tool selection, composition"; table 2 shows ToolHub maintains stable Hit@1 (0.907-0.937) across 24→506 tool scales while prompt baselines degrade to 0.031-0.353.

### Mechanism 3
- Claim: Routing by task complexity prevents over-processing simple queries and under-planning complex workflows.
- Mechanism: A Router classifies tasks by semantic complexity and execution requirements. Single-step, weakly-dependent tasks → System-1 (direct multimodal reasoning with RAG). Multi-step, tool-dependent tasks → System-2 (contract planning, tool orchestration).
- Core assumption: Complexity classification is reliable; misrouting simple tasks to System-2 incurs acceptable latency overhead.
- Evidence anchors: Abstract states "System-1 for fast-path multimodal question answering... System-2 for complex tasks using contract-driven planning"; section 3.1 specifies routing criteria based on task dependencies and tool usage requirements.

## Foundational Learning

- Concept: **Design by Contract (DbC)**
  - Why needed here: Need contracts specify preconditions, postconditions, and constraints that make agent execution verifiable rather than speculative.
  - Quick check question: Can you explain how a need contract differs from a standard function signature?

- Concept: **Directed Acyclic Graphs (DAGs) for workflow representation**
  - Why needed here: Plan specifications are DAG structures; understanding topological ordering and dependency resolution is essential for debugging execution traces.
  - Quick check question: Given nodes A→B→C and A→D→C, which nodes can execute in parallel?

- Concept: **Multi-path RAG (dense/sparse/graph)**
  - Why needed here: System-1 fuses three retrieval strategies; understanding when each path dominates helps diagnose retrieval failures.
  - Quick check question: Which retrieval path would best handle a query requiring multi-hop reasoning across related agricultural policies?

## Architecture Onboarding

- Component map: Router → System-1 (AgriGPT/AgriGPT-VL/AgriGPT-Omni + unified RAG) or System-2 (Debate → Need Contract → ToolHub (TDI/TOCI) → ToolMaker → Execution/Verification)
- Critical path: Router classifies task → System-1 processes simple queries directly or System-2 generates DAG → Debate refines plan → Need contract per node → TDI retrieves tools → TOCI validates composition → Execute → Verify against contracts
- Design tradeoffs: Robustness vs latency (System-2 adds 3-5 round trips), scalability vs specificity (ToolHub stable at 506 tools), verifiability vs flexibility (contracts constrain outputs)
- Failure signatures: Empty/degenerate outputs (schema parsing failure), tool chain rejection by TOCI (schema mismatch), debate deadlock (supervisors disagree without resolution)
- First 3 experiments: 1) Router boundary test: 50 queries spanning simple→complex spectrum; 2) ToolHub scale stress test: 24→506 tools incremental comparison; 3) Contract violation injection: 50 plans with intentional schema violations

## Open Questions the Paper Calls Out

### Open Question 1
- Question: How can contract-driven planning be adapted for strict real-time agricultural scenarios where latency constraints preclude multi-round verification and negotiation?
- Basis in paper: The authors state System-2 introduces "additional computational cost and interaction latency" and "may be less suitable for scenarios with strict real-time requirements, where further trade-offs between efficiency and robustness are necessary."
- Why unresolved: The paper does not propose mechanisms to reduce overhead or provide bounded-time guarantees for time-critical agricultural operations.
- What evidence would resolve it: A study comparing contract-driven planning against simplified execution paths under latency budgets, or an adaptive mechanism that dynamically contracts verification steps when time pressure is detected.

### Open Question 2
- Question: What techniques can improve smaller models' adherence to structured output schemas required by contract-driven planning?
- Basis in paper: The authors note contract-driven planning "relies on models' ability to consistently follow predefined output schemas" and deviations "may affect contract parsing and downstream execution. Improving robustness to format variations remains an important direction for future work."
- Why unresolved: The paper demonstrates benefits with capable models but does not address how to maintain schema compliance when using smaller or less capable models common in edge deployments.
- What evidence would resolve it: Experiments showing schema adherence rates across model sizes with proposed mitigation strategies (e.g., constrained decoding, schema-aware fine-tuning, or post-hoc correction modules).

### Open Question 3
- Question: How does AgriAgent generalize to non-agricultural domains with different tool ecosystems and constraint structures?
- Basis in paper: The framework is specialized for agricultural tasks with domain-specific models (AgriGPT, AgriGPT-VL) and agricultural tool registries, but the core mechanisms (contract-driven planning, ToolHub, ToolMaker) are domain-agnostic. No transfer experiments are reported.
- Why unresolved: The architectural contributions may be broadly applicable, but without cross-domain evaluation, it remains unclear whether the benefits stem from domain specialization or from the general framework design.
- What evidence would resolve it: Experiments applying AgriAgent's System-2 components (contracts, ToolHub, ToolMaker) to another domain (e.g., healthcare, manufacturing) with comparable tool availability and task complexity distributions.

## Limitations

- System-2 introduces additional latency (3-5 round trips) for debate refinement and contract verification, potentially unsuitable for strict real-time applications
- Contract-based approach may reject valid creative solutions that don't fit predefined schemas, trading flexibility for verifiability
- Router's complexity classification is critical but not extensively validated—misclassification rates could significantly impact overall system efficiency

## Confidence

- High: System-1 multimodal performance on tested datasets; ToolHub's consistent Hit@1 performance across 24→506 tool scales
- Medium: System-2 contract fulfillment rates (94.4-100%); Router's ability to correctly classify task complexity boundaries
- Low: Generalization to domains beyond agriculture; Performance with truly open-ended tool creation requests; Scalability beyond 506 tools without architectural modifications

## Next Checks

1. **Router boundary validation**: Submit 100 tasks spanning simple to complex spectrum, including ambiguous cases near the classification boundary. Measure both classification accuracy and latency impact when misclassified tasks are processed by the wrong system.

2. **Schema constraint stress test**: Design 50 tool creation requests that intentionally push against or violate the TOCI schema compatibility rules. Verify that ToolMaker can handle creative solutions that don't fit strict schemas while maintaining verifiability.

3. **Multi-agent debate robustness**: Introduce adversarial supervisor configurations (deliberately poor critique/defense strategies) and measure system resilience. Test whether the debate process converges to valid plans within reasonable iteration limits or becomes deadlocked.