---
ver: rpa2
title: Proving Theorems Recursively
arxiv_id: '2405.14414'
source_url: https://arxiv.org/abs/2405.14414
tags:
- proof
- level
- poetry
- theorem
- search
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: POETRY introduces recursive theorem proving to overcome the limitations
  of short-sighted heuristics in step-by-step approaches. Instead of proving theorems
  step-by-step, it first generates a verifiable proof sketch at each level, deferring
  the proofs of intermediate conjectures to deeper levels using a sorry tactic.
---

# Proving Theorems Recursively

## Quick Facts
- arXiv ID: 2405.14414
- Source URL: https://arxiv.org/abs/2405.14414
- Reference count: 33
- Key outcome: POETRY achieves 42.2% success rate on miniF2F, a 5.1% improvement over state-of-the-art

## Executive Summary
POETRY introduces a recursive approach to theorem proving that overcomes the limitations of step-by-step methods by generating verifiable proof sketches at each level. Instead of proving theorems directly, it uses a "sorry" tactic to defer intermediate conjectures to deeper levels, enabling the discovery of significantly longer proofs (up to 26 steps versus 10 for previous methods). The recursive best-first search algorithm allows the system to pause and continue the search across different proof levels, finding proofs that were previously unreachable.

## Method Summary
POETRY operates by first generating a proof sketch using a language model, where intermediate conjectures are replaced with "sorry" tactics. A recursive best-first search then conducts level-by-level proof search, pausing at each level to solve the current target theorem while deferring detailed proofs of intermediate steps. Once a proof sketch is found, the search continues to deeper levels to resolve the skipped conjectures. The system uses node status labels (OPEN, FAILED, PROVED, HALF-PROVED) and sorry edges to manage the proof search tree, allowing for efficient backtracking and continuation of the search.

## Key Results
- Achieves 42.2% success rate on miniF2F, a 5.1% improvement over state-of-the-art
- Finds proofs up to 26 steps long, compared to 10 steps for previous methods
- Outperforms step-by-step baselines by 3.9% on average and discovers previously unprovable theorems

## Why This Works (Mechanism)

### Mechanism 1
- Claim: Recursive theorem proving overcomes the limitations of short-sighted heuristics by decomposing long proofs into manageable proof sketches at each level.
- Mechanism: The algorithm first generates a verifiable proof sketch at each level, replacing intermediate conjectures with the sorry tactic. This allows tackling complex proofs incrementally by deferring detailed proofs of intermediate steps to deeper levels.
- Core assumption: Breaking down a long proof into shorter proof sketches prevents the search space from expanding exponentially as the proof length increases.
- Evidence anchors:
  - [abstract] "POETRY searches for a verifiable sketch of the proof at each level and focuses on solving the current level's theorem or conjecture. Detailed proofs of intermediate conjectures within the sketch are temporarily replaced by a placeholder tactic called sorry, deferring their proofs to subsequent levels."
  - [section 3.1] "Each proof sketch focuses solely on the target theorem, conjectures, or subgoals, with the detailed proof of intermediate conjectures or subgoals replaced by the sorry tactic."
- Break condition: If the sorry tactic is incorrectly applied, leading to false intermediate conjectures that cannot be proven at deeper levels, the proof sketch becomes invalid.

### Mechanism 2
- Claim: Recursive best-first search enables pausing and continuing the search across different proof levels, allowing for more efficient exploration of the proof space.
- Mechanism: The algorithm employs best-first search to find proof sketches at each level. When a proof sketch is found, it pauses the search at the current level and proceeds to the next level to solve the skipped middle conjectures. Once all sketches are found and middle conjectures are resolved, a complete proof is achieved.
- Core assumption: The best-first search technique can be enhanced to handle multi-level proofs and dynamically shift between current and subsequent proof layers based on the progress and outcomes of proof sketches.
- Evidence anchors:
  - [abstract] "POETRY introduces a novel recursive best-first search (recursive BFS) algorithm to conduct a level-by-level proof search."
  - [section 3.2] "Recursive BFS employs the best-first search technique to search for proof sketches at each level. When a proof sketch is found at a certain level, the algorithm pauses the search at this current level and then proceeds to the next level to solve the skipped middle conjectures."
- Break condition: If the search algorithm fails to find a valid proof sketch at any level, the entire proof attempt fails.

### Mechanism 3
- Claim: The sorry edge and node status system allows for efficient management of the proof search tree, enabling backtracking and continuation of the search when necessary.
- Mechanism: The sorry edge is used to connect parent and child nodes when a proof step contains a "sorry" keyword. Node status labels (OPEN, FAILED, PROVED, HALF-PROVED) are used to track the progress of the search and determine when to pause and continue the search across different levels.
- Core assumption: The sorry edge and node status system can effectively manage the proof search tree and enable efficient backtracking and continuation of the search.
- Evidence anchors:
  - [abstract] "As shown in Figure 2(a), each node in the proof tree is a proof state and each edge is a proof step. In a proof state, once a tactic contains a 'sorry' keyword (usually after a conjecture or subgoal), we use a special sorry edge to connect the parent node and the child node."
  - [section 3.2] "Moreover, we attach each node in the search tree with one of the status labels: OPEN (the node is open, and no proof has been found so far), FAILED (the node is failed when all potential subproofs or child nodes stemming from it are unable to establish a valid proof), PROVED (the node is proven and part of the successful proof), and HALF-PROVED."
- Break condition: If the node status system fails to accurately track the progress of the search, leading to incorrect pausing and continuing of the search, the proof attempt may fail.

## Foundational Learning

- Concept: Formal theorem proving environments (e.g., Isabelle, Lean, Coq)
  - Why needed here: POETRY operates within the Isabelle theorem prover, which provides the formal environment for proving theorems. Understanding the basics of formal theorem proving environments is essential for grasping how POETRY works.
  - Quick check question: What is the role of a formal theorem proving environment like Isabelle in the context of POETRY?

- Concept: Proof sketches and the sorry tactic
  - Why needed here: POETRY relies on generating verifiable proof sketches at each level, with intermediate conjectures replaced by the sorry tactic. Understanding the concept of proof sketches and the sorry tactic is crucial for understanding how POETRY decomposes long proofs into manageable parts.
  - Quick check question: How does the sorry tactic enable POETRY to defer detailed proofs of intermediate conjectures to deeper levels?

- Concept: Best-first search and recursive algorithms
  - Why needed here: POETRY employs a recursive best-first search algorithm to conduct level-by-level proof search. Understanding the basics of best-first search and recursive algorithms is necessary for grasping how POETRY explores the proof space efficiently.
  - Quick check question: How does the recursive best-first search algorithm in POETRY differ from a standard best-first search algorithm?

## Architecture Onboarding

- Component map: Language model -> Proof sketch extractor -> Recursive best-first search -> Node status system
- Critical path: 1. Input theorem statement into Isabelle. 2. Extract proof sketches using the proof sketch extractor. 3. Conduct level-by-level proof search using recursive best-first search. 4. Generate proof steps using the language model. 5. Update node statuses and manage the proof search tree using the node status system. 6. Return complete proof when all levels are successfully proven.
- Design tradeoffs: Accuracy vs. efficiency: POETRY trades off some accuracy in the proof sketch generation for improved efficiency in the proof search. Depth vs. breadth: The recursive best-first search algorithm prioritizes depth over breadth, exploring deeper levels of the proof before considering alternative paths.
- Failure signatures: Invalid proof sketches: If the proof sketch extractor generates invalid proof sketches, the entire proof attempt may fail. Incorrect node status updates: If the node status system fails to accurately track the progress of the search, leading to incorrect pausing and continuing of the search, the proof attempt may fail. Language model errors: If the language model generates incorrect proof steps, the proof search may fail to find a valid proof.
- First 3 experiments: 1. Implement a basic proof sketch extractor that splits theorems into proof sketches without the sorry tactic. 2. Implement a recursive best-first search algorithm that conducts level-by-level proof search without pausing and continuing across different levels. 3. Implement a node status system that manages the proof search tree without using sorry edges and status labels.

## Open Questions the Paper Calls Out

### Open Question 1
- Question: How does the performance of POETRY scale with increasing proof length and complexity in comparison to step-by-step methods?
- Basis in paper: [explicit] The paper states that POETRY can find proofs up to 26 steps long, compared to 10 steps for previous methods, and significantly outperforms step-by-step baselines on average.
- Why unresolved: The paper does not provide a detailed analysis of how the performance of POETRY scales with increasing proof length and complexity, or a direct comparison of its scalability with step-by-step methods.
- What evidence would resolve it: A comprehensive study comparing the performance of POETRY and step-by-step methods on proofs of varying lengths and complexities, including an analysis of the scaling behavior and efficiency of both approaches.

### Open Question 2
- Question: How robust is POETRY to different formal mathematical environments, and what are the engineering challenges involved in extending it to other systems like Lean or Coq?
- Basis in paper: [explicit] The paper mentions that POETRY can be extended to other formal mathematical environments with additional engineering effort, but does not provide details on the specific challenges or the robustness of the approach in different systems.
- Why unresolved: The paper does not discuss the specific challenges involved in adapting POETRY to other formal mathematical environments or provide empirical evidence of its robustness in different systems.
- What evidence would resolve it: A detailed analysis of the engineering challenges involved in extending POETRY to other formal mathematical environments, along with empirical results demonstrating its performance and robustness in different systems.

### Open Question 3
- Question: How does the quality of the generated proof sketches impact the overall performance of POETRY, and what are the factors that influence the accuracy of the sketches?
- Basis in paper: [inferred] The paper mentions that the verified proof sketches might not always be correct due to mid-conjectures/subgoals' proof being skipped by sorry, and that ensuring the correctness of the proof sketch at each level significantly enhances performance.
- Why unresolved: The paper does not provide a detailed analysis of the factors that influence the accuracy of the generated proof sketches or how the quality of the sketches impacts the overall performance of POETRY.
- What evidence would resolve it: A comprehensive study analyzing the factors that influence the accuracy of the generated proof sketches, along with an investigation of how the quality of the sketches impacts the overall performance of POETRY.

## Limitations
- The exact implementation details of the ExtractProofSketch function are not provided, which is critical for reproducing the results
- The evaluation methodology for measuring "proofs found that were previously unprovable" lacks clarity on how this was determined
- The comparison to state-of-the-art methods only reports aggregate improvements without showing per-method breakdowns

## Confidence

- **High confidence**: The basic architecture of recursive proof sketches with sorry tactics is well-defined and implementable
- **Medium confidence**: The reported 5.1% improvement over state-of-the-art is plausible given the novel approach, but the exact comparison methodology is unclear
- **Low confidence**: The claim about finding "distinct sets of theorems that were previously unprovable" lacks sufficient methodological detail for verification

## Next Checks

1. Reproduce the proof sketch extraction: Implement the ExtractProofSketch function independently and verify that it generates similar distributions of proof lengths and sorry tactics as reported in the paper

2. Cross-validate proof uniqueness claims: Take a random sample of the "newly discovered proofs" and verify they cannot be generated by existing step-by-step theorem provers when given sufficient search time

3. Ablation study on recursion depth: Test the model with different maximum recursion depths (e.g., limiting to 3 levels instead of the reported approach) to quantify the contribution of deep recursion versus other architectural improvements