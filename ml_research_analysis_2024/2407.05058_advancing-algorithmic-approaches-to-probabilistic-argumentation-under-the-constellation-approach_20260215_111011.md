---
ver: rpa2
title: Advancing Algorithmic Approaches to Probabilistic Argumentation under the Constellation
  Approach
arxiv_id: '2407.05058'
source_url: https://arxiv.org/abs/2407.05058
tags:
- arguments
- argument
- complete
- given
- argumentation
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: "This paper addresses the high computational complexity of probabilistic\
  \ argumentation frameworks under the constellation approach, particularly for computing\
  \ the probability of a set being an extension and argument acceptability. The authors\
  \ refine existing complexity results, showing that these two tasks have different\
  \ underlying counting complexities: the former is P-complete while the latter is\
  \ \xB7NP-complete."
---

# Advancing Algorithmic Approaches to Probabilistic Argumentation under the Constellation Approach

## Quick Facts
- arXiv ID: 2407.05058
- Source URL: https://arxiv.org/abs/2407.05058
- Reference count: 15
- Key outcome: This paper develops a dynamic programming algorithm utilizing tree-decompositions to efficiently compute the probability of a set being a complete extension in probabilistic argumentation frameworks, showing promise for instances with up to 750 arguments when tree-width is at most 5.

## Executive Summary
This paper addresses the high computational complexity of probabilistic argumentation frameworks under the constellation approach, particularly for computing the probability of a set being an extension and argument acceptability. The authors refine existing complexity results, showing that these two main reasoning tasks diverge in their complexity: the former is #P-complete while the latter is #·NP-complete. They develop a dynamic programming algorithm utilizing tree-decompositions to efficiently compute the probability of a set being a complete extension, and experimentally evaluate its performance on instances with up to 750 arguments.

## Method Summary
The method employs dynamic programming operating on tree-decompositions of the argumentation graph to compute the probability of a set being a complete extension. The algorithm recursively computes partial solutions for each bag in the tree-decomposition, combining them at join nodes while tracking labelings and probabilities. This approach exploits the bounded tree-width to keep the state space polynomial in the input size. The implementation includes preprocessing to identify arguments with deterministically fixed labels, and offers both floating-point and rational number versions for different precision/speed tradeoffs.

## Key Results
- The algorithm can solve probabilistic argumentation problems that were previously considered intractable due to their high computational complexity
- Experimental evaluation shows no timeouts for tree-width at most 5, with instances containing up to 750 arguments being solvable
- The two main reasoning tasks (probability of set being extension vs. argument acceptability) have different underlying counting complexities: #P-complete vs #·NP-complete

## Why This Works (Mechanism)

### Mechanism 1
- Claim: Dynamic programming over tree-decompositions enables efficient computation of extension probabilities in probabilistic argumentation frameworks.
- Mechanism: The algorithm recursively computes partial solutions for each bag in the tree-decomposition, combining them at join nodes while tracking labelings and probabilities. By exploiting the bounded tree-width, the number of partial solutions per bag remains manageable.
- Core assumption: The tree-width of the argumentation graph is bounded, allowing the dynamic programming state space to remain polynomial in the input size.
- Evidence anchors:
  - [abstract]: "We present an algorithm for the complex task of computing the probability of a set of arguments being a complete extension by using dynamic programming operating on tree-decompositions."
  - [section]: "Inspired by their capability of solving #P-hard problems, we develop a dynamic programming algorithm for probabilistic AFs utilizing tree-decompositions (Bodlaender 1993)."

### Mechanism 2
- Claim: Counting the number of subframeworks where a set is an extension (#P-complete) has lower complexity than counting where an argument is accepted (#·NP-complete).
- Mechanism: The former problem can be solved by enumerating subframeworks and checking a fixed condition (set membership), while the latter requires checking existence of extensions containing the argument across subframeworks, introducing a search component.
- Core assumption: The complexity classes #P and #·NP correctly capture the inherent difficulty differences between these counting problems.
- Evidence anchors:
  - [abstract]: "We refine existing complexity results and show that two main reasoning tasks... diverge in their complexity: the former is #P-complete and the latter is #·NP-complete when considering their underlying counting problems."

### Mechanism 3
- Claim: Preprocessing can eliminate certain arguments from consideration by fixing their labels in all complete extensions.
- Mechanism: Arguments that are either unattacked and certain, or attacked by certain arguments with certain attacks, can be deterministically labeled (in or out), reducing the problem size before the main algorithm runs.
- Core assumption: The preprocessing rules correctly identify arguments whose labels are fixed across all subframeworks in FP(F).
- Evidence anchors:
  - [section]: "Example 5. Consider the PAF shown in Figure 2... Since argument a is unattacked and certain, all subframeworks in FP(F) contain a and in each complete labeling a is labeled 'in'."

## Foundational Learning

- Concept: Tree-decompositions and tree-width
  - Why needed here: The algorithm's efficiency depends on the tree-width being bounded, as it determines the size of partial solutions that need to be tracked.
  - Quick check question: What is the tree-width of a tree graph? (Answer: 1)

- Concept: Counting complexity classes (#P, #·NP)
  - Why needed here: Understanding why these problems have different complexities helps in designing appropriate algorithms and understanding their limitations.
  - Quick check question: What is the difference between #P and #·NP in terms of their definitions? (Answer: #P counts accepting paths of NP machines, #·NP counts solutions where a NP predicate must be satisfied)

- Concept: Abstract argumentation frameworks and semantics
  - Why needed here: The algorithm operates on probabilistic AFs, so understanding the basic concepts (attacks, conflict-freeness, admissibility, etc.) is essential.
  - Quick check question: What is the difference between a conflict-free set and an admissible set in argumentation? (Answer: An admissible set is conflict-free and defends all its members)

## Architecture Onboarding

- Component map: Preprocessing module → Tree-decomposition generator → Dynamic programming algorithm (leaf, introduction, forget, join handlers) → Post-processing module
- Critical path: For P-Ext computation: preprocessing → tree-decomposition generation → dynamic programming traversal (post-order) → probability aggregation at root
- Design tradeoffs: Using rational numbers (TD-Ext-r) ensures precision but is slower than floating-point (TD-Ext-f), which may accumulate rounding errors. The choice depends on whether exactness or speed is prioritized.
- Failure signatures: Timeouts occur when tree-width is too high (experimentally around 5-6). Memory issues arise from too many rows in tables. Incorrect results from TD-Ext-f may indicate floating-point precision problems.
- First 3 experiments:
  1. Run on a small PAF (3-4 arguments) with known answer to verify correctness of all components.
  2. Test preprocessing effectiveness by comparing problem sizes before and after on various PAFs.
  3. Benchmark TD-Ext-f vs TD-Ext-r on instances where both complete within timeout to measure precision vs. speed tradeoff.

## Open Questions the Paper Calls Out

### Open Question 1
- Question: Can the dynamic programming algorithm be extended to compute argument acceptability in probabilistic argumentation frameworks under the constellation approach?
- Basis in paper: [explicit] The paper discusses the potential extension of the algorithm to acceptability but notes it requires more work to avoid over-counting.
- Why unresolved: The current algorithm is designed for computing the probability of a set being a complete extension, and extending it to argument acceptability involves avoiding over-counting of subframeworks.
- What evidence would resolve it: A detailed algorithmic approach that successfully computes argument acceptability without over-counting, validated through experimental results.

### Open Question 2
- Question: How can preprocessing techniques be optimized to improve the performance of tree-decomposition-based algorithms in probabilistic argumentation?
- Basis in paper: [inferred] The paper mentions the potential benefit of preprocessing for dynamic programming algorithms but does not provide specific techniques.
- Why unresolved: While preprocessing is acknowledged as beneficial, the paper does not explore specific methods to optimize it for probabilistic argumentation.
- What evidence would resolve it: Development and experimental validation of preprocessing techniques that reduce the number of rows in tables and improve algorithm performance.

### Open Question 3
- Question: What are the implications of introducing dependencies between arguments in probabilistic argumentation frameworks, and how can these be efficiently represented and computed?
- Basis in paper: [explicit] The paper discusses extending the algorithm to incorporate dependencies between arguments using marginal probabilities.
- Why unresolved: The paper outlines a method for representing dependencies but does not fully explore the computational implications or efficiency of this approach.
- What evidence would resolve it: A comprehensive study showing how dependencies affect computational complexity and efficiency, along with practical examples and results.

## Limitations

- The algorithm's performance critically depends on the tree-width of the attack graph, with practical limits around tree-width 5-6
- Preprocessing effectiveness relies on having many certain arguments and attacks, which may not be present in PAFs with predominantly uncertain components
- The claimed complexity separation between P-Ext and P-Accept is theoretically sound but not empirically validated

## Confidence

**High confidence**: The dynamic programming framework based on tree-decompositions is sound and represents a valid approach to the problem. The preprocessing rules for identifying deterministically labeled arguments are correctly specified.

**Medium confidence**: The experimental results demonstrating scalability for tree-width ≤ 5 are promising but based on a limited set of instances. The runtime comparisons between TD-Ext-f and TD-Ext-r show expected trends but lack statistical significance testing.

**Low confidence**: The claimed complexity separation between P-Ext and P-Accept is theoretically sound but not empirically validated. The practical impact of this complexity difference on real-world problems remains unclear.

## Next Checks

1. **Scalability testing**: Evaluate the algorithm on PAFs with tree-width > 5 to determine the practical limits of the approach and identify when exponential blow-up occurs.

2. **Complexity separation validation**: Construct pairs of PAFs that differ only in whether the task is P-Ext or P-Accept, then measure the actual runtime difference to empirically verify the theoretical complexity separation.

3. **Alternative probability distributions**: Test the algorithm with non-independent probability distributions (where argument/attack probabilities are correlated) to determine if the preprocessing rules and dynamic programming approach still apply or need modification.