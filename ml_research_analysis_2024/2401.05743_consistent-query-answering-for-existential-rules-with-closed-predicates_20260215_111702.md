---
ver: rpa2
title: Consistent Query Answering for Existential Rules with Closed Predicates
arxiv_id: '2401.05743'
source_url: https://arxiv.org/abs/2401.05743
tags:
- dependencies
- repair
- every
- database
- full
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: 'This paper studies consistent query answering in databases with
  existential rules under a closed-world assumption, focusing on the class of disjunctive
  embedded dependencies with inequalities (DEDs) and their subclasses (acyclic, linear,
  full, guarded, sticky). The authors analyze the data complexity of two central problems:
  repair checking and Boolean UCQ entailment under both AR and IAR semantics.'
---

# Consistent Query Answering for Existential Rules with Closed Predicates

## Quick Facts
- arXiv ID: 2401.05743
- Source URL: https://arxiv.org/abs/2401.05743
- Authors: Lorenzo Marconi; Riccardo Rosati
- Reference count: 27
- Primary result: First-order rewritable repair checking and IAR-entailment for acyclic, linear, full, guarded, and sticky dependencies under closed-world assumption

## Executive Summary
This paper presents a comprehensive analysis of consistent query answering (CQA) in databases with existential rules under a closed-world assumption. The authors study disjunctive embedded dependencies with inequalities (DEDs) and their subclasses, focusing on data complexity of repair checking and Boolean UCQ entailment under both AR and IAR semantics. They establish that while these problems are generally computationally hard, many tractable cases exist, particularly for full and acyclic+full dependencies where the problems become first-order rewritable and solvable in AC0.

## Method Summary
The paper analyzes the data complexity of CQA problems through theoretical complexity analysis with proof techniques. The approach involves defining formal repair semantics under closed-world assumption with tuple-deletion only, then establishing complexity results through reductions and first-order rewriting techniques. For tractable cases, the authors provide detailed rewriting procedures that enable AC0 evaluation, while for harder cases they establish matching lower bounds through reductions from known hard problems like 3-CNF SAT and HORN SAT.

## Key Results
- Repair checking is in AC0 for acyclic, linear, full, guarded, and sticky dependencies under closed-world assumption
- IAR-entailment of Boolean UCQs is in AC0 for all studied dependency classes
- AR-entailment is coNP-hard for general DEDs and acyclic dependencies, but remains in AC0 for full and acyclic+full dependencies
- First-order rewritability enables practical implementation of CQA for multiple tractable cases

## Why This Works (Mechanism)

### Mechanism 1
- Claim: Disjunctive embedded dependencies with inequalities (DEDs) enable more expressive repair semantics by allowing disjunctive heads in existential rules.
- Mechanism: DEDs extend tuple-generating dependencies (TGDs) and equality-generating dependencies (EGDs) by permitting disjunction in rule heads. This allows modeling more complex data dependencies and inconsistency scenarios, enabling richer repair definitions.
- Core assumption: The disjunctive nature of heads captures scenarios where multiple repair paths are valid, and these can be handled computationally.
- Evidence anchors:
  - [abstract]: "the broad class of disjunctive embedded dependencies with inequalities (DEDs), which extend both tuple-generating dependencies and equality-generated dependencies"
  - [section]: "Disjunctive embedded dependencies with inequalities (or simply dependency) for S is an FO sentence... where Q is a UCQ"
- Break condition: If disjunctive heads lead to exponential blowup in repair space without tractable handling, the complexity benefits disappear.

### Mechanism 2
- Claim: Tuple-deletion semantics under closed-world assumption enables first-order rewritable repair checking for certain classes of dependencies.
- Mechanism: By assuming closed predicates and restricting repairs to tuple deletions only, the repair space becomes bounded by the original database size. For acyclic, linear, full, guarded, and sticky dependencies, this enables reduction to first-order sentences that can be evaluated in AC0.
- Core assumption: The closed-world assumption and tuple-deletion semantics create a finite, well-structured repair space that can be captured by first-order logic.
- Evidence anchors:
  - [abstract]: "we provide a detailed analysis of the data complexity of CQA and associated tasks (repair checking) under different semantics (AR and IAR) and for different classes of existential rules"
  - [section]: "Repair checking is in AC0 w.r.t. data complexity in the case of acyclic dependencies"
- Break condition: If dependencies create repair dependencies that cannot be captured in first-order logic, the rewritability claim fails.

### Mechanism 3
- Claim: Different semantics (AR vs IAR) provide different computational complexity trade-offs for query entailment.
- Mechanism: AR-entailment requires answers to be true in all repairs (skeptical semantics), while IAR-entailment requires answers to be true in the intersection of all repairs (sound approximation). This difference leads to different complexity classes for various dependency classes.
- Core assumption: The semantic distinction between "all repairs" vs "intersection of repairs" creates meaningful complexity differences that can be exploited algorithmically.
- Evidence anchors:
  - [abstract]: "We study the complexity of the above problems, providing a comprehensive analysis of the data complexity (that is, the complexity with respect to the size of the database) of repair checking and both AR-entailment and IAR-entailment of BUCQs"
  - [section]: "AR-entailment is coNP-hard, and therefore computationally harder than IAR-entailment of BUCQs (which is in AC0 in both cases)"
- Break condition: If the semantic distinction doesn't create meaningful computational differences, the complexity analysis becomes irrelevant.

## Foundational Learning

- Concept: Data complexity vs combined complexity
  - Why needed here: The paper focuses exclusively on data complexity (complexity with respect to database size while keeping query and dependency size fixed), which is crucial for understanding practical scalability.
  - Quick check question: What's the difference between data complexity and combined complexity, and why does this paper focus on data complexity?

- Concept: Existential rules and their subclasses
  - Why needed here: Understanding the different classes of existential rules (acyclic, linear, full, guarded, sticky) is essential for grasping why certain classes admit first-order rewritability while others don't.
  - Quick check question: What distinguishes acyclic, linear, full, guarded, and sticky existential rules from each other?

- Concept: Repair semantics (AR vs IAR)
  - Why needed here: The two semantics represent different approaches to handling multiple repairs - AR is skeptical (requires truth in all repairs) while IAR is based on the intersection of repairs. This distinction drives the complexity analysis.
  - Quick check question: How do AR-entailment and IAR-entailment differ, and what are the implications for query answering?

## Architecture Onboarding

- Component map: Database -> Dependency parser -> Repair checker -> Query entailment engine -> Result
- Critical path: Database → Dependency parser → Repair checker → Query entailment engine → Result
- Design tradeoffs:
  - Expressiveness vs tractability: More expressive dependency classes (general DEDs) lead to higher complexity
  - Closed vs open world: Closed-world assumption enables tuple-deletion only, simplifying repairs
  - AR vs IAR semantics: AR is more skeptical but computationally harder; IAR is sound but potentially incomplete
- Failure signatures:
  - Exponential blowup in repair space indicates need for constraint propagation
  - Incorrect repair detection suggests issues with dependency parsing or chase computation
  - Query entailment errors may indicate problems with the semantic distinction between AR and IAR
- First 3 experiments:
  1. Implement repair checking for acyclic dependencies and verify AC0 complexity
  2. Test query entailment under IAR semantics for linear dependencies
  3. Compare AR vs IAR entailment complexity for full dependencies

## Open Questions the Paper Calls Out

### Open Question 1
- Question: How does the combination of open-world and closed-world assumptions affect the complexity of consistent query answering for existential rules?
- Basis in paper: [explicit] The paper mentions this as an interesting future research direction, noting that combining OWA and CWA is usually very challenging from a computational viewpoint.
- Why unresolved: The paper only studies a "purely closed" approach where all predicates have a closed interpretation, and does not explore hybrid approaches that partition predicates into open and closed classes.
- What evidence would resolve it: Complexity results for consistent query answering under hybrid OWA/CWA semantics for various classes of existential rules, showing how the partition between open and closed predicates affects tractability and computational complexity.

### Open Question 2
- Question: What are the practical implications of the first-order rewritability results for consistent query answering in real-world knowledge bases?
- Basis in paper: [explicit] The paper identifies several classes of existential rules where consistent query answering problems are in AC0 and FO-rewritable, suggesting these results could be a starting point for developing practical algorithms.
- Why unresolved: While the theoretical results are established, the paper does not explore how these rewritings would perform in practice or what optimizations might be necessary for large-scale knowledge bases.
- What evidence would resolve it: Implementation and empirical evaluation of query answering algorithms based on the FO rewriting techniques presented, showing their performance on real-world knowledge bases and comparing them to existing methods.

### Open Question 3
- Question: How do the complexity results for consistent query answering relate to the problem of controlled query evaluation under privacy constraints?
- Basis in paper: [explicit] The paper mentions connections between consistent query answering and controlled query evaluation, noting interest in investigating the consequences of their results for such problems.
- Why unresolved: The paper does not explore these connections in detail or provide specific complexity results for controlled query evaluation in the presence of existential rules and inconsistencies.
- What evidence would resolve it: Complexity analysis of controlled query evaluation problems under various privacy policies and inconsistency scenarios, showing how the results for consistent query answering translate to this related problem and identifying any new tractable cases or computational challenges.

## Limitations

- Theoretical focus: The paper establishes complexity bounds but does not provide empirical validation of the proposed algorithms
- Reduction details: Some complexity lower bound proofs are stated but not fully detailed in the provided text
- Closed-world restriction: Results are limited to closed-world assumption, excluding scenarios with open predicates

## Confidence

- High confidence: The AC0 upper bounds for repair checking in acyclic, linear, full, guarded, and sticky dependencies
- Medium confidence: The coNP-hardness results for AR-entailment in general DEDs and acyclic dependencies
- Low confidence: The practical performance of the proposed FO rewritings without empirical validation

## Next Checks

1. Implement and test the chase computation for full dependencies to verify correctness of repair checking
2. Benchmark the AC0 rewriting procedures on databases with varying sizes to assess practical scalability
3. Validate the semantic distinction between AR and IAR entailment by implementing both and comparing their behavior on concrete examples