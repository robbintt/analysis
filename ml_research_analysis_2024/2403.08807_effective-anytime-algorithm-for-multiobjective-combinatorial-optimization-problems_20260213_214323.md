---
ver: rpa2
title: Effective anytime algorithm for multiobjective combinatorial optimization problems
arxiv_id: '2403.08807'
source_url: https://arxiv.org/abs/2403.08807
tags:
- algorithm
- time
- solutions
- algorithms
- non-dominated
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: "This paper proposes an effective anytime algorithm for multiobjective\
  \ combinatorial optimization (MOCO) problems that produces a well-spread set of\
  \ non-dominated solutions at any point during execution. The algorithm, called TPA,\
  \ is based on the D\xE4chert-Klamroth framework but introduces three novel contributions:\
  \ a strategy to select search space regions that ensures good dispersion of solutions,\
  \ a new way of partitioning the search space after finding a new non-dominated point,\
  \ and a new quality function to measure priority for new regions to explore."
---

# Effective anytime algorithm for multiobjective combinatorial optimization problems

## Quick Facts
- arXiv ID: 2403.08807
- Source URL: https://arxiv.org/abs/2403.08807
- Reference count: 39
- Proposed TPA algorithm outperforms state-of-the-art methods in hypervolume and solution count on 480 benchmark instances

## Executive Summary
This paper introduces TPA, an effective anytime algorithm for multiobjective combinatorial optimization (MOCO) problems that produces well-spread non-dominated solutions throughout execution. The algorithm improves upon the Dächert-Klamroth framework through three key innovations: an alternating direction selection strategy for balanced exploration, a p-partition method that reduces redundancy when splitting search space, and a reduced scaled priority function that more accurately estimates viable search regions. Extensive experiments on 480 instances demonstrate TPA's superior performance across multiple metrics including hypervolume, solution count, and spread measures.

## Method Summary
TPA is an anytime algorithm that iteratively explores a partitioned search space to find non-dominated solutions in MOCO problems. The method maintains p priority queues (one per objective direction) containing boxes representing unexplored regions. In each iteration, boxes are selected using an alternating direction strategy, then an ILP solver finds optimal solutions within those boxes. When new non-dominated points are discovered, the search space is partitioned using p-partition and priorities are updated using a reduced scaled function. Redundancy elimination filters out overlapping boxes. The process continues until time expires or no boxes remain, producing a diverse set of solutions at any point during execution.

## Key Results
- TPA significantly outperforms two state-of-the-art algorithms in hypervolume (HV) and number of non-dominated solutions found
- TPA achieves the best or tied-for-best performance in most cases across all four evaluation metrics
- Statistical tests confirm TPA's superior performance is significant (p < 0.05) across all metrics and problem classes
- The algorithm demonstrates strong anytime performance, maintaining good solution quality throughout execution

## Why This Works (Mechanism)

### Mechanism 1
- Claim: Alternating direction selection in the search space improves the spread of non-dominated solutions.
- Mechanism: By cycling through priority queues Li that contain boxes with direction i, the algorithm ensures that regions displaced along different dimensions are explored in a balanced manner. This avoids bias toward a single objective and improves diversity across the Pareto front.
- Core assumption: Different search directions contribute to better coverage of the objective space when alternated systematically.
- Evidence anchors:
  - [abstract] "A new strategy to select the appropriate search space region as the next box to explore, in order to guarantee that the new solutions found are spread over the objective space."
  - [section] "Boxes in different directions are displaced in the objective space along the different dimensions. We propose to select a box from a different priority queue Li in each iteration of TPA."
- Break condition: If the alternation cycle becomes too rigid or if one direction consistently yields empty or redundant boxes, the spread benefit may diminish.

### Mechanism 2
- Claim: p-partition reduces redundancy and improves partitioning of the search space after finding a new non-dominated point.
- Mechanism: Instead of full p-split, which creates overlapping boxes, p-partition generates a disjoint set of boxes. This avoids redundant exploration and focuses computational effort on unexplored regions.
- Core assumption: Non-overlapping partitions lead to more efficient search and less wasted computation.
- Evidence anchors:
  - [abstract] "A new way of partitioning the search space after finding a new non-dominated point."
  - [section] "The main difference between p-partition and full p-split is that the new boxes created by p-partition form a partition of the original box (they are pairwise disjoint)."
- Break condition: If the p-partition creates too many small boxes, the overhead of managing them may outweigh the redundancy reduction benefit.

### Mechanism 3
- Claim: The reduced scaled priority function better estimates the region size where non-dominated points can exist.
- Mechanism: By subtracting the scaled volume of the region dominated by a new non-dominated point, the priority function more accurately reflects the remaining viable search space.
- Core assumption: Overestimation of box priority leads to inefficient search; correcting this improves focus on promising regions.
- Evidence anchors:
  - [abstract] "A new quality function to measure the priority for the new regions to explore."
  - [section] "We define a new priority function to correct this overestimation."
- Break condition: If the scaling parameters (e.g., nadir and ideal points) are poorly estimated, the priority function may misrank boxes.

## Foundational Learning

- Concept: Pareto optimality and dominance
  - Why needed here: The algorithm generates and maintains a set of non-dominated points; understanding dominance is essential to verify correctness.
  - Quick check question: Given two solutions x and y with objective values (2,5) and (3,4), does x dominate y?

- Concept: Search space partitioning (box splitting)
  - Why needed here: The algorithm repeatedly splits boxes to explore new regions; understanding how boxes are defined and split is critical for implementation.
  - Quick check question: If a box has upper bound (10,15,20) and a new non-dominated point is (5,10,15), what are the upper bounds of the resulting p-partition boxes?

- Concept: Hypervolume and spread metrics
  - Why needed here: Performance is evaluated using HV, Δ*, and ε+; understanding these metrics is necessary to interpret results.
  - Quick check question: If a reference point is (1,1,1) and the non-dominated set is {(0.2,0.5,0.3), (0.4,0.1,0.6)}, is the hypervolume larger or smaller than if the set were {(0.2,0.5,0.3)}?

## Architecture Onboarding

- Component map:
  - Priority queues Li (p queues, one per direction) -> Box structure (lower/upper bounds, priority, direction) -> ILP solver (CPLEX) -> Redundancy elimination (RE) filter -> Join operation for merging redundant boxes

- Critical path:
  1. Initialize with box [zI, zN]
  2. Select next box via alternating direction strategy
  3. Solve ILP problem with weighted Tchebycheff norm
  4. If new non-dominated point found, update boxes using p-partition and priority function
  5. Filter redundant boxes via RE
  6. Repeat until time limit or no boxes remain

- Design tradeoffs:
  - Alternating directions vs. highest priority first: Alternating improves spread but may delay exploring high-priority regions.
  - p-partition vs. full p-split: p-partition reduces redundancy but may generate more boxes.
  - Reduced scaled priority vs. raw volume: More accurate but requires additional computation.

- Failure signatures:
  - Excessive number of small boxes -> memory exhaustion
  - CPLEX solver timeouts -> algorithm stalls
  - All boxes becoming redundant -> premature termination
  - Poor priority estimation -> suboptimal spread

- First 3 experiments:
  1. Run TPA on a small bi-objective knapsack instance with known Pareto front; verify that all non-dominated points are found and spread is good.
  2. Compare p-partition vs. full p-split on a fixed instance; measure number of boxes and redundancy reduction.
  3. Test alternating direction selection by running two versions (alternating vs. always highest priority) on the same instance; compare spread metrics.

## Open Questions the Paper Calls Out

### Open Question 1
- Question: What is the optimal strategy for selecting the initial box to explore in TPA to maximize anytime performance across different MOCO problem classes?
- Basis in paper: [explicit] The paper mentions selecting an initial box with upper bound of the nadir point but does not analyze different initialization strategies.
- Why unresolved: The paper only describes one initialization method and does not compare it with alternatives or analyze sensitivity to initial conditions.
- What evidence would resolve it: Comparative experiments testing different initialization strategies (random, heuristic-based, problem-specific) across diverse MOCO problem classes.

### Open Question 2
- Question: How does TPA's anytime performance scale with increasing dimensionality (number of objectives) beyond the tested range?
- Basis in paper: [inferred] The paper tests up to 4 objectives but discusses the algorithm being valid for any p ≥ 2. The scalability analysis is limited to tested instances.
- Why unresolved: The computational experiments are limited to problems with up to 4 objectives, leaving scalability beyond this range unexplored.
- What evidence would resolve it: Systematic experiments on high-dimensional MOCO problems (5+ objectives) measuring anytime metrics like ONVGR, HV, and computational time.

### Open Question 3
- Question: Can TPA's partitioning strategy be further optimized by incorporating problem-specific structure or domain knowledge?
- Basis in paper: [explicit] The paper introduces p-partition as a novel contribution but acknowledges it may generate redundant zones requiring filtering.
- Why unresolved: While p-partition improves over full p-split, the paper does not explore whether problem-specific adaptations could yield further improvements.
- What evidence would resolve it: Comparative experiments applying TPA with standard p-partition versus problem-specific partitioning strategies on various MOCO problem classes.

## Limitations

- Benchmark instances are not publicly available, making exact reproduction difficult
- Implementation details of priority queues and redundancy elimination may vary between implementations
- Performance claims rely on statistical tests but underlying data distribution and instance characteristics are not fully described

## Confidence

- High: Alternating direction selection improves solution spread
- High: p-partition reduces redundancy vs. full p-split
- Medium: Reduced scaled priority function consistently improves search efficiency

## Next Checks

1. Replicate p-partition vs. full p-split on a small MOCO instance to verify redundancy reduction claims.
2. Implement alternating direction selection and compare spread metrics against a highest-priority-first variant.
3. Validate priority function accuracy by testing on instances with known nadir/ideal points.