---
ver: rpa2
title: Loosely Synchronized Rule-Based Planning for Multi-Agent Path Finding with
  Asynchronous Actions
arxiv_id: '2412.11678'
source_url: https://arxiv.org/abs/2412.11678
tags:
- agent
- agents
- vertex
- lsrp
- line
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: This paper presents a new approach for solving Multi-Agent Path
  Finding with Asynchronous Actions (MAPF-AA), a variant of MAPF where agents can
  have different action durations and start times. The key challenge addressed is
  scalability - existing MAPF-AA algorithms struggle with many agents due to their
  focus on finding optimal solutions.
---

# Loosely Synchronized Rule-Based Planning for Multi-Agent Path Finding with Asynchronous Actions

## Quick Facts
- arXiv ID: 2412.11678
- Source URL: https://arxiv.org/abs/2412.11678
- Reference count: 32
- Handles up to 1000 agents compared to 100 agents for existing methods

## Executive Summary
This paper introduces Loosely Synchronized Rule-based Planning (LSRP), a new algorithm for Multi-Agent Path Finding with Asynchronous Actions (MAPF-AA). The key innovation is a caching mechanism that enables efficient planning for agents with different action durations and start times. LSRP combines priority inheritance from PIBT with the loosely synchronized search approach, allowing it to scale to problems with up to 1000 agents while maintaining conflict-free solutions.

## Method Summary
LSRP addresses the scalability challenge in MAPF-AA by introducing a cache-based planning mechanism that stores planned actions for multiple agents with close starting times. The algorithm builds on PIBT's priority inheritance system, where agents are assigned priorities that increase over time, allowing higher-priority agents to push others out of their way. When agents need to swap locations, LSRP-SWAP introduces a swap operation. The method trades solution optimality for scalability, using unbounded sub-optimal solutions while maintaining conflict-free paths through its loosely synchronized approach.

## Key Results
- LSRP can handle up to 1000 agents within a 30-second runtime limit, compared to 100 agents for existing methods
- Solutions have approximately 25% longer makespan than optimal solutions
- LSRP produces solutions with 55-90% of the makespan compared to approaches that ignore asynchronous actions
- The method successfully resolves conflicts through push operations and swap operations when needed

## Why This Works (Mechanism)

### Mechanism 1
- Claim: The cache-based planning of future actions allows asynchronous actions to be handled efficiently without full re-planning.
- Mechanism: When agents have actions with close starting times, LSRP caches planned future actions in a dictionary keyed by timestamps. This allows agents to reuse these cached actions instead of re-planning from scratch, reducing computational overhead while maintaining conflict-free paths.
- Core assumption: Cached actions remain valid when reused for agents with similar timestamps.
- Evidence anchors:
  - [abstract]: "LSRP introduces a caching mechanism to plan actions for multiple agents with close starting times, enabling it to handle asynchronous actions efficiently."
  - [section]: "During the search, Φ caches the planned actions of the agents, and is updated in Alg.3... This future individual state corresponding to the move action of agent i from vi to v between timestamps [ti wait, ti move] is generated and stored in Φ."
- Break condition: If action durations vary significantly between agents, cached actions may become invalid and require re-planning.

### Mechanism 2
- Claim: The priority inheritance mechanism ensures all agents eventually reach their goals in c-graphs.
- Mechanism: Agents are assigned priorities that increase over time. The highest priority agent can push other agents out of its way to reach its goal. Once an agent reaches its goal, its priority is reset, allowing another agent to become highest priority and proceed.
- Core assumption: The graph contains cycles of sufficient length (≥ N+1) for all adjacent vertex pairs.
- Evidence anchors:
  - [section]: "PIBT guarantees that the agent with the highest priority eventually reaches its goal, at which it becomes the lowest priority agent. Therefore, each agent becomes the highest priority agent at least once and is able to reach its goal at some time step."
  - [section]: "If there exists a cycle of length ≥ N + 1 for all pairs of adjacent vertices in G, then we call this graph a c-graph. Intuitively, for a c-graph, LSRP guarantees that the agent with highest priority can push away any other agents that block its way to its goal, and reaches its goal within finite time."
- Break condition: In graphs without sufficient cycles (non-c-graphs), agents may get stuck in push cycles and never reach goals.

### Mechanism 3
- Claim: The swap operation resolves deadlock situations where agents block each other's paths.
- Mechanism: When agents need to swap locations but cannot proceed through push operations alone, LSRP-SWAP introduces a swap operation where agents temporarily move away from their goals to exchange positions.
- Core assumption: Swap is only invoked when push operations are insufficient to resolve conflicts.
- Evidence anchors:
  - [section]: "Fig. 3 shows an example. Assume the yellow agent has higher initial priority than the blue agent. The yellow agent first pushes the blue agent until reaches goal D. Then, the blue agent has higher priority and pushes the yellow agent until reaches goal E. As a result, these two agents iteratively push each other and can never successfully swap their locations."
  - [section]: "Inspired by this, we develop ASY-PUSH-SWAP... ASY-PUSH-SWAP takes the same input as ASY-PUSH, and invokes a procedure SWAP-REQUIRED-POSSIBLE to check if there exists an agent j that needs to swap location with agent i."
- Break condition: If swap operation itself creates new conflicts or if the graph structure prevents effective swapping.

## Foundational Learning

- Concept: Multi-Agent Path Finding (MAPF) with duration conflicts
  - Why needed here: Understanding how LSRP differs from standard MAPF is crucial for grasping why asynchronous actions require specialized handling
  - Quick check question: How does duration conflict differ from vertex and edge conflicts in standard MAPF?

- Concept: Priority inheritance algorithms
  - Why needed here: LSRP builds directly on PIBT's priority inheritance mechanism, which is fundamental to understanding how agents are planned
  - Quick check question: In PIBT, what happens when a higher-priority agent wants to occupy a location currently held by a lower-priority agent?

- Concept: State-space search with timestamps
  - Why needed here: LSRP extends the LSS state definition to include both locations and action times, which is essential for handling asynchronous actions
  - Quick check question: How does including timestamps in state definitions enable handling of asynchronous actions?

## Architecture Onboarding

- Component map: Priority assignment -> Agent selection (Icurr) -> ASY-PUSH/SWAP planning -> Cache update -> State progression
- Critical path: The planning of agents in Icurr with their associated conflict resolution (push/swap) determines solution feasibility and runtime
- Design tradeoffs: Trading solution optimality for scalability by using unbounded sub-optimal solutions and caching mechanisms
- Failure signatures: Push cycles in non-c-graphs, excessive cache misses when action durations vary widely, swap operation failures in constrained graphs
- First 3 experiments:
  1. Test LSRP on a simple 3x3 grid with 2 agents having different action durations to verify basic functionality
  2. Test scalability by running LSRP on larger grids (up to 1000 agents) with uniform action durations
  3. Test swap operation by creating scenarios where agents must exchange positions to reach their goals

## Open Questions the Paper Calls Out

### Open Question 1
- Question: How does the caching mechanism in LSRP affect the optimality of solutions compared to other MAPF-AA approaches?
- Basis in paper: [explicit] The paper mentions a caching mechanism to plan actions for multiple agents with close starting times, enabling efficient handling of asynchronous actions.
- Why unresolved: The paper focuses on scalability and runtime efficiency but does not provide a detailed analysis of how the caching mechanism impacts solution optimality compared to other methods.
- What evidence would resolve it: Comparative studies measuring solution optimality (e.g., makespan, sum of costs) between LSRP and other MAPF-AA algorithms with and without caching.

### Open Question 2
- Question: What are the theoretical limits of LSRP's scalability in terms of the number of agents and graph size?
- Basis in paper: [inferred] The paper claims LSRP can handle up to 1000 agents but does not explore the theoretical bounds of scalability.
- Why unresolved: While experimental results show scalability, the paper does not provide a formal analysis of the theoretical limits or conditions under which LSRP's scalability might degrade.
- What evidence would resolve it: Theoretical analysis or empirical studies testing LSRP on graphs of varying sizes and agent counts to identify scalability thresholds.

### Open Question 3
- Question: How does the swap operation in LSRP-SWAP affect the completeness of the algorithm in non-c-graphs?
- Basis in paper: [explicit] The paper introduces LSRP-SWAP to handle cases where agents need to swap locations, but notes that Theorem 1 and 2 may not hold for LSRP-SWAP.
- Why unresolved: The paper acknowledges the potential incompleteness of LSRP-SWAP in non-c-graphs but does not provide a detailed analysis of its completeness or conditions for failure.
- What evidence would resolve it: Formal proofs or counterexamples demonstrating the completeness or incompleteness of LSRP-SWAP in various graph types.

## Limitations
- LSRP's completeness is only guaranteed for c-graphs (graphs with cycles of length ≥ N+1 for all adjacent vertex pairs)
- The algorithm trades solution optimality for scalability, with makespan typically 25% longer than optimal solutions
- No theoretical guarantees for convergence time or solution quality bounds

## Confidence
- **High Confidence**: LSRP's ability to handle an order of magnitude more agents than existing methods (1000 vs 100 agents) - supported by extensive experimental results across multiple benchmarks
- **Medium Confidence**: The claim that LSRP produces solutions 55-90% of the makespan compared to methods ignoring asynchronous actions - based on comparative experiments but dependent on specific problem instances
- **Medium Confidence**: The effectiveness of the caching mechanism for improving runtime efficiency - while intuitively sound, the exact performance gains depend on action duration distributions and cache hit rates

## Next Checks
1. Test LSRP on non-c-graphs with cycles shorter than N+1 to empirically validate the claimed limitation and identify failure patterns
2. Measure cache hit rates and their impact on runtime performance across different action duration distributions
3. Evaluate LSRP-SWAP on increasingly constrained graphs to determine the minimum space requirements for successful swap operations