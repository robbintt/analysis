---
ver: rpa2
title: 'On Policy Reuse: An Expressive Language for Representing and Executing General
  Policies that Call Other Policies'
arxiv_id: '2403.16824'
source_url: https://arxiv.org/abs/2403.16824
tags:
- state
- policies
- rules
- memory
- sketches
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: 'The paper extends a rule-based language for representing general
  policies and sketches by adding: (1) finite memory states for sequencing behaviors,
  (2) indexical features whose values depend on internal registers that can be loaded
  with objects, and (3) modules that wrap policies and sketches to enable them to
  call each other by passing parameters. This extended language allows policies and
  sketches to be more flexible and reusable, as illustrated through examples like
  building towers of blocks using reusable sub-policies.'
---

# On Policy Reuse: An Expressive Language for Representing and Executing General Policies that Call Other Policies

## Quick Facts
- **arXiv ID**: 2403.16824
- **Source URL**: https://arxiv.org/abs/2403.16824
- **Reference count**: 10
- **Key outcome**: Extends rule-based language for general policies with memory states, indexical features, and modules for reusable hierarchical policies

## Executive Summary
This paper introduces an extended language for representing general policies and sketches in planning domains. The extension adds three key features: finite memory states for sequencing behaviors like finite state controllers, indexical features that depend on internal registers for object referencing, and modules that wrap policies to enable calling each other with parameters. The language allows for more expressive and reusable policy representations, enabling hierarchical policies to be built from simpler components. The execution model uses a stack-based approach to handle nested module calls and subproblem solving via IW search.

## Method Summary
The method involves extending an existing rule-based language for general policies by adding memory states (finite state controllers), indexical features (register-dependent), and modules (callable wrappers). The execution uses a stack-based interpreter (SIWM) that handles nested module calls, ground action execution, and subproblem solving via IW search. While the paper defines the representation and execution mechanisms, it does not address learning algorithms for acquiring these policies.

## Key Results
- Memory states enable conditional execution paths and loops by restricting which rules can apply at any time
- Indexical features reduce feature complexity by allowing direct object referencing through registers
- Modules enable policy reuse through parameter passing and recursive calls
- Extended language supports bottom-up learning of hierarchical policies from simpler components

## Why This Works (Mechanism)

### Mechanism 1
- **Claim**: Internal memory states enable sequencing of behaviors in hierarchical policies by allowing policies to switch between different rule sets.
- **Mechanism**: Memory states act as finite state controllers that select which subset of rules is applicable at any given time. When a policy reaches a memory state, only rules associated with that state can fire, enabling conditional execution paths and loops.
- **Core assumption**: The policy can deterministically transition between memory states based on feature conditions without getting stuck in cycles.
- **Evidence anchors**:
  - [abstract] "internal memory states, as in finite state controllers"
  - [section] "When the current memory state is m, only rules of the form (m, C) → (E, m′) apply"
  - [corpus] Weak evidence - corpus focuses on policy gradient and neural representations rather than finite state controllers
- **Break condition**: If the policy becomes irreducible (no applicable rule) or cycles indefinitely between memory states, execution fails.

### Mechanism 2
- **Claim**: Indexical features reduce feature complexity by allowing policies to refer to objects through registers rather than computing complex predicates.
- **Mechanism**: Registers store references to specific objects, and indexical features compute their values based on the object in the register. This allows policies to mark important objects and refer to them directly, avoiding the need for complex relational features.
- **Core assumption**: The set of objects that can be loaded into registers is sufficient to express the necessary policy behavior for the given domain.
- **Evidence anchors**:
  - [abstract] "indexical features, whose values are a function of the state and a number of internal registers that can be loaded with objects"
  - [section] "an object can be regarded as marked with 'mark' r when the object is loaded into register r"
  - [corpus] Weak evidence - corpus discusses general policies but not register-based indexing mechanisms
- **Break condition**: If the policy requires tracking more objects than available registers, or if the same object needs to be in multiple registers simultaneously, the mechanism breaks down.

### Mechanism 3
- **Claim**: Modules enable policy reuse by wrapping policies and sketches into callable units that can be invoked with parameters.
- **Mechanism**: Modules define interfaces with arguments, and call rules specify when to invoke other modules. The execution model uses a stack to handle nested calls, maintaining context and register values across invocations.
- **Core assumption**: The caller module can provide appropriate parameter values based on its current state and the callee module's requirements.
- **Evidence anchors**:
  - [abstract] "modules that wrap policies and sketches and allow them to call each other by passing parameters"
  - [section] "If a call rule (m, C) → (modj(x1, x2, ..., xn), m′) is chosen...the sketch associated with the module name is executed"
  - [corpus] Weak evidence - corpus focuses on neural and gradient-based approaches rather than explicit module systems
- **Break condition**: If the call hierarchy becomes too deep, the stack may overflow, or if parameter passing cannot capture the necessary information, the reuse mechanism fails.

## Foundational Learning

- **Concept**: Finite state controllers
  - **Why needed here**: Memory states in the extended language function as finite state controllers that sequence behaviors
  - **Quick check question**: How do memory states restrict which rules can apply at any given time?

- **Concept**: Parametric representations
  - **Why needed here**: Indexical features depend on register values, making policies parametric over objects in the domain
  - **Quick check question**: What is the difference between a plain feature and an indexical feature in this context?

- **Concept**: Recursive function calls
  - **Why needed here**: The module system allows policies to call each other recursively, similar to function calls in programming
  - **Quick check question**: How does the execution model handle nested module calls and maintain context?

## Architecture Onboarding

- **Component map**: Features (Boolean, numerical, concepts, roles, indexical features) -> Memory states (finite set of controller states) -> Registers (storage for object references) -> Rules (conditions and effects including load, call, do rules) -> Modules (named wrappers with interfaces and rule sets) -> Execution engine (stack-based interpreter SIW M)

- **Critical path**: Parse module definition → Initialize registers and memory → Execute rules until termination or failure → Handle calls and do actions → Return result

- **Design tradeoffs**:
  - Expressiveness vs. termination: More powerful features make termination checking harder
  - Register count vs. policy complexity: More registers enable more complex policies but increase learning difficulty
  - Call depth vs. resource usage: Deep call hierarchies use more stack space

- **Failure signatures**:
  - Irreducible policies: No applicable rule in current state
  - Non-terminating policies: Infinite loops between memory states
  - Call failures: No matching ground action for do rule or missing module

- **First 3 experiments**:
  1. Implement a simple tower-building policy with memory states and verify it can sequence actions correctly
  2. Add indexical features with registers to the tower policy and demonstrate reduced feature complexity
  3. Create a module that calls the tower policy and verify parameter passing and call stack behavior

## Open Questions the Paper Calls Out

### Open Question 1
- **Question**: Can the extended language for policies and sketches be efficiently learned bottom-up from simpler policies, as suggested for building complex towers of blocks?
- **Basis in paper**: [explicit] The paper suggests learning hierarchical policies bottom-up by generating and reusing policies, instead of the more common approach of learning them top-down.
- **Why unresolved**: The paper does not address the learning problem, focusing instead on the representation problem. The learning methods for the extended language have not been developed or tested.
- **What evidence would resolve it**: Demonstrating a successful bottom-up learning algorithm for the extended language on a range of planning problems, showing improved efficiency or performance compared to top-down approaches.

### Open Question 2
- **Question**: What are the theoretical properties of the modular framework, such as acyclicity and termination, when policies and sketches can call each other recursively?
- **Basis in paper**: [explicit] The paper mentions that the study of theoretical properties of the modular framework, like acyclicity and termination, is important and left for future work.
- **Why unresolved**: The paper introduces the modular framework but does not provide a theoretical analysis of its properties, particularly in the presence of recursive calls.
- **What evidence would resolve it**: Proving theorems or providing counterexamples that establish the conditions under which the modular framework is acyclic and terminating, even with recursive calls.

### Open Question 3
- **Question**: How does the use of indexical features and registers in the extended language impact the complexity of learning and executing general policies and sketches?
- **Basis in paper**: [explicit] The paper states that indexical features whose values depend on registers can drastically reduce the complexity of the features needed, in line with the intuition of deictic representations.
- **Why unresolved**: While the paper illustrates the expressive power of indexical features, it does not quantify their impact on the complexity of learning and execution. The trade-offs between expressiveness and complexity are not fully explored.
- **What evidence would resolve it**: Empirical studies comparing the performance of policies and sketches using indexical features versus those using traditional features, in terms of learning time, execution time, and solution quality.

## Limitations

- The paper focuses exclusively on representational aspects without addressing learning algorithms or empirical validation
- The execution model assumes a stack-based interpreter but lacks formal proofs of termination or complexity bounds
- The claim about indexical features reducing feature complexity lacks quantitative analysis comparing feature set sizes
- The interaction between memory states and register values during policy execution is not fully formalized

## Confidence

- **High Confidence**: The basic mechanism of using memory states as finite state controllers to sequence behaviors is well-established and clearly defined
- **Medium Confidence**: The module system for enabling policy reuse through parameter passing is conceptually sound but lacks formal semantics for all edge cases
- **Medium Confidence**: The claim about indexical features reducing feature complexity is plausible based on the examples but lacks rigorous empirical validation

## Next Checks

1. **Termination Analysis**: Conduct a formal analysis of termination conditions for policies using memory states, registers, and recursive module calls. Develop a static analysis tool to detect potential non-terminating policies before execution.

2. **Feature Complexity Benchmark**: Implement a benchmark comparing the number and complexity of features required for policies with and without indexical features across multiple planning domains. Quantify the reduction in feature engineering effort.

3. **Stack Overflow Vulnerability**: Design stress tests that push the module call hierarchy to extreme depths to identify stack overflow vulnerabilities and develop mitigation strategies such as tail call optimization or iterative execution models.