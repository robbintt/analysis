---
ver: rpa2
title: 'Routing and Scheduling in Answer Set Programming applied to Multi-Agent Path
  Finding: Preliminary Report'
arxiv_id: '2403.12153'
source_url: https://arxiv.org/abs/2403.12153
tags:
- move
- mapf
- vertex
- time
- event
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: This paper presents alternative approaches to routing and scheduling
  in Answer Set Programming (ASP), focusing on Multi-Agent Path Finding (MAPF). The
  core idea is to capture the flow of time using partial orders instead of time steps,
  eliminating the need for fixed upper bounds on plan lengths.
---

# Routing and Scheduling in Answer Set Programming applied to Multi-Agent Path Finding: Preliminary Report

## Quick Facts
- arXiv ID: 2403.12153
- Source URL: https://arxiv.org/abs/2403.12153
- Authors: Roland Kaminski; Torsten Schaub; Tran Cao Son; Jiří Švancara; Philipp Wanko
- Reference count: 2
- Primary result: Partial-order-based ASP encodings for MAPF show promise, especially for longer path-based plans, but experimental validation is limited

## Executive Summary
This paper presents alternative approaches to routing and scheduling in Answer Set Programming (ASP), focusing on Multi-Agent Path Finding (MAPF). The core idea is to capture the flow of time using partial orders instead of time steps, eliminating the need for fixed upper bounds on plan lengths. This approach trades the ability to distinguish multiple occurrences of the same action or fluent for more efficient handling of routing and scheduling problems.

The authors develop new ASP encodings for MAPF that leverage acyclicity and difference constraints to efficiently handle partial orders. These encodings are compared to traditional time-step-based approaches through empirical analysis on various benchmark classes of MAPF scenarios. The results show that the partial-order-based encodings perform well, especially for path-based plans with longer lengths, while traditional approaches struggle with fine-grained scheduling due to the linear increase in problem size with each time step.

## Method Summary
The paper introduces a novel approach to encoding MAPF problems in ASP by using partial orders to represent time instead of discrete time steps. This method eliminates the need for a priori bounds on plan lengths, a significant limitation of traditional time-step-based encodings. The authors leverage acyclicity and difference constraints to efficiently capture these partial orders in ASP. They develop specific encodings that take advantage of these properties to handle the routing and scheduling aspects of MAPF more effectively. The approach trades the ability to distinguish multiple occurrences of the same action or fluent for improved scalability and efficiency in handling larger, more complex MAPF instances.

## Key Results
- Partial-order-based ASP encodings for MAPF eliminate the need for fixed upper bounds on plan lengths
- The encodings perform well, especially for path-based plans with longer lengths
- Traditional time-step-based approaches struggle with fine-grained scheduling due to linear problem size increase

## Why This Works (Mechanism)
The partial-order approach works by representing the temporal flow of actions and fluents as a directed acyclic graph (DAG) rather than a linear sequence of time steps. This allows for more flexible and efficient encoding of temporal relationships, as it doesn't require predefining a maximum plan length. The use of difference constraints further optimizes the encoding by allowing efficient propagation of temporal information through the partial order. This mechanism trades the expressiveness of distinguishing multiple occurrences of the same action or fluent for significant gains in scalability and efficiency, particularly beneficial for MAPF scenarios with longer paths or more complex scheduling requirements.

## Foundational Learning
- **Partial Orders**: Needed to represent temporal flow without fixed time steps. Quick check: Can you explain how partial orders differ from linear time sequences in planning problems?
- **Difference Constraints**: Used to efficiently propagate temporal information in partial-order encodings. Quick check: How do difference constraints work in ASP, and why are they useful for partial-order representations?
- **Acyclicity**: Ensures the temporal flow represented by partial orders doesn't contain cycles. Quick check: Why is acyclicity crucial for valid temporal representations in planning?
- **MAPF Problem Structure**: Understanding the basics of Multi-Agent Path Finding is essential. Quick check: Can you describe the core challenge in MAPF and why it's computationally complex?
- **ASP Encoding Techniques**: Familiarity with Answer Set Programming concepts is necessary. Quick check: How does ASP differ from other logic programming paradigms, and why is it suitable for planning problems?

## Architecture Onboarding

Component Map:
MAPF Problem -> Partial-Order Representation -> ASP Encoding with Difference Constraints -> Solution Extraction

Critical Path:
Problem formulation -> Partial-order temporal representation -> ASP encoding generation -> Solver execution -> Solution validation and extraction

Design Tradeoffs:
- Expressiveness vs. Efficiency: Partial orders lose action/fluent multiplicity but gain scalability
- Predefined bounds vs. Flexibility: Eliminates need for maximum plan length but may require more complex reasoning
- Linear vs. DAG-based temporal representation: Offers more efficient encoding at the cost of some expressiveness

Failure Signatures:
- Cycles in partial-order representation indicate invalid temporal constraints
- Inconsistent difference constraints suggest unsatisfiable temporal relationships
- Inability to find solutions may indicate overly restrictive constraints or solver limitations

First Experiments:
1. Encode a simple MAPF instance using both traditional time-step and partial-order approaches
2. Test the partial-order encoding on a larger MAPF scenario to observe scalability benefits
3. Introduce temporal constraints to a MAPF problem and verify correct handling by the partial-order encoding

## Open Questions the Paper Calls Out
None

## Limitations
- Experimental validation appears limited in scope, focusing on specific benchmark classes
- The trade-off between losing action/fluent multiplicity and gaining efficiency is not fully characterized
- The claim about eliminating fixed upper bounds requires further empirical validation on larger, more complex instances

## Confidence
- High confidence in the theoretical foundation of partial-order representation in ASP
- Medium confidence in the proposed encodings' correctness and completeness
- Low confidence in the empirical performance claims due to limited experimental scope

## Next Checks
1. Conduct comprehensive benchmarking across diverse MAPF scenarios including varying agent counts, grid sizes, and obstacle densities to validate performance claims
2. Test the encodings on MAPF variants requiring action/fluent multiplicity to assess the practical limitations of the partial-order approach
3. Compare scalability with state-of-the-art MAPF solvers beyond traditional time-step-based ASP approaches, including optimal and suboptimal methods