---
ver: rpa2
title: Optimal and Bounded Suboptimal Any-Angle Multi-agent Pathfinding
arxiv_id: '2404.16379'
source_url: https://arxiv.org/abs/2404.16379
tags:
- aa-ccbs
- ccbs
- optimal
- search
- any-angle
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: This paper introduces AA-CCBS, the first optimal algorithm for
  any-angle multi-agent pathfinding (AA-MAPF), where agents can move between any two
  locations as long as their straight-line paths avoid obstacles. The algorithm combines
  Continuous Conflict-based Search (CCBS) with an optimal any-angle variant of Safe
  Interval Path Planning (TO-AA-SIPP).
---

# Optimal and Bounded Suboptimal Any-Angle Multi-agent Pathfinding

## Quick Facts
- **arXiv ID**: 2404.16379
- **Source URL**: https://arxiv.org/abs/2404.16379
- **Reference count**: 40
- **Primary result**: Introduces AA-CCBS, the first optimal any-angle MAPF algorithm, achieving 30% more solved instances than vanilla CCBS with DS+MC3, and 123% more instances with bounded-suboptimal variants.

## Executive Summary
This paper presents AA-CCBS, the first optimal algorithm for any-angle multi-agent pathfinding (AA-MAPF), where agents can move between any two locations as long as their straight-line paths avoid obstacles. The algorithm combines Continuous Conflict-based Search (CCBS) with an optimal any-angle variant of Safe Interval Path Planning (TO-AA-SIPP). To address scalability challenges caused by the large branching factor of any-angle pathfinding, the authors adapt Disjoint Splitting (DS) and Multi-Constraints (MC) to the any-angle setting. Experimental results show that these enhancements significantly improve performance: DS and DS+MC3 solve over 30% more problems than the vanilla combination under a 5-minute time limit. The paper also introduces a bounded-suboptimal variant of AA-CCBS, enabling controlled trade-offs between runtime and solution quality.

## Method Summary
AA-CCBS is an optimal planner based on Continuous Conflict-based Search (CCBS) and TO-AA-SIPP, enhanced with Disjoint Splitting (DS) and three variants of Multi-Constraints (MC1, MC2, MC3). The algorithm uses a high-level search over constraint trees to detect and resolve conflicts between agent paths, while the low-level planner (TO-AA-SIPP) finds optimal any-angle paths that respect these constraints. Bounded-suboptimal variants use Focal Search with a suboptimality factor w to trade solution quality for faster runtime.

## Key Results
- AA-CCBS with DS+MC3 solves over 30% more problems than vanilla AA-CCBS under a 5-minute time limit.
- Bounded-suboptimal variants with w=1.25 solve 123% more instances than the optimal variant.
- MC3 requires fewer high-level iterations than DS and DS+MC3 in nearly half of the instances, but DS variants outperform MC3 on harder instances with longer time limits.

## Why This Works (Mechanism)

### Mechanism 1
- Claim: AA-CCBS solves MAPF problems optimally when agents can move along any straight-line path that avoids obstacles.
- Mechanism: Combines Continuous Conflict-based Search (CCBS) with an optimal any-angle variant of the Safe Interval Path Planning (TO-AA-SIPP), allowing agents to move between any pair of vertices connected by a collision-free line segment.
- Core assumption: The environment can be represented as a set of vertices in a metric space, and collision detection can be performed accurately for disk-shaped agents.
- Evidence anchors:
  - [abstract] "Our planner is based on the Continuous Conflict-based Search (CCBS) algorithm and an optimal any-angle variant of the Safe Interval Path Planning (TO-AA-SIPP)."
  - [section III] Defines the any-angle MAPF problem and the move action constraints.
- Break condition: If the line-of-sight function is inaccurate or computationally expensive, the algorithm may fail to find valid paths or scale poorly.

### Mechanism 2
- Claim: Multi-Constraints (MC) reduce the number of high-level iterations in AA-CCBS by resolving conflicts more aggressively.
- Mechanism: When two actions conflict, MC creates a set of constraints that prohibit multiple conflicting actions simultaneously, rather than just one. Variants MC1, MC2, and MC3 differ in how they select actions to include in the constraint set.
- Core assumption: Including more conflicting actions in a multi-constraint leads to stronger pruning of the search tree without losing optimality.
- Evidence anchors:
  - [section V-A] Describes the three MC variants and their construction.
  - [section VI] Experimental results show MC3, DS, and DS+MC3 solve significantly more problems than vanilla AA-CCBS.
- Break condition: If the unsafe intervals of actions in a multi-constraint overlap significantly, the resulting constraint may be too weak to prune effectively.

### Mechanism 3
- Claim: Disjoint Splitting (DS) improves scalability by forcing one agent to commit to a landmark action, reducing branching in the high-level search.
- Mechanism: For each conflict, DS creates two child nodes: one with a negative constraint on one agent, and another with a positive constraint (landmark) on one agent and a negative constraint on the other. This splits the search space more effectively.
- Core assumption: Positive constraints that force agents to take specific actions can be implemented efficiently in the any-angle setting without compromising optimality.
- Evidence anchors:
  - [section V-B] Explains how DS is integrated with MC in AA-CCBS.
  - [section VI] Results show DS and DS+MC3 outperform other variants on harder instances.
- Break condition: If landmark actions are too restrictive or lead to dead ends, the search may explore unpromising branches longer than necessary.

## Foundational Learning

- Concept: Conflict-Based Search (CBS) and its variants
  - Why needed here: AA-CCBS is built on CCBS, which is itself an extension of CBS to continuous time. Understanding CBS's high-level search and low-level planning separation is essential.
  - Quick check question: In CBS, what is the purpose of the high-level search tree, and how does it differ from the low-level pathfinding?

- Concept: Safe Interval Path Planning (SIPP) and its any-angle variant TO-AA-SIPP
  - Why needed here: The low-level planner in AA-CCBS uses TO-AA-SIPP to find optimal any-angle paths that respect constraints. Knowing how SIPP handles dynamic obstacles helps understand the constraint integration.
  - Quick check question: How does SIPP represent safe time intervals, and why is this representation useful for handling CCBS constraints?

- Concept: Multi-agent pathfinding (MAPF) variants and optimization criteria
  - Why needed here: AA-MAPF is a variant of MAPF with any-angle moves. Understanding the standard MAPF problem, its complexity, and common optimization goals (sum-of-costs, makespan) provides context for the contributions.
  - Quick check question: What is the difference between sum-of-costs and makespan optimization in MAPF, and how might the choice affect algorithm design?

## Architecture Onboarding

- Component map:
  - High-level search: Best-first search over constraint trees (CCBS framework)
  - Low-level planner: TO-AA-SIPP for optimal any-angle paths with constraints
  - Conflict resolution: MC variants (MC1, MC2, MC3) and DS for enhanced pruning
  - Bounded-suboptimal extension: Focal search wrapper for controlled trade-offs

- Critical path:
  1. Initialize all agents with unconstrained paths using TO-AA-SIPP
  2. Detect conflicts between agent paths
  3. Resolve conflicts using MC and/or DS to generate child nodes
  4. Repeat until a conflict-free solution is found or time limit is reached

- Design tradeoffs:
  - Any-angle vs. grid-based moves: Any-angle allows shorter paths but increases branching factor and computational cost
  - MC variants: MC1 is simpler but may be weaker; MC2 and MC3 are stronger but require more computation to construct
  - DS vs. no DS: DS reduces branching but may increase solution cost due to landmark constraints
  - Optimal vs. bounded-suboptimal: Optimal guarantees best solution but may be slow; bounded-suboptimal is faster but sacrifices solution quality

- Failure signatures:
  - High memory usage: Large branching factor from any-angle moves or excessive constraint tree growth
  - Slow convergence: Weak constraints that fail to prune search effectively
  - Inconsistent results: Bugs in constraint propagation or unsafe interval computation
  - Suboptimal solutions: Incorrect integration of DS or MC leading to lost optimality guarantees

- First 3 experiments:
  1. Run AA-CCBS on a small, simple MAPF instance (e.g., 2-3 agents on empty-16-16) and verify it finds the optimal solution.
  2. Compare AA-CCBS with and without MC3 on a medium-sized instance to observe the impact on high-level iterations and runtime.
  3. Test the bounded-suboptimal variant with w=1.1 on a hard instance to confirm it solves more problems than the optimal variant within the time limit.

## Open Questions the Paper Calls Out

### Open Question 1
- Question: How can the integration of disjoint splitting with multi-constraints in AA-CCBS be improved to avoid the loss of pruning power observed in the bounded-suboptimal variant?
- Basis in paper: [explicit] The paper notes that the poor results of DS in the bounded-suboptimal variant may be due to the positive constraints it imposes, which often do not lead to immediately eliminating the conflict that causes these constraints.
- Why unresolved: The paper suggests that DS loses much of its power in the bounded-suboptimal variant because the search is more greedy by design and the branching factor becomes much less important. However, it does not provide a concrete solution to this issue.
- What evidence would resolve it: Developing a method to integrate DS with MC in a way that maintains the pruning power of DS in the bounded-suboptimal variant, and demonstrating through experiments that this integration improves the performance of AA-CCBS in terms of both success rate and solution cost.

### Open Question 2
- Question: What are the specific conditions under which MC3 outperforms DS and DS+MC3 in terms of high-level iterations, and can these conditions be generalized to other MAPF instances?
- Basis in paper: [explicit] The paper shows that MC3 outperforms all other variants of AA-CCBS if the time limit is between 0.01 and 0.1 seconds, while DS and DS+MC3 outperform MC3 when the time limit is higher. It also notes that in nearly half of the instances MC3 requires fewer high-level iterations than DS and DS+MC3.
- Why unresolved: The paper does not provide a detailed analysis of the specific conditions under which MC3 is more effective, nor does it generalize these conditions to other MAPF instances.
- What evidence would resolve it: Conducting a comprehensive analysis of the MAPF instances where MC3 outperforms DS and DS+MC3, identifying the common characteristics of these instances, and testing whether these characteristics can be used to predict the performance of MC3 on new MAPF instances.

### Open Question 3
- Question: How can the procedures for forming multi-constraints in AA-CCBS be further optimized to reduce the number of high-level iterations and improve the scalability of the algorithm?
- Basis in paper: [explicit] The paper suggests that more sophisticated procedures of forming multi-constraints could be explored in future work, but does not provide specific suggestions.
- Why unresolved: The paper does not provide concrete suggestions for optimizing the procedures for forming multi-constraints, nor does it explore the potential impact of these optimizations on the performance of AA-CCBS.
- What evidence would resolve it: Developing and testing new procedures for forming multi-constraints in AA-CCBS, and demonstrating through experiments that these procedures reduce the number of high-level iterations and improve the scalability of the algorithm.

## Limitations

- The algorithm assumes disk-shaped agents and computationally feasible collision detection, which may not hold in all environments.
- Performance degrades significantly on larger instances with many agents due to the exponential branching factor inherent to any-angle moves.
- The experimental evaluation uses only five MovingAI maps, limiting external validity and generalizability.

## Confidence

- **Algorithmic framework and experimental methodology**: High
- **Performance claims (30% improvement, 123% more instances solved)**: Medium
- **Bounded-suboptimal claims**: High

## Next Checks

1. **Reproduce scalability results**: Run AA-CCBS with DS+MC3 on instances with 50-100 agents from different map types to verify the claimed performance improvements and identify breaking points.

2. **Validate optimality preservation**: Implement a verification tool that checks whether solutions found by AA-CCBS are indeed optimal by comparing against known optimal solutions for small instances.

3. **Benchmark against grid-based MAPF**: Compare AA-CCBS with the best-performing grid-based MAPF algorithms on the same instances to quantify the trade-off between solution quality and computational cost.