---
ver: rpa2
title: Through the Looking Glass, and what Horn Clause Programs Found There
arxiv_id: '2407.20413'
source_url: https://arxiv.org/abs/2407.20413
tags:
- horn
- dual
- clause
- clauses
- programs
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: The paper revisits Dual Horn clauses as a constructive negation
  mechanism that provides variable bindings explaining why a statement is falsified.
  Unlike negation as failure, which lacks explanations and has high complexity in
  ASP systems, Dual Horn clause programs support goal-driven forward reasoning and
  have polynomial complexity.
---

# Through the Looking Glass, and what Horn Clause Programs Found There

## Quick Facts
- arXiv ID: 2407.20413
- Source URL: https://arxiv.org/abs/2407.20413
- Authors: Paul Tarau
- Reference count: 28
- One-line primary result: Dual Horn clauses provide constructive negation with polynomial complexity for propositional programs, enabling explainable reasoning chains in LLM-generated propositional programs

## Executive Summary
This paper explores Dual Horn clauses as a constructive negation mechanism that provides variable bindings explaining why a statement is falsified. Unlike negation as failure, which lacks explanations and has high complexity in ASP systems, Dual Horn clause programs support goal-driven forward reasoning and have polynomial complexity. The authors introduce SymLP, an embedded language combining Horn and Dual Horn clauses, implemented via compilation to Prolog. They demonstrate reasoning patterns like default reasoning, theory falsification, and negation as failure. As an application, LLM-generated propositional Horn and Dual Horn clause programs enhance Generative AI with explainable reasoning chains. The approach ensures tractability for large programs and offers a straightforward semantics for reasoning with positive and negative information.

## Method Summary
The paper presents a method for implementing Dual Horn clauses as a constructive negation mechanism in Prolog. It introduces SymLP, an embedded language that combines Horn and Dual Horn clauses through Prolog modules and term expansion. The key technique involves compiling Dual Horn clauses to equivalent Horn clauses, which are then executed using a dual-use meta-interpreter. This approach preserves polynomial complexity for propositional programs while providing explanations for falsified statements. The method is demonstrated through applications in default reasoning, theory falsification, and negation as failure, with LLM-generated propositional programs serving as a motivating example.

## Key Results
- Dual Horn clauses provide constructive negation with polynomial complexity for propositional programs
- SymLP language successfully combines Horn and Dual Horn clauses in a single Prolog module
- LLM-generated propositional programs using Dual Horn clauses enable explainable reasoning chains
- The approach maintains tractability for large programs while offering straightforward semantics for reasoning with positive and negative information

## Why This Works (Mechanism)

### Mechanism 1
- Claim: Dual Horn clauses enable constructive negation with polynomial complexity for propositional programs.
- Mechanism: By flipping literals and disjunctions to conjunctions, Dual Horn clauses are compiled into Horn clauses. The metainterpreter succeeds in falsifying a goal if and only if the corresponding Horn program would succeed in proving it, preserving polynomial complexity.
- Core assumption: The translation from Dual Horn to Horn clauses is correct and maintains the logical equivalence needed for the metainterpreter to work.
- Evidence anchors:
  - [abstract]: "With Dual Horn clause programs, by contrast to negation as failure, the variable bindings in their computed answers provide explanations for the reasons why a statement is successfully falsified. Moreover, in the propositional case, by contrast to negation as failure as implemented with stable models semantics in ASP systems, and similarly to Horn clause programs, Dual Horn clause programs have polynomial complexity."
  - [section]: "We will implement it here using Prolog's term expansion that overloads the Prolog reader with a call to a compile clauses(SymLPclause,EquivalentPrologclause). The key idea is to convert Dual Horn clauses occurring in a Prolog program to corresponding Horn clauses that, when executed, follow the semantics specified by the dual-use meta-interpreter."
- Break condition: If the translation fails to preserve logical equivalence or the metainterpreter does not correctly simulate goal-driven falsification.

### Mechanism 2
- Claim: The SymLP language combines Horn and Dual Horn clauses in a single Prolog module, enabling explainable reasoning with both positive and negative facts.
- Mechanism: By placing Horn clause predicates in module "true" and Dual Horn clause predicates in module "false", the language maintains disjoint predicate symbols, allowing safe cohabitation. This enables queries that mix proving and disproving goals.
- Core assumption: The module separation ensures no predicate name conflicts and the Prolog term expansion mechanism correctly compiles Dual Horn clauses to Horn clauses in the "false" module.
- Evidence anchors:
  - [abstract]: "As a (motivating) application, we cast LLM reasoning chains into propositional Horn and Dual Horn clauses that work together to constructively prove and disprove goals and enhance Generative AI with explainability of reasoning chains."
  - [section]: "The next step is to design a mechanism for the 'safe cohabitation' of Horn clauses and Dual Horn clauses in the same program. To ensure that their predicates defining rules and facts are disjoint... we will place the Horn clause component in module true and the Dual Horn clause component in module false."
- Break condition: If module separation fails or term expansion does not correctly handle complex Horn and Dual Horn clause programs.

### Mechanism 3
- Claim: LLM-generated Dual Horn clause programs provide a scalable and explainable alternative to traditional reasoning methods in Generative AI.
- Mechanism: LLMs recursively explore topics to generate large sets of positive and negative facts and rules, which are exported as Prolog programs. The polynomial complexity of Dual Horn programs ensures tractability for large programs.
- Core assumption: LLMs can generate high-quality propositional Horn and Dual Horn clauses that accurately represent reasoning chains and the resulting programs are semantically correct.
- Evidence anchors:
  - [abstract]: "As an (motivating) application, we cast LLM reasoning chains into propositional Horn and Dual Horn clauses that work together to constructively prove and disprove goals and enhance Generative AI with explainability of reasoning chains."
  - [section]: "Given the ability to steer an LLM to explore recursively a given topic while staying focussed on the objective specified by an initiator goal... the LLM can be used to generate large sets of high quality positive or negative facts as well as rules describing their inference steps, to be all exported as a Prolog program."
- Break condition: If LLM-generated programs are semantically incorrect or the scale of generated programs exceeds the polynomial complexity guarantees.

## Foundational Learning

- Concept: Constructive negation
  - Why needed here: Understanding how Dual Horn clauses provide explanations for why a statement is false, unlike negation as failure.
  - Quick check question: How does constructive negation in Dual Horn clauses differ from negation as failure in Prolog?

- Concept: Logic program compilation
  - Why needed here: Understanding how Dual Horn clauses are compiled into Horn clauses for execution in Prolog.
  - Quick check question: What is the key transformation applied to Dual Horn clauses during compilation?

- Concept: Prolog modules and term expansion
  - Why needed here: Understanding how SymLP uses Prolog modules to separate Horn and Dual Horn clauses and how term expansion is used for compilation.
  - Quick check question: How does Prolog's term expansion mechanism enable the SymLP language to combine Horn and Dual Horn clauses?

## Architecture Onboarding

- Component map:
  - LLM generator -> Prolog modules (true/false) -> Compilation module -> Metainterpreter -> Results with explanations

- Critical path:
  1. LLM generates reasoning chain as propositional Horn and Dual Horn clauses.
  2. SymLP language compiles Dual Horn clauses to Horn clauses using term expansion.
  3. Metainterpreter executes compiled program to prove or disprove goals.
  4. Results are returned with explanations for why goals were proved or disproved.

- Design tradeoffs:
  - Using Prolog modules for separation ensures no predicate name conflicts but requires careful management of module dependencies.
  - Compiling Dual Horn clauses to Horn clauses enables use of existing Prolog engines but requires correct translation logic.
  - LLM-generated programs provide scalability but rely on LLM quality and may introduce errors.

- Failure signatures:
  - Prolog compilation errors due to incorrect term expansion or module separation.
  - Metainterpreter failures due to incorrect translation of Dual Horn clauses or unsupported clause structures.
  - Incorrect results due to errors in LLM-generated programs or semantic mismatches during compilation.

- First 3 experiments:
  1. Test compilation of simple Dual Horn clauses to Horn clauses and verify metainterpreter correctness.
  2. Test SymLP language with a small mixed Horn and Dual Horn program, ensuring module separation works.
  3. Test LLM-generated program execution with a small reasoning chain, verifying correctness and scalability.

## Open Questions the Paper Calls Out

### Open Question 1
- Question: How does the polynomial complexity of Dual Horn clause programs scale with the size of LLM-generated programs?
- Basis in paper: [explicit] The paper mentions that the polynomial complexity ensures tractability for very large propositional programs generated by LLMs.
- Why unresolved: The paper does not provide specific performance benchmarks or scaling analysis for large-scale LLM-generated Dual Horn clause programs.
- What evidence would resolve it: Empirical studies measuring execution time and memory usage of Dual Horn clause programs with increasing sizes, comparing them to other approaches like ASP or constructive negation.

### Open Question 2
- Question: Can the integration of Dual Horn clauses with soft-unification techniques improve the handling of uncertainty in LLM-generated knowledge bases?
- Basis in paper: [inferred] The paper suggests future work exploring soft-unification and closeness via cosine-similarity to positive or negative facts.
- Why unresolved: The paper does not explore the practical implementation or effectiveness of combining soft-unification with Dual Horn clauses.
- What evidence would resolve it: Experimental results showing improved accuracy or efficiency in reasoning tasks when combining Dual Horn clauses with soft-unification techniques in LLM-generated programs.

### Open Question 3
- Question: How does the performance of Dual Horn clause programs compare to negation as failure in Prolog when handling large-scale default reasoning tasks?
- Basis in paper: [explicit] The paper contrasts Dual Horn clauses with negation as failure, highlighting the explanatory power and polynomial complexity of Dual Horn clauses.
- Why unresolved: The paper does not provide a direct performance comparison between Dual Horn clauses and negation as failure in practical scenarios.
- What evidence would resolve it: Benchmarking studies comparing execution time, memory usage, and explanation quality of Dual Horn clause programs versus negation as failure in Prolog for default reasoning tasks with varying complexity.

## Limitations
- The paper does not provide empirical validation of the approach with actual LLM-generated programs
- Complexity measurements are not provided for non-propositional cases
- The translation from natural language reasoning chains to propositional clauses may introduce semantic errors

## Confidence
- High confidence: The theoretical foundations of Dual Horn clauses and their compilation to Horn clauses
- Medium confidence: The SymLP language design and its ability to combine Horn and Dual Horn clauses
- Medium confidence: The polynomial complexity claims for propositional programs
- Low confidence: The practical effectiveness of LLM-generated programs and their integration with the SymLP framework

## Next Checks
1. Implement a benchmark suite testing the metainterpreter with diverse Dual Horn clause patterns to verify correct compilation and execution behavior
2. Generate a small set of propositional Horn/Dual Horn clauses using an LLM and validate their semantic correctness when executed through the SymLP framework
3. Measure execution time and memory usage for increasingly large propositional Dual Horn programs to empirically verify polynomial complexity bounds