---
ver: rpa2
title: Surrogate Assisted Monte Carlo Tree Search in Combinatorial Optimization
arxiv_id: '2403.09925'
source_url: https://arxiv.org/abs/2403.09925
tags:
- surrogate
- uni00000011
- function
- uni00000013
- node
- transformers
- self-attention
- retrieval-augmented-generation
- instruction-tuning
- parameter-efficient-finetuning
- mixture-of-experts
- chain-of-thought
core_contribution: This paper addresses the problem of store closures in a network
  of retail stores, aiming to minimize the loss of sales resulting from the removal
  of several retail stores. The challenge is that accurately estimating sales is expensive
  and time-consuming.
---

# Surrogate Assisted Monte Carlo Tree Search in Combinatorial Optimization

## Quick Facts
- arXiv ID: 2403.09925
- Source URL: https://arxiv.org/abs/2403.09925
- Authors: Saeid Amiri; Parisa Zehtabi; Danial Dervcic; Michael Cashmore
- Reference count: 13
- Key outcome: Surrogate-assisted MCTS reduces computational cost while maintaining solution consistency for store closure optimization problems.

## Executive Summary
This paper addresses the computational challenge of store closure optimization in retail networks by proposing a surrogate-assisted Monte Carlo Tree Search (SMCTS) approach. The method uses a faster but less accurate surrogate evaluation function for most tree searches, with occasional re-evaluations using the main function to maintain solution quality. Experimental results demonstrate that SMCTS can generate solutions faster than standard MCTS while maintaining consistent solutions as measured by the Sørensen–Dice coefficient, though some inconsistencies appear for problems involving 3-4 store removals.

## Method Summary
The SMCTS approach modifies standard MCTS by introducing a two-tier evaluation system. The algorithm uses a surrogate function Fs for most node evaluations during tree search, which is computationally cheaper than the main evaluation function Fm. When children nodes have been visited equally often, a re-evaluate step checks if neighboring node values are within the surrogate's error bound σs, and if so, replaces them with more accurate Fm evaluations to correct for accumulated errors. The method is applied to store closure problems using the Iowa Liquor Dataset, with XGBoost models trained as both the main and surrogate evaluation functions.

## Key Results
- SMCTS achieves computational speedup by using surrogate evaluations for most nodes, with the ratio of surrogate to main function calls increasing with problem size
- Solution consistency between SMCTS and standard MCTS is maintained for most cases as measured by Sørensen–Dice coefficient
- Inconsistencies emerge for 3-4 store removals due to the surrogate function's weaker estimations in outlier counties

## Why This Works (Mechanism)

### Mechanism 1
- Claim: The surrogate-assisted MCTS (SMCTS) reduces computational cost by replacing expensive evaluations with fast but less accurate surrogate evaluations, with occasional re-evaluations to maintain accuracy.
- Mechanism: The algorithm uses a surrogate function Fs for most node evaluations during tree search, which is computationally cheaper than the main evaluation function Fm. When children nodes have been visited equally often, the Re-evaluate step checks if neighboring node values are within the surrogate's error bound σs, and if so, replaces them with more accurate Fm evaluations to correct for accumulated errors.
- Core assumption: The surrogate function's error bound σs is known and can be used to determine when re-evaluation is necessary to maintain solution quality.
- Evidence anchors:
  - [abstract] "The key idea is to use the surrogate function for most evaluations, with occasional re-evaluations using the main function to refine the node values."
  - [section] "The novelty of SMCTS is in the re-evaluate step where an occasional refinement of node values is done in order to reduce value errors."
- Break condition: If the surrogate function has high error bounds or the re-evaluation step is triggered too frequently, the computational savings diminish and the solution may become inconsistent with pure MCTS.

### Mechanism 2
- Claim: The SMCTS framework maintains solution consistency with standard MCTS by strategically using re-evaluation only when necessary.
- Mechanism: The algorithm monitors when all children of a node have been visited equally often, indicating sufficient exploration. At this point, it sorts the node values and compares adjacent values against the surrogate's error bound. Only when values are within σs of each other does it trigger re-evaluation, ensuring that corrections are made only where surrogate errors might affect decision quality.
- Core assumption: The distribution of node values allows the re-evaluation condition (Vsi+1 − σs < Vsi + σs) to effectively identify nodes where surrogate errors could impact the search outcome.
- Evidence anchors:
  - [section] "Algorithm 2 sorts the values of all children in the subtree... if Vsi+1 − σs is less than Vsi + σs, then these node values need to be updated with Fm."
  - [section] "The number of times that re-evaluate is called would depend on σs and the distribution of node values."
- Break condition: If the surrogate function systematically underestimates or overestimates in specific regions of the search space, the re-evaluation may not occur frequently enough to maintain consistency.

### Mechanism 3
- Claim: The SMCTS approach scales better for larger problems with more stores to remove or more total stores.
- Mechanism: As the problem size increases (more stores or more removals), the tree depth and branching factor increase, making the computational savings from using the faster surrogate function more significant. The re-evaluation step becomes more efficient relative to the total search because it only corrects nodes where errors might affect decisions, rather than evaluating every node with the expensive function.
- Core assumption: The computational complexity of evaluating with Fm grows faster than the cost of managing and occasionally re-evaluating with Fm in SMCTS as problem size increases.
- Evidence anchors:
  - [section] "Figure 2 shows the average ratio of the number of times Fs has been called versus Fm for ten counties... with the increase in the number of removed branches, the relative number of times the surrogate function is called increases."
  - [section] "Figure 3 shows the ratio of surrogate evaluation to the total evaluation using various surrogates with various error bound. With the increase in the error of the surrogate, we observe an increase in the re-evaluation step."
- Break condition: If the problem size increase leads to such deep trees that even the surrogate evaluations become computationally expensive, or if the re-evaluation step becomes too frequent due to high surrogate error, the scaling advantage diminishes.

## Foundational Learning

- Concept: Monte Carlo Tree Search (MCTS) algorithm and its four main steps (Selection, Expansion, Simulation/Evaluation, Backup)
  - Why needed here: The paper builds directly on MCTS by modifying the evaluation step with a surrogate function. Understanding the standard MCTS workflow is essential to grasp how SMCTS differs and why the re-evaluation step is necessary.
  - Quick check question: What are the four main components of standard MCTS, and how does SMCTS modify one of these components?

- Concept: Surrogate modeling and error bounds in machine learning
  - Why needed here: The paper relies on having a faster but less accurate surrogate model with a known error bound. Understanding how surrogate models work and how error bounds are calculated is crucial for understanding when and why re-evaluation occurs.
  - Quick check question: If a surrogate model has a normalized RMSE of 0.27 and the main model has 0.16, what is the error bound σs used in the re-evaluation condition?

- Concept: Combinatorial optimization problems and facility location problems
  - Why needed here: The paper applies SMCTS to a specific combinatorial optimization problem (store closure) within a facility location context. Understanding the problem domain helps in appreciating why computational efficiency is important and how the solution quality is measured.
  - Quick check question: In the store closure problem described, what is the objective function trying to minimize, and what constraint must be satisfied?

## Architecture Onboarding

- Component map:
  - Tree structure: Nodes represent partial solutions (sets of stores to remove)
  - Selection policy: UCB1 for balancing exploration and exploitation
  - Evaluation functions: Two-tier system with fast surrogate Fs and accurate main function Fm
  - Re-evaluation module: Conditional re-evaluation based on error bounds and node visitation patterns
  - Backup mechanism: Value propagation to update parent nodes

- Critical path:
  1. Start at root node
  2. Selection using UCB1 until reaching a leaf or terminal node
  3. Expansion of leaf nodes
  4. Evaluation using surrogate function Fs
  5. Backup of evaluation results
  6. Check if re-evaluation condition is met (all children equally visited)
  7. If yes, trigger re-evaluation module
  8. Return best solution found

- Design tradeoffs:
  - Accuracy vs. speed: Using Fs sacrifices some accuracy for computational efficiency
  - Re-evaluation frequency: Too frequent re-evaluations reduce speed benefits; too infrequent risk solution inconsistency
  - Surrogate quality: Higher quality surrogates (lower σs) require fewer re-evaluations but may be more expensive to compute
  - Exploration vs. exploitation: UCB1 parameter C controls this balance, affecting how quickly the algorithm converges

- Failure signatures:
  - High re-evaluation frequency: Indicates surrogate function has high error or poor correlation with main function
  - Solution inconsistency with MCTS: Suggests surrogate function is inadequate for this problem domain
  - No computational speedup: Could indicate surrogate function is nearly as expensive as main function, or re-evaluation occurs too frequently
  - Premature convergence to suboptimal solutions: May indicate insufficient exploration due to aggressive exploitation in UCB1

- First 3 experiments:
  1. Implement SMCTS with a dummy surrogate function that returns random values within a known error bound, verify that re-evaluation occurs correctly when values are within σs of each other
  2. Compare solution consistency between SMCTS and standard MCTS on a small problem instance (e.g., 5-10 stores, remove 2-3) using a simple evaluation function
  3. Measure computational speedup by running both algorithms on a medium-sized problem (e.g., 20-30 stores, remove 5-10) and recording the ratio of evaluations using Fs vs Fm

## Open Questions the Paper Calls Out

- Question: What are the key criteria for designing an effective surrogate function that balances speed and accuracy in MCTS for combinatorial optimization?
  - Basis in paper: [explicit] The paper states "The choice of an efficient surrogate function is its own research problem" and discusses the trade-off between speed and accuracy of the surrogate function.
  - Why unresolved: The paper uses a pre-defined surrogate function without detailing the process of its creation or the criteria for selecting features and model architecture.
  - What evidence would resolve it: Comparative analysis of different surrogate functions with varying feature sets and model architectures, demonstrating their impact on MCTS performance in terms of speed and accuracy.

## Limitations

- The surrogate function's error bounds may be insufficient for certain problem configurations, leading to solution inconsistencies for 3-4 store removals
- The choice of XGBoost with a subset of features as the surrogate is not justified beyond computational efficiency
- The approach's generalizability to other combinatorial optimization problems beyond store closure is not explored

## Confidence

- **High confidence**: The computational speedup mechanism of using surrogate evaluations is well-established and clearly demonstrated through the ratio of surrogate to main function calls.
- **Medium confidence**: The solution consistency claims are supported by Sørensen–Dice coefficient measurements, but the inconsistencies for 3-4 branch removals indicate limitations in the approach.
- **Medium confidence**: The scaling benefits for larger problems are demonstrated but rely on the assumption that computational savings from the surrogate outweigh the overhead of re-evaluation.

## Next Checks

1. **Error bound sensitivity analysis**: Systematically vary the error bound σs to determine the optimal tradeoff between computational speedup and solution consistency across different problem sizes.
2. **Surrogate model ablation**: Replace the XGBoost surrogate with alternative models (linear regression, neural networks) to determine if different surrogate architectures improve consistency without sacrificing speed.
3. **Domain transfer validation**: Apply the SMCTS framework to a different combinatorial optimization problem (e.g., vehicle routing or facility location) to test the generalizability of the approach beyond the store closure domain.