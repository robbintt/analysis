# Herb.jl: A Unifying Program Synthesis Library

*Tilman Hinnerichs; Reuben Gardos Reid; Jaap de Jong; Bart Swinkels; Pamela Wochner; Nicolae Filat; Tudor Magurescu; Issa Hanou; Sebastijan Dumancic*

---

### üìä Quick Facts

| Metric | Details |
| :--- | :--- |
| **Quality Score** | 9/10 |
| **Citations** | 15 References |
| **Language** | Julia |
| **Core Modules** | 4 (Specification, Grammar, Interpret, Constraints) |
| **Implementation LOC** | ~80‚Äì140 lines (vs. thousands) |
| **Memory Efficiency** | Up to 10x reduction via Uniform Trees |

---

## üìù Executive Summary

The field of program synthesis is currently plagued by significant fragmentation, where tools and algorithms are developed in isolation without interoperability. This lack of standardization forces researchers to repeatedly implement low-level infrastructure and scaffolding rather than focusing on novel algorithmic contributions. While existing tools differ in specifics, they rely on similar fundamental architectural patterns. The paper argues that this repetition is a major inefficiency slowing down progress, and it establishes the need for a unified, modular framework to lower the barrier to entry and accelerate innovation.

The authors introduce **Herb.jl**, an open-source library written in Julia that decomposes program synthesis algorithms into four modular, extendable sub-compartments: `HerbSpecification`, `HerbGrammar`, `HerbInterpret`, and `HerbConstraints`. Technically, the framework employs a "**Uniform Trees**" data structure that groups operators with identical shapes into single nodes, distinct from standard abstract syntax trees (ASTs). This approach separates syntax from semantics‚Äîadhering to SyGuS (Syntax-Guided Synthesis) principles‚Äîfacilitating syntactic enumeration prior to semantic evaluation.

By leveraging Julia‚Äôs native AST representation and multiple dispatch, Herb.jl allows users to construct synthesis pipelines using components as interchangeable building blocks. The authors validated the framework through a rigorous three-step process: implementing a basic problem/grammar pair, re-implementing established synthesizers, and executing standard benchmarks.

Concrete quantitative results demonstrate the library's efficiency:
*   Re-implementations of existing synthesizers required drastically less code (**FrAngel** in ~80 lines, **Probe** in ~84 lines, and **Neo** in ~140 lines).
*   The Uniform Trees structure reduced memory overhead by **up to 10x** compared to naive AST representations.
*   High modularity: required only **two code modifications** to switch search strategies (e.g., depth-first to stochastic).

Herb.jl represents a pivotal standardization effort for program synthesis infrastructure. By reducing implementation overhead from thousands of lines to double digits and enabling the modular remixing of components, the library shifts the research focus from re-implementing basic scaffolding to advancing algorithmic techniques.

---

## üîç Key Findings

*   **Fragmentation of Tools:** The field suffers from a lack of interoperability, making the reuse and remixing of existing methods tedious.
*   **Common Architectural Patterns:** Current methods rely on similar fundamental building blocks, suggesting a unified modular approach is feasible.
*   **Ease of Re-implementation:** The Herb.jl library enables the re-implementation of previously developed synthesizers using only a few lines of code.
*   **Comprehensive Workflow Support:** The library facilitates the entire synthesis pipeline, ranging from defining custom problems and grammars to running synthesizers against standard benchmarks.

---

## üß™ Methodology

The authors developed **Herb.jl**, a library implemented in the Julia programming language. The strategy involves decomposing synthesis algorithms into modular, communicating, and fully extendable sub-compartments. By treating synthesis components as interchangeable building blocks, the library allows users to construct or modify synthesis pipelines without rewriting low-level code.

The approach was validated through three distinct use cases:
1.  Implementing a basic problem/grammar pair.
2.  Replicating an existing synthesizer with minimal effort.
3.  Executing benchmark tests.

---

## ‚öôÔ∏è Technical Details

Herb.jl is a modular Julia library designed to solve fragmentation in program synthesis tools.

### Core Architecture
The framework comprises four primary modules:
*   **HerbSpecification:** For defining synthesis problems.
*   **HerbGrammar:** For handling grammatical rules.
*   **HerbInterpret:** For semantic evaluation.
*   **HerbConstraints:** For managing constraints.

### Key Technologies
*   **Uniform Trees:** A data structure that groups operators with identical shapes into single nodes to reduce memory usage and facilitate constraint propagation.
*   **SyGuS Principles:** Separates syntax from semantics, allowing syntactic enumeration before semantic evaluation.
*   **Julia Integration:** Utilizes Julia's native AST representation and multiple dispatch for extensibility.
*   **Garden.jl:** A companion package containing re-implementations of synthesizers like Probe, FrAngel, and Neo.

---

## ‚ú® Contributions

*   **Herb.jl:** A unifying, open-source library for program synthesis written in Julia.
*   **Modular Framework:** A standardized architecture that separates synthesis algorithms into extendable sub-compartments, allowing for straightforward application and remixing of modules.
*   **Research Acceleration:** A toolset that significantly lowers the barrier to entry for implementing new synthesizers and applying them to benchmarks.

---

## üìà Results

The experiments focus on qualitative metrics and implementation efficiency rather than raw quantitative performance benchmarks.

*   **Implementation Efficiency:** Re-implementations of existing synthesizers can be achieved in significantly fewer lines of code.
*   **Modularity:** The library demonstrates high modularity, requiring only "two modifications" to switch search strategies (e.g., from depth-first to stochastic).
*   **Benchmark Support:** Supports standard benchmarks through the `HerbBenchmarks` collection, including the SyGuS challenge and Abstract Reasoning Corpus.
*   **Performance:** The use of Uniform Trees is claimed to significantly reduce memory usage (specifically up to 10x in validation).
*   **Specific Metrics:**
    *   FrAngel Re-implementation: ~80 lines
    *   Probe Re-implementation: ~84 lines
    *   Neo Re-implementation: ~140 lines

---
