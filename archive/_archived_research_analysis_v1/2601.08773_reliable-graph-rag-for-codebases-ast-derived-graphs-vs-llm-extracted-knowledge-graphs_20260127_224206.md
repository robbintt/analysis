---
title: 'Reliable Graph-RAG for Codebases: AST-Derived Graphs vs LLM-Extracted Knowledge
  Graphs'
arxiv_id: '2601.08773'
source_url: https://arxiv.org/abs/2601.08773
generated_at: '2026-01-27T22:42:06'
quality_score: 9
citation_count: 40
model_profiles_used:
- default
- fast
model_profiles:
  default:
    provider: cerebras
    name: zai-glm-4.7
    temperature: 1.0
    max_tokens: 150000
  fast:
    provider: cerebras
    name: zai-glm-4.7
    temperature: 1.0
    max_tokens: 150000
---

# Reliable Graph-RAG for Codebases: AST-Derived Graphs vs LLM-Extracted Knowledge Graphs

*Knowledge Graph, Extracted Knowledge, On Shopizer, Reliable Graph, Manideep Reddy, Augmented Generation, Graph Naive, Generated Knowledge, Software Engineer*

---

> ### üìä Quick Facts
>
> *   **Benchmark Dataset:** Shopizer (Java)
> *   **Evaluation Queries:** 15 Architecture and code-tracing queries
> *   **Top Correctness Score:** 15/15 (DKB approach)
> *   **Cost Efficiency:** AST-derived graphs are orders of magnitude cheaper than LLM-based construction
> *   **Coverage Integrity:** DKB achieves 100% consistency vs. Probabilistic Incompleteness in LLMs
> *   **Latency Impact:** Graph-RAG adds only marginal overhead over vector search baseline

---

## üìë Executive Summary

Retrieval-Augmented Generation (RAG) systems face significant limitations when applied to complex software codebases. While standard vector similarity search (Naive RAG) is fast, it fails to capture the intricate structural relationships and architectural flows required for accurate code tracing and comprehension. Although Graph-based RAG (Graph-RAG) offers a theoretical solution by introducing structural context, current implementations often rely on Large Language Models (LLMs) to extract knowledge graphs. This approach introduces a critical reliability issue termed **"probabilistic indexing incompleteness,"** where LLMs non-deterministically skip files or hallucinate edges, resulting in unstable retrieval and prohibitive computational costs.

The authors propose a **Deterministic Knowledge Graph (DKB)** constructed via Abstract Syntax Tree (AST) parsing using Tree-sitter, shifting from generative extraction to static analysis. This method automatically maps source code into a graph structure where nodes represent code entities (classes, methods, files) and edges define structural relationships (extends, implements, calls). To overcome "context flattening," the system employs a sophisticated retrieval algorithm featuring bidirectional graph expansion, predecessor traversal (upstream), and interface-consumer expansion. This architecture enables multi-hop reasoning that strictly follows code logic, ensuring that the retrieval process leverages ground-truth structural data rather than inferred connections.

Evaluated on the Shopizer Java benchmark using a suite of 15 architecture and code-tracing queries, the DKB approach achieved a **perfect correctness score of 15/15**, significantly outperforming both the LLM-Generated Knowledge Graph (LLM-KB) and the No-Graph vector baseline. The study revealed that AST-derived graph construction is orders of magnitude faster and more cost-efficient than LLM-based extraction while providing 100% corpus coverage. While the No-Graph vector baseline recorded the lowest absolute query latency, it lacked stability on complex tasks. In contrast, Graph-RAG methods introduced only marginal latency overhead relative to the baseline while delivering the necessary context for correct answers on complex architectural queries.

This research provides decisive empirical evidence that static analysis is superior to generative extraction for building reliable code knowledge bases. By quantifying the reliability risks of "probabilistic indexing incompleteness," the paper highlights a fundamental vulnerability in LLM-centric indexing pipelines for software engineering. The findings validate that integrating deterministic structural graph relationships effectively mitigates the limitations of purely lexical vector search, establishing a new standard for building scalable, cost-effective, and high-precision code intelligence systems.

---

## üîë Key Findings

*   **Superior Accuracy of AST-Derived Graphs:** The Deterministic Knowledge Graph (DKB) built via Tree-sitter parsing achieved perfect correctness (15/15) on the Shopizer benchmark, outperforming both LLM-Generated Knowledge Graph and vector baselines.
*   **Significant Cost and Speed Efficiency:** AST-derived graph construction is orders of magnitude faster and cheaper than LLM-based construction.
*   **Probabilistic Incompleteness in LLM Extraction:** LLM-mediated graph generation suffers from reliability issues, skipping a substantial portion of files and yielding lower node coverage.
*   **Latency vs. Correctness Trade-off:** While the No-Graph vector baseline achieved the lowest query latency, it was less stable on complex queries; Graph-RAG methods added marginal latency overhead but provided necessary context.

---

## üî¨ Methodology

The researchers conducted a benchmark study comparing three Retrieval-Augmented Generation (RAG) pipelines on Java codebases:

1.  **No-Graph Naive RAG:** Utilized vector similarity search as a baseline.
2.  **LLM-Generated Knowledge Graph (LLM-KB):** Employed LLMs to probabilistically extract graph structures.
3.  **Deterministic AST-Derived Knowledge Graph (DKB):** Used Tree-sitter for static analysis and parsing.

Evaluation was performed using a suite of 15 architecture and code-tracing queries per repository. The study measured the following metrics:
*   Indexing overhead
*   Query-time latency
*   Corpus coverage
*   Financial cost
*   Answer correctness

---

## ‚öôÔ∏è Technical Details

The paper evaluates three retrieval architectures for code intelligence:

### Architectures
*   **No-Graph Naive RAG:** A vector baseline relying on lexical similarity.
*   **LLM-KB Graph RAG:** A probabilistic approach using generative models for extraction.
*   **DKB (Deterministic Knowledge Graph):** The proposed approach utilizing AST parsing via Tree-sitter.

### DKB Specifics
*   **Graph Composition:**
    *   **Nodes:** Classes, methods, and files.
    *   **Edges:** Structural relationships such as `extends`, `implements`, and `calls`.
    *   **Consistency:** Achieves 100% consistency compared to the non-deterministic nature of LLMs.
*   **Retrieval Algorithm:**
    *   **Bidirectional Graph Expansion:** Navigates relationships in multiple directions.
    *   **Predecessor Traversal (Upstream):** Traces the flow of data and control backward.
    *   **Interface-Consumer Expansion:** Addresses 'context flattening' by connecting interfaces to their implementations.
    *   **Multi-hop Reasoning:** Enables complex logic tracing that strict lexical similarity cannot handle.

---

## üìà Results

Evaluated on the Shopizer benchmark, the DKB approach achieved **perfect correctness (15/15)**, significantly outperforming both the LLM-KB and vector baselines.

*   **Performance:** DKB construction was orders of magnitude faster and cheaper than LLM-based graph construction while providing complete coverage, contrasting with the 'probabilistic incompleteness' of LLM-KB.
*   **Latency:** Although the vector baseline had the lowest absolute latency, Graph-RAG methods added only marginal latency while ensuring correctness on complex architectural queries through predecessor traversal and interface boundary expansion.

---

## ‚úÖ Contributions

*   **Empirical Evidence for Static Analysis over Generative Extraction:** Demonstrated that deterministic AST parsing is more reliable and cost-effective than using LLMs to extract graph structures.
*   **Quantification of Reliability Risks:** Exposed and quantified 'probabilistic indexing incompleteness,' a failure mode in LLM-mediated indexing.
*   **Validation of Graph-RAG for Software Engineering:** Confirmed that integrating structural graph relationships mitigates vector search limitations and improves performance on complex code tracing.

---

**Report Details:**  
Quality Score: `9/10`  
References: `40 citations`